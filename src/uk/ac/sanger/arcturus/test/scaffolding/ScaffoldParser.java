package scaffolding;

import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.event.*;

import java.awt.Dimension;
import java.awt.GridLayout;

import java.io.*;
import java.util.*;
import java.text.*;

import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;

public class ScaffoldParser {
    public static void main(String[] args) {
	if (args.length < 1) {
	    System.err.println("You must provide an XML file name");
	    System.exit(1);
	}

        XmlToTree handler = new XmlToTree();
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setValidating(true);

	try {
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse( new File(args[0]), handler);
        } catch (SAXParseException spe) {
           // Error generated by the parser
           System.err.println("\n** Parsing error"
              + ", line " + spe.getLineNumber()
              + ", uri " + spe.getSystemId());
           System.err.println("   " + spe.getMessage() );

           // Use the contained exception, if any
           Exception  x = spe;
           if (spe.getException() != null)
               x = spe.getException();
           x.printStackTrace();

        } catch (SAXException sxe) {
           // Error generated by this application
           // (or a parser-initialization error)
           Exception  x = sxe;
           if (sxe.getException() != null)
               x = sxe.getException();
           x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
           // I/O error
           ioe.printStackTrace();
        }

	final Assembly assembly = handler.getAssembly();
	
	//assembly.displayIndented("    ", 0, System.out);

        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createAndShowGUI(assembly);
            }
        });
    }

    private static void createAndShowGUI(Assembly assembly) {
        //Make sure we have nice window decorations.
        JFrame.setDefaultLookAndFeelDecorated(true);

        //Create and set up the window.
        JFrame frame = new JFrame("ScaffoldTree");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        //Create and set up the content pane.
        ScaffoldTree newContentPane = new ScaffoldTree(assembly);
        newContentPane.setOpaque(true); //content panes must be opaque
        frame.setContentPane(newContentPane);

        //Display the window.
        frame.pack();
        frame.setVisible(true);
    }
}

class Core {
    protected Vector children = new Vector();

    public void add(Object object) {
	children.add(object);
    }

    public int getChildCount() {
	return children.size();
    }

    public Enumeration elements() {
	return children.elements();
    }

    public void displayIndented(String prefix, int indentLevel, PrintStream ps) {
	for (int i = 0; i < indentLevel; i++)
	    ps.print(prefix);

	ps.println(this);

	if (children.size() > 0) {
	    ps.println();

	    for (int i = 0; i < indentLevel; i++)
		ps.print(prefix);

	    ps.println(prefix + "CONTAINS");

	    for (Enumeration e = children.elements(); e.hasMoreElements() ;) {
		Object child = e.nextElement();
		if (child instanceof Core) {
		    ps.println();
		    Core coreChild = (Core)child;

		    coreChild.displayIndented(prefix, indentLevel + 1, ps);
		} else {
		    ps.println();
		    for (int i = 0; i < indentLevel + 1; i++)
			ps.print(prefix);
		    ps.println(child);
		}
	    }
	}
    }
}

class Assembly extends Core {
    private String instance = null;
    private String organism = null;
    private Date created = null;

    public Assembly(String instance, String organism, String created) {
	this.instance = instance;
	this.organism = organism;
	SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-DD HH:mm:ss");
	try {
	    this.created = df.parse(created);
	}
	catch (ParseException pe) {
	    System.err.println("ParseException parsing \"" + created + "\"");
	    this.created = null;
	}
    }

    public String getInstance() { return instance; }

    public String getOrganism() { return organism; }

    public Date getCreated() { return created; }

    public String toString() {
	return "Assembly[instance=" + instance + ", organism=" +
	    organism + ", created=" + created + "]";
    }
}

class SuperScaffold extends Core {
    private int id = -1;
    private int size = 0;

    public SuperScaffold(int id, int size) {
	this.id = id;
	this.size = size;
    }

    public int getId() { return id; }

    public int getSize() { return size; }

    public String toString() {
	return "SuperScaffold[id=" + id + ", size=" + size + "]";
    }
}

class Scaffold extends Core {
    private int id = -1;
    private boolean forward = true;

    public Scaffold(int id, boolean forward) {
	this.id = id;
	this.forward = forward;
    }

    public int getId() { return id; }

    public boolean isForward() { return forward; }

    public String toString() {
	return "Scaffold[id=" + id + ", sense=" +
	    (forward ? "F" : "R") + "]";
    }
}

class Contig {
    private int id = -1;
    private int size = 0;
    private int project = -1;
    private boolean forward = true;

    public Contig(int id, int size, int project, boolean forward) {
	this.id = id;
	this.size = size;
	this.project = project;	this.forward = forward;
    }

    public int getId() { return id; }

    public int getSize() { return size; }

    public int getProject() { return project; }

    public boolean isForward() { return forward; }

    public String toString() {
	return "Contig[id=" + id +
	    ", size=" + size +
	    ", project=" + project +
	    ", sense=" + (forward ? "F" : "R") + "]";
    }
}

class Gap extends Core {
    private int size = -1;

    public Gap(int size) {
	this.size = size;
    }

    public int getSize() { return size; }

    public String toString() {
	int nBridges = children.size();

	if (nBridges > 0)
	    return "Gap[size=" + size + ", " + nBridges + " bridges]";
	else
	    return "Gap[size=" + size + ", no bridges]";
    }
}

class SuperBridge extends Core {
    protected int template_id = -1;
    protected int silow = -1;
    protected int sihigh = -1;
    protected Link linka = null;
    protected Link linkb = null;

    public SuperBridge(int template_id, int silow, int sihigh,
		  Link linka, Link linkb) {
	this.template_id = template_id;
	this.silow = silow;
	this.sihigh = sihigh;
	this.linka = linka;
	this.linkb = linkb;
    }

    public SuperBridge(int template_id, int silow, int sihigh) {
	this.template_id = template_id;
	this.silow = silow;
	this.sihigh = sihigh;
    }

    public boolean addLink(Link link) {
	if (linka == null) {
	    linka = link;
	    return true;
	}

	if (linkb == null) {
	    linkb = link;
	    return true;
	}

	return false;
    }

    public int getTemplateId() { return template_id; }

    public int getSilow() { return silow; }

    public int getSihigh() { return sihigh; }

    public Link getLinkA() { return linka; }

    public Link getLinkB() { return linkb; }

    public String toString() {
	return "SuperBridge[template_id=" + template_id +
	    ", silow=" + silow +
	    ", sihigh=" + sihigh +
	    ", linka=" + linka + ", linkb=" + linkb + "]";
    }
}

class Bridge extends SuperBridge {
    private int gapsize = -1;

    public Bridge(int template_id, int silow, int sihigh, int gapsize,
		  Link linka, Link linkb) {
	super(template_id, silow, sihigh, linka, linkb);
	this.gapsize = gapsize;
    }

    public Bridge(int template_id, int silow, int sihigh, int gapsize) {
	super(template_id, silow, sihigh);
	this.gapsize = gapsize;
    }

    public int getGapSize() { return gapsize; }

    public String toString() {
	return "Bridge[template_id=" + template_id +
	    ", silow=" + silow +
	    ", sihigh=" + sihigh +
	    ", gapsize=" + gapsize +
	    ", linka=" + linka + ", linkb=" + linkb + "]";
    }
}
    
class Link {
    private int contig_id = -1;
    private int read_id = -1;
    private int cstart = -1;
    private int cfinish = -1;
    private boolean forward = true;

    public Link(int contig_id, int read_id, int cstart, int cfinish,
		boolean forward) {
	this.contig_id = contig_id;
	this.read_id = read_id;
	this.cstart = cstart;
	this.cfinish = cfinish;
	this.forward = forward;
    }

    public int getContigId() { return contig_id; }

    public int getReadId() { return read_id; }

    public int getCStart() { return cstart; }

    public int getCFinish() { return cfinish; }

    public boolean isForward() { return forward; }

    public String toString() {
	return "Link[contig=" + contig_id +
	    ", read=" + read_id +
	    ", cstart=" + cstart +
	    ", cfinish=" + cfinish +
	    ", sense=" + (forward ? "F" : "R") + "]";
    }
}

class XmlToTree extends DefaultHandler {
    protected SAXParserFactory factory = null;
    protected SAXParser saxParser = null;

    public static final int ASSEMBLY = 1;
    public static final int SUPERSCAFFOLD = 2;
    public static final int SCAFFOLD = 3;
    public static final int CONTIG = 4;
    public static final int GAP = 5;
    public static final int BRIDGE = 6;
    public static final int SUPERBRIDGE = 7;
    public static final int LINK = 8;

    protected Assembly lastAssembly = null;
    protected SuperScaffold lastSuperScaffold = null;
    protected Scaffold lastScaffold = null;
    protected Gap lastGap = null;
    protected Bridge lastBridge = null;
    protected SuperBridge lastSuperBridge = null;

    public void startDocument() throws SAXException {
	lastAssembly = null;
	lastSuperScaffold = null;
	lastScaffold = null;
	lastGap = null;
	lastBridge = null;
	lastSuperBridge = null;
    }

    public void endDocument() throws SAXException {
    }

    public Assembly getAssembly() {
	return lastAssembly;
    }

    private int getTypeCode(String lName, String qName) {
	if (lName != null && lName.length() > 0)
	    return getTypeCode(lName);
	else if (qName != null && qName.length() > 0)
	    return getTypeCode(qName);
	else
	    return -1;
    }

    private int getTypeCode(String name) {
	if (name.equals("contig"))
	    return CONTIG;

	if (name.equals("gap"))
	    return GAP;

	if (name.equals("bridge"))
	    return BRIDGE;

	if (name.equals("link"))
	    return LINK;

	if (name.equals("scaffold"))
	    return SCAFFOLD;

	if (name.equals("superscaffold"))
	    return SUPERSCAFFOLD;

	if (name.equals("superbridge"))
	    return SUPERBRIDGE;

	if (name.equals("assembly"))
	    return ASSEMBLY;

	return -1;
    }

    public void startElement(String namespaceURI,
                             String lName, // local name
                             String qName, // qualified name
                             Attributes attrs)
    throws SAXException {
	int type = getTypeCode(lName, qName);

	switch (type) {
	case ASSEMBLY:
	    lastAssembly = makeAssembly(attrs);
	    break;

	case SUPERSCAFFOLD:
	    lastSuperScaffold = makeSuperScaffold(attrs);
	    lastAssembly.add(lastSuperScaffold);
	    break;

	case SCAFFOLD:
	    lastScaffold = makeScaffold(attrs);
	    lastSuperScaffold.add(lastScaffold);
	    break;

	case CONTIG:
	    Contig contig = makeContig(attrs);
	    lastScaffold.add(contig);
	    break;

	case GAP:
	    lastGap = makeGap(attrs);
	    lastScaffold.add(lastGap);
	    break;

	case BRIDGE:
	    lastBridge = makeBridge(attrs);
	    lastGap.add(lastBridge);
	    break;

	case SUPERBRIDGE:
	    lastSuperBridge = makeSuperBridge(attrs);
	    lastSuperScaffold.add(lastSuperBridge);
	    break;

	case LINK:
	    Link link = makeLink(attrs);
	    if (lastBridge != null)
		lastBridge.addLink(link);
	    else if (lastSuperBridge != null)
		lastSuperBridge.addLink(link);
	    break;
	}
    }

    public void endElement(String namespaceURI,
                           String lName, // local name
                           String qName  // qualified name
                          )
    throws SAXException {
	int type = getTypeCode(lName, qName);

	switch (type) {
	case ASSEMBLY:
	    break;

	case SUPERSCAFFOLD:
	    lastSuperScaffold = null;
	    break;

	case SCAFFOLD:
	    lastScaffold = null;
	    break;

	case CONTIG:
	    break;

	case GAP:
	    lastGap = null;
	    break;

	case BRIDGE:
	    lastBridge = null;
	    break;

	case SUPERBRIDGE:
	    lastSuperBridge = null;
	    break;

	case LINK:
	    break;
	}
    }

    public void error(SAXParseException e)
    throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException err)
    throws SAXParseException {
        System.out.println("** Warning"
            + ", line " + err.getLineNumber()
            + ", uri " + err.getSystemId());
        System.out.println("   " + err.getMessage());
    }

    private int getIntegerAttribute(Attributes attrs, String key, int defaultvalue) {
	String s = attrs.getValue(key);

	if (s == null)
	    return defaultvalue;
	else
	    return Integer.parseInt(s);
    }

    private int getIntegerAttribute(Attributes attrs, String key) {
	return getIntegerAttribute(attrs, key, -1);
    }

    private boolean getBooleanAttribute(Attributes attrs, String key, String truevalue) {
	String s = attrs.getValue(key);

	if (s == null)
	    return false;
	else
	    return s.equals(truevalue);
    }

    private boolean getBooleanAttribute(Attributes attrs, String key) {
	return getBooleanAttribute(attrs, key, "true");
    }

    private Assembly makeAssembly(Attributes attrs) {
	String instance = attrs.getValue("instance");
	String organism = attrs.getValue("organism");
	String created = attrs.getValue("date");

	return new Assembly(instance, organism, created);
    }

    private SuperScaffold makeSuperScaffold(Attributes attrs) {
	int id = getIntegerAttribute(attrs, "id");
	int size = getIntegerAttribute(attrs, "size");

	return new SuperScaffold(id, size);
    }

    private Scaffold makeScaffold(Attributes attrs) {
	int id = getIntegerAttribute(attrs, "id");
	boolean forward = getBooleanAttribute(attrs, "sense", "F");

	return new Scaffold(id, forward);
    }

    private Contig makeContig(Attributes attrs) {
	int id = getIntegerAttribute(attrs, "id");
	int size = getIntegerAttribute(attrs, "size");
	int project_id = getIntegerAttribute(attrs, "project");
	boolean forward = getBooleanAttribute(attrs, "sense", "F");

	return new Contig(id, size, project_id, forward);
    }

    private Gap makeGap(Attributes attrs) {
	int size = getIntegerAttribute(attrs, "size");

	return new Gap(size);
    }

    private SuperBridge makeSuperBridge(Attributes attrs) {
	int template_id = getIntegerAttribute(attrs, "template");
	int silow = getIntegerAttribute(attrs, "silow");
	int sihigh = getIntegerAttribute(attrs, "sihigh");

	return new SuperBridge(template_id, silow, sihigh);
     }

    private Bridge makeBridge(Attributes attrs) {
	int template_id = getIntegerAttribute(attrs, "template");
	int silow = getIntegerAttribute(attrs, "silow");
	int sihigh = getIntegerAttribute(attrs, "sihigh");
	int gapsize = getIntegerAttribute(attrs, "gapsize");

	return new Bridge(template_id, silow, sihigh, gapsize);
    }

    private Link makeLink(Attributes attrs) {
	int contig_id = getIntegerAttribute(attrs, "contig");
	int read_id = getIntegerAttribute(attrs, "read");
	int cstart = getIntegerAttribute(attrs, "cstart");
	int cfinish = getIntegerAttribute(attrs, "cfinish");
	boolean forward = getBooleanAttribute(attrs, "sense", "F");

	return new Link(contig_id, read_id, cstart, cfinish, forward);
    }
}

class ScaffoldTree extends JPanel
    implements TreeSelectionListener {
    private JEditorPane htmlPane;
    private JTree tree;
 
    public ScaffoldTree(Assembly assembly) {
        super(new GridLayout(1,0));

	DefaultMutableTreeNode top = makeTreeFromAssembly(assembly);

        //Create a tree that allows one selection at a time.
        tree = new JTree(top);
        tree.getSelectionModel().setSelectionMode
                (TreeSelectionModel.SINGLE_TREE_SELECTION);

        //Listen for when the selection changes.
        tree.addTreeSelectionListener(this);

        //Create the scroll pane and add the tree to it. 
        JScrollPane treeView = new JScrollPane(tree);

        //Create the HTML viewing pane.
        htmlPane = new JEditorPane();
        htmlPane.setEditable(false);
        JScrollPane htmlView = new JScrollPane(htmlPane);

        //Add the scroll panes to a split pane.
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setTopComponent(treeView);
        splitPane.setBottomComponent(htmlView);

        Dimension minimumSize = new Dimension(100, 50);
        htmlView.setMinimumSize(minimumSize);
        treeView.setMinimumSize(minimumSize);
        splitPane.setDividerLocation(100);

        splitPane.setPreferredSize(new Dimension(500, 300));

        add(splitPane);
    }

    public void valueChanged(TreeSelectionEvent e) {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                           tree.getLastSelectedPathComponent();

        if (node == null) return;

        Object nodeInfo = node.getUserObject();

	System.err.println("Selected " + nodeInfo);
    }

    private DefaultMutableTreeNode makeTreeFromAssembly(Assembly assembly) {
	return createTreeRecursively(assembly);
    }

    private DefaultMutableTreeNode createTreeRecursively(Core parent) {
	DefaultMutableTreeNode parentNode = new DefaultMutableTreeNode(parent, true);

	for (Enumeration e = parent.elements(); e.hasMoreElements() ;) {
	    Object child = e.nextElement();
	    if (child instanceof Core) {
		Core coreChild = (Core)child;
		
		DefaultMutableTreeNode childNode = createTreeRecursively(coreChild);

		parentNode.add(childNode);
	    } else {
		parentNode.add(new DefaultMutableTreeNode(child, false));
	    }
	}

	return parentNode;
    }
}

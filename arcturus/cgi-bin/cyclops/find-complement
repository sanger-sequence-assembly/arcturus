#!/usr/local/bin/perl -w

#############################################################################
# find complementary READ pairs
#############################################################################

use strict;

use GateKeeper; 

##############################################################################
# unbuffered output
##############################################################################

open(STDERR,">&STDOUT") || die "Can't dump to STDOUT: $!\n";
select(STDERR); $| = 1; # Make unbuffered.
select(STDOUT); $| = 1; # Make unbuffered.

# print "content-type:text/plain\n\n";

##############################################################################
# get configuration data, open CGI and MySQL Database
##############################################################################

my $GateKeeper = GateKeeper->new('mysql',0);

my ($cgi, $database, $blocksize, $start, $length, $suffix, $mksession);
if ($cgi = $GateKeeper->cgiHandle(1)) {
    $database  = $cgi->parameter('organism')  || $cgi->parameter('database') || 'arcturus';
    $blocksize = $cgi->parameter('blocksize') || 1000;
    $start     = $cgi->parameter('start')     || 1;
    $length    = $cgi->parameter('length')    || 100000;
    $suffix    = $cgi->parameter('suffix');
    $mksession = !$cgi->MethodGet || 0;
}
else {
    $database  = shift @ARGV;
    $blocksize = shift @ARGV || 1000;
    $start     = shift @ARGV || 1;
    $length    = shift @ARGV || 10000;
    $suffix    = shift @ARGV;
    $mksession = 0;
}

my $organisms  = $GateKeeper->dbHandle($database,{returnTableHandle => 1});

my %options = (makeSession => $mksession, silently => 1, diagnosis => 1, ageWindow => 25);
if (!$GateKeeper->authorize(100,\%options)) {
    my $error = $GateKeeper->{error};
    $GateKeeper->dropDead($error);
}

# decide on the interface to be used

my $brtag = "\n";
my $noGUI = $cgi->parameter('noGUI');
undef my $redirect;

if ($cgi && $database ne 'arcturus' && $noGUI) {
    $GateKeeper->cgiHeader(1); # return string plain
# what about defaults?
}
elsif ($cgi && $noGUI) {
    $GateKeeper->dropDead("Please define a database");
}
elsif ($cgi) {

    my $action = $cgi->parameter('action');
    if (!$action || $action ne 'Search') {
# compose the query form
        $brtag = "<br>";
        my $page = $GateKeeper->GUI("read pairs finder");
        my $host   = $GateKeeper->currentHost;
        my $script = $GateKeeper->currentScript;
        my $head = "Welcome to the Arcturus Read Pairs finder";
        $page->sectionheader($head,3,0);
        my $body = "Read Pairs are identified in the specified database <br>";
        $body   .= "and will be marked";
        $page->add($body,0,1,"color='blue'");
        my $text = "Please specify the search constraints and submit";
        $page->sectionheader($text,3,1);
# the data fields (always allow a change of database)
        my $form = &form;
        my $dbases = $organisms->htmlOptions('dbasename','organism',20,0,$database);
        $form =~ s/DATABASE/$dbases/;
        if ($database ne 'arcturus') {
            my $attribute = $organisms->unpackAttributes($database,'dbasename');
            $blocksize = $attribute->{PRbs} if $attribute->{PRbs};
            $start     = $attribute->{PRst} if $attribute->{PRst};
            $length    = $attribute->{PRlt} if $attribute->{PRlt};
            $suffix    = $attribute->{PRsf} if $attribute->{PRsf};
        }
        $redirect = "${host}pairs" if $cgi->parameter('redirect');
        $page->form($script,0,$redirect); 
        $page->add($form,0,1);        
        $page->preload('blocksize',$blocksize,1);
        $page->preload('start',$start,1);
        $page->preload('length',$length,1);
        $page->preload('suffix',$suffix,1) if $suffix;
#   $cgi->delete('USER');
        $page->ingestCGI;
        my @buttons;
#        push @buttons, 'type=submit value="Redirect" name="redirect"' if !$redirect;
        push @buttons, 'type=submit value="Recall" name="action"';
        push @buttons, 'type=submit value="Search" name="action"';
        push @buttons, 'type=reset  value="Reset"';
        $page->buttonbartemplate(@buttons+0,0,\@buttons);
        $page->form(0);
        $page->flush;
        $GateKeeper->disconnect;
        exit 0;
    }
    $GateKeeper->cgiHeader(1); # line mode on the viewing window
}
elsif ($database eq 'arcturus') {
    $GateKeeper->dropDead("Please define a database");
}

##############################################################################
# MAIN
##############################################################################

print "Okay, authorized! $brtag";

print "database=$database blocksize=$blocksize  start=$start  length=$length ";
print "suffix=$suffix" if $suffix;
print "$brtag";

$GateKeeper->focus(1);

# outline
# scan reads table in blocks of blocksize
# select inside each block those reads without registered counterpart
# search for its complement and put in place the read_id

my $READS   = $organisms->spawn('READS',$database,0,0);
my $PAIRS   = $organisms->spawn('READPAIRS',$database,0,0);
my $STRANDS = $organisms->spawn('STRANDS',$database,0,1);

$READS->setTracer(0); # switch off query tracing
$PAIRS->setMultiLineInsert(10); # block inserts
my $maximum = $READS->count;

# $GateKeeper->disconnect; exit 0; # test mode

my $continue = 1;
my $tlength = $length + $start;
$tlength = $maximum if ($tlength > $maximum);
my $list = 0;

while ($continue) {

    my $final = $start - 1 + $blocksize;
    $final = $tlength if ($final > $tlength);
    print "Processing block $start - $final : ";
    my $tested = 0;
    my $paired = 0;

# get all reads in start-final window from READPAIRS reverse (for usage later)

    undef my $hashes;
    my $where = "read_id >= $start and read_id <= $final and paired='N'";
    if ($hashes = $READS->associate('read_id,readname,template','where',$where)) {
        undef my %readhash;
        if (ref($hashes) eq 'ARRAY') {
            foreach my $hash (@$hashes) {
                $hash->{template} = 'NULL' if !$hash->{template};
                $readhash{$hash->{read_id}}  = $hash->{template}.'&'.$hash->{readname};
            }
        }
        $hashes = \%readhash;
    }
    else {
        $GateKeeper->dropDead("Query FAILED: $READS->{qerror}");
    }

# the keys of $hashes are the readid's of reads not labeled as belonging to a pair

    my @hashes = sort {$a <=> $b;} keys (%$hashes);

    if (!@hashes) {
        print "No (unallocated) data found in block $start -  $final$brtag";
    }
    else {
        my $nr = @hashes;
        print "$nr reads to be investigated$brtag";
    }

    foreach my $readid (@hashes) {
        my ($template,$readname) = split '&',$hashes->{$readid};
        next if !$readname; # previously encountered read
	my $complement = $readname;
        $complement =~ s/\.(\w)/._/;
        my $pstrand = $1;
        $complement .= $suffix if $suffix;
        if ($complement eq $readname) {
            print "Non-standard readname $readname $brtag";
            next;
        }
        $tested++;
        undef my $where;
        if ($template && $template !~ /\b(unknown|NULL)\b/) {
            $where = "template = '$template' and ";
        }
        $where .= "readname != '$readname' and readname like '$complement'";
        my $chash = $READS->associate('read_id,readname','where',$where,-1);
        if (ref($chash) ne 'ARRAY' || @$chash == 0) {
            print "$readid $readname : No complement found$brtag" if ($list > 1);
            next;
        }

        my $warn = 0; $warn = 1 if (@$chash > 1);
        print "   $readid $readname WARNING: several complements found! " if $warn;
        foreach my $hash (@$chash) {

            print "$readid $readname " if ($list && !$warn);
            my $creadname  = $hash->{readname};
            my $complement = $hash->{read_id};

            next if ($creadname =~ /$readname/ || $readname =~ /$creadname/); # same strand

            print "Complement found: $creadname $complement " if $list;
            print "$creadname " if $warn;

            my $pdescription = $STRANDS->associate('description',$pstrand,'strand');
            $pdescription =~ s/^.*\b(forward|reverse)\b.*$/$1/;
            undef my $cstrand; $cstrand = $1 if ($creadname =~ /\.(\w)/);
            undef my $cdescription;
            if ($cstrand) {
                $cdescription = $STRANDS->associate('description',$cstrand,'strand');
                $cdescription =~ s/^.*\b(forward|reverse)\b.*$/$1/;
            }
            else {
                print "$readid $readname " if (!$list && !$warn);
                print "Cannot determine strand in complement $creadname$brtag" if !$list;
                next;
            }

            my ($forward, $reverse);
            if ($pdescription eq 'forward' && $cdescription eq 'reverse') {
                $forward = $readid;
                $reverse = $complement;
            }
            elsif ($cdescription eq 'forward' && $pdescription eq 'reverse') {
                $forward = $complement;
                $reverse = $readid;
            }
            else {
                print "read $readname; mate $creadname: !! identical or undetermined strands!!$brtag";
                next;
            }

            if ($PAIRS->newrow('forward',$forward,'reverse',$reverse)) {
                print "Added to READPAIRS$brtag" if $list;
                $READS->update('paired','F','read_id',$forward);
                $READS->update('paired','R','read_id',$reverse);
                $paired++;
            }
            else {
                print "!! insert error $PAIRS->{errors} !!$brtag";
            }

            $hashes->{$complement} = 0;  # or delete
        }
        print "$brtag" if $warn;
    }

    print "$tested unpaired reads tested; ** $paired ** new pairs found in this block$brtag";

    $start = $final + 1; # preset next cycle
    $continue = 0 if ($start >= $tlength);

}

$PAIRS->flush(); # dump remaining pair entries

# add link for the next block (using a session id!)

if (!$redirect) {
#        my $rreturn = $lreturn;
#        $rreturn =~ s/update/rloader/;
#        $rreturn =~ s/getmenu/specify/;
#        $rreturn .= "\&database=$database\&source=$source\&assemblyname=$assemblyname";
#        $page->linkbutton('LOAD MORE',$rreturn,0);
#        $page->linkbutton('MAIN MENU',$lreturn,0);
#        $page->flush();

}

# pack attributes, preload for subsequent search

$organisms->packAttribute($database,'dbasename','attributes','PRbs',$blocksize);
$organisms->packAttribute($database,'dbasename','attributes','PRst',$start);
$organisms->packAttribute($database,'dbasename','attributes','PRlt',$length);
$organisms->packAttribute($database,'dbasename','attributes','PRsf',$suffix) if $suffix;

my $userid = $cgi->parameter('USER');

$organisms->historyUpdate($userid,'insert',1);

##############################################################################
# EXIT
##############################################################################

$GateKeeper->disconnect();

exit 0;

##############################################################################

sub form {

    my $form;
    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH=50%>";
    $form .= "<TR><TH ALIGN=LEFT>Database</TH><TD>DATABASE</TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT NOWRAP>Starting Position</TH><TD><INPUT VALUE='START' SIZE=7 NAME='start'></TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Length</TH><TD><INPUT VALUE='LENGTH' SIZE=7 NAME='length'></TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Block Size</TH><TD><INPUT VALUE='BLOCK' SIZE=5 NAME='blocksize'></TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Extension Suffix</TH><TD><INPUT NAME='suffix' SIZE=2 VALUE=' '></TD></TR>";
    $form .= "</TABLE>";

    return $form;
}

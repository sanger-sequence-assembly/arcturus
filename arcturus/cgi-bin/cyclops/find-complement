#!/usr/local/bin/perl -w

#############################################################################
# find complementary READ pairs
#############################################################################

use strict;

use GateKeeper; 

##############################################################################
# unbuffered output
##############################################################################

open(STDERR,">&STDOUT") || die "Can't dump to STDOUT: $!\n";
select(STDERR); $| = 1; # Make unbuffered.
select(STDOUT); $| = 1; # Make unbuffered.

##############################################################################
# get configuration data, open CGI and MySQL Database
##############################################################################

my $GateKeeper = GateKeeper->new('mysql',0);

my ($cgi, $database, $blocksize, $start, $length, $suffix);
if ($cgi = $GateKeeper->cgiHandle(1)) {
    $database  = $cgi->parameter('organism');
    $blocksize = $cgi->parameter('blocksize') || 1000;
    $start     = $cgi->parameter('start')     || 1;
    $length    = $cgi->parameter('length')    || 100000;
    $suffix    = $cgi->parameter('suffix');   
}
else {
    $database  = shift @ARGV;
    $blocksize = shift @ARGV || 1000;
    $start     = shift @ARGV || 1;
    $length    = shift @ARGV || 10000;
    $suffix    = shift @ARGV;
}

my $organisms  = $GateKeeper->dbHandle($database,{dbhandle=>0});

my $status = $GateKeeper->authorize(100,{'nosession'=>1, silently=>0});

if (!$status) {
    my $error = $GateKeeper->{error};
    $GateKeeper->dropDead($error);
}

$GateKeeper->cgiHeader(1); # return string plain

##############################################################################
# MAIN
##############################################################################

print "Okay, authorized! \n";

# $start = 43001; $length=1000;
print "database=$database blocksize=$blocksize  start=$start  length=$length ";
print "suffix=$suffix" if $suffix;
print "\n";

$GateKeeper->focus(1);

# outline
# scan reads table in blocks of blocksize
# select inside each block those reads without registered counterpart
# search for its complement and put in place the read_id

my $READS   = $organisms->spawn('READS',$database,0);
my $PAIRS   = $organisms->spawn('READPAIRS',$database,0);
my $STRANDS = $organisms->spawn('STRANDS',$database,1);

$READS->setTracer(0); # switch off query tracing
$PAIRS->setMultiLineInsert(10); # block inserts

my $continue = 1;
$length = $length + $start;
my $list = 0;

while ($continue) {

    my $final = $start - 1 + $blocksize;
    print "Processing block $start - $final : ";
    my $tested = 0;
    my $paired = 0;

# get all reads in start-final window from READPAIRS reverse (for usage later)

    undef my $hashes;
    my $where = "read_id >= $start and read_id <= $final and paired=' '";
    if ($hashes = $READS->associate('read_id,readname,template','where',$where)) {
# print "hashes: $hashes \n";
        undef my %readhash;
        if (ref($hashes) eq 'ARRAY') {
            foreach my $hash (@$hashes) {
                $hash->{template} = 'NULL' if !$hash->{template};
                $readhash{$hash->{read_id}}  = $hash->{template}.'&'.$hash->{readname};
            }
        }
        $hashes = \%readhash;
# print "hashes: $hashes \n";
    }
    else {
        $GateKeeper->dropDead("Query FAILED: $organisms->{qerror}");
    }

# the keys of $hashes are the readid's of reads not labeled as belonging to a pair

    my @hashes = sort {$a <=> $b;} keys (%$hashes);

    if (!@hashes) {
        print "No data found in block $start -  $final\n";
    }
    else {
        my $nr = @hashes;
        print "$nr reads to be investigated\n";
    }

    foreach my $readid (@hashes) {
        my ($template,$readname) = split '&',$hashes->{$readid};
        next if !$readname; # previously encountered read
	my $complement = $readname;
        $complement =~ s/\.(\w)/._/;
        my $pstrand = $1;
        $complement .= $suffix if $suffix;
        if ($complement eq $readname) {
            print "Non-standard readname $readname \n";
            next;
        }
        undef my $where;
        if ($template && $template !~ /\b(unknown|NULL)\b/) {
            $where = "template = '$template' and ";
        }
        $where .= "readname != '$readname' and readname like '$complement'";
        my $chash = $READS->associate('read_id,readname','where',$where,-1);
        if (ref($chash) ne 'ARRAY' || @$chash == 0) {
            print "$readid $readname : No complement found\n" if ($list > 1);
            next;
        }
        $tested++;

        my $warn = 0; $warn = 1 if (@$chash > 1);
        print "\n$readid $readname WARNING: several complements found! " if $warn;
        foreach my $hash (@$chash) {

            print "$readid $readname " if ($list && !$warn);
            my $creadname  = $hash->{readname};
            my $complement = $hash->{read_id};

            next if ($creadname =~ /$readname/ || $readname =~ /$creadname/); # same strand

            print "Complement found: $creadname $complement " if $list;
            print "$creadname " if $warn;

            my $pdescription = $STRANDS->associate('description',$pstrand,'strand');
            $pdescription =~ s/^.*\b(forward|reverse)\b.*$/$1/;
            undef my $cstrand; $cstrand = $1 if ($creadname =~ /\.(\w)/);
            undef my $cdescription;
            if ($cstrand) {
                $cdescription = $STRANDS->associate('description',$cstrand,'strand');
                $cdescription =~ s/^.*\b(forward|reverse)\b.*$/$1/;
            }
            else {
                print "$readid $readname " if (!$list && !$warn);
                print "Cannot determine strand in complement $creadname\n" if !$list;
                next;
            }

            my ($forward, $reverse);
            if ($pdescription eq 'forward' && $cdescription eq 'reverse') {
                $forward = $readid;
                $reverse = $complement;
            }
            elsif ($cdescription eq 'forward' && $pdescription eq 'reverse') {
                $forward = $complement;
                $reverse = $readid;
            }
            else {
                print "\nread $readname; mate $creadname: !! identical or undetermined strands!!\n";
                next;
            }

# print "pair to added to READPAIRS\n";            
            if ($PAIRS->newrow('forward',$forward,'reverse',$reverse)) {
                print "Added to READPAIRS\n" if $list;
                $READS->update('paired','F','read_id',$forward);
                $READS->update('paired','R','read_id',$reverse);
                $paired++;
            }
            else {
                print "!! insert error $PAIRS->{errors} !!\n";
            }

            $hashes->{$complement} = 0;  # or delete
        }
        print "\n" if $warn;
    }

    print "$tested unpaired reads tested; $paired new pairs found in this block\n";

    $start = $final + 1; # preset next cycle
    $continue = 0 if ($start >= $length);

# add a continuation link for the next block (using a session id!)

}

$PAIRS->flush(); # dump remaining pair entries

my $userid = $cgi->parameter('USER');

$organisms->historyUpdate($userid,'insert',1);

##############################################################################
# EXIT
##############################################################################

$GateKeeper->disconnect();




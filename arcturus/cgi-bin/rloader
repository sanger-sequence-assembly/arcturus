#!/usr/local/bin/perl 

#############################################################################
#
# Upload Reads into ARCTURUS database
#
#############################################################################

use strict; # Constraint variables declaration before using them

BEGIN { 
   $ENV{ORACLE_HOME} = '/usr/local/oracle';
   $ENV{ORACLE_SID}  = 'inform';
   $ENV{TWO_TASK}    = 'sids';
   $ENV{PERL5LIB}   .= ':/usr/local/badger/bin';
}

use GateKeeper; 
use ReadsReader;
#use PathogenRepository;

##############################################################################
# unbuffered output
##############################################################################

open(STDERR,">&STDOUT") || die "Can't dump to STDOUT: $!\n";
select(STDERR); $| = 1; # Make unbuffered.
select(STDOUT); $| = 1; # Make unbuffered.

##############################################################################
# get configuration data, open CGI and MySQL Database
##############################################################################

my $GateKeeper = GateKeeper->new('mysql',1);

my $config     = $GateKeeper->configHandle();

my $cgi        = $GateKeeper->cgiHandle(1);

my ($void, $database, $option, $origin, $session);

# how is this script invoked?

if ($cgi) {
   ($void, $database, $option) = split ('/',$GateKeeper->origin());
#   $database = $cgi->parameter('database') if !$database;
#   $database = $cgi->parameter('organism') if !$database;
#   $database = 'arcturus if !$database';
   $option = 'getform' if !$option;
}
else {
   $database = shift @ARGV;
}

my $organisms = $GateKeeper->dbHandle($database,{returnTableHandle => 1});

##############################################################################
# MAIN
##############################################################################

my %config;
$config{RDD} = "<to be defined>";
# $config{RDD} = $config->get("ROOTDATADIR");
$config{SDS} = ''; # default search sub-directories
# $config{SDS} = join ' ',@{$config->get("SEARCH_DIR")}; # default search sub-directories
$config{GMD} = $config->get("GELMINDDIR");
$config{SCF} = $config->get("SCFREADDIR");
$config{EKS} = join ' ',@{$config->get("excludekeys")}; # default reject strings
$config{PRO} = $config->get("PROJECT"); # for Oracle reads
$config{SCH} = $config->get("SCHEMA");  # for Oracle reads
$config{LPR} = $config->get("LOADPERRUN");
$config{FNF} = '';
$config{GBF} = '';

# all of these may be overwritten by 'attributes' data from ORGANISMS or ASSEMBLY 

my $arc_cgi_dir = $config->get('ARC_CGI_DIR');
my $arc_log_dir = $config->get('ARC_LOG_DIR');
my $db_manager  = $config->get('db_manager'); 
my $BADGERDIR   = $config->get('BADGERDIR');

$config{LGF} = "$arc_log_dir/rloader.DATABASE.log"; # default logfile

my ($LOADPERRUN,$GELMINDDIR,$ROOTDATADIR,$SCFREADDIR,$SCHEMA,$PROJECT,$LOGFILE);
my ($FNF, $GBF, @SEARCH_DIR, @excludekeys);

undef my ($action, $page, $confirm);
undef my ($userid  , $project , $assembly, $assemblyname, $assemblynmbr);
undef my ($fnfilter, $gbfilter, $source, $rloader, $forced, $update);
undef my ($arc_logfile, $logON, $TEST);

my $lreturn = "$arc_cgi_dir/update/arcturus/getmenu"; # return link
$session = $cgi->parameter('session',0) if $cgi;
$lreturn .= "\?session=$session" if $session; 

my ($brtag, $gfont, $yfont, $ofont, $rfont, $efont, $bfont);

###############################################################################
# invokation via web: first "getmenu", then the "specify" and "" option
###############################################################################

if ($cgi) {
    $origin = 1;
# used as cgi scripts
    $brtag = "<br>";
    $gfont = "<FONT COLOR=lightgreen>";
    $yfont = "<FONT COLOR=yellow>";
    $ofont = "<FONT COLOR=orange>";
    $rfont = "<FONT COLOR=red>";
    $bfont = "<FONT COLOR=blue>";
    $efont = "</FONT>";

# redefine option if a "specify" option comes with process defined, else get form

    $option = 'process' if ($option eq 'specify' && $cgi->parameter('process',0));

# preprocessing of input info


    undef my $error;
    if ($option eq 'getform') {
        $page = $GateKeeper->GUI('READS loader');
#        $page->address('ejz@sanger.ac.uk','Ed Zuiderwijk',2);
        $page->form("$arc_cgi_dir/rloader/$database/specify");
        $page->add("<BR><BR>ARCTURUS READS loader specifications<P><P>",0,0,"size=+1");
        my %options = (mask=>'011000001111000001',
                       headColor=>'FAFAD2',cellColor=>'CCCCCC',linkColor=>'E2E2FF');
        if ($database eq 'arcturus') {
            my $table = $organisms->htmlTable(\%options);
            $page->add($table,0,0,"size=-1");
            $page->sectionheader("Select a Database and Read specification",4,0);
            $page->add($organisms->htmlOptions('dbasename','database',20,0),0,0);
        }
        else {
            my %options = (mask=>'011000001111000001',
                           headColor=>'FAFAD2',cellColor=>'CCCCCC',linkColor=>'E2E2FF');
            my $table = $organisms->htmlTable(\%options,'dbasename',$database);
            $cgi->addkey('database',$database);
            $page->add($table);
            $page->sectionheader("Select a Read specification",4,0);
        }
        $page->add(&form1(),0,1);
        $page->submitbuttonbar($lreturn,0,0);
        $page->ingestCGI();
        $page->form(0);
        $page->flush();
        $GateKeeper->disconnect;
        exit 0; 
    }
    elsif ($option eq 'specify') {
# get source, database, and whether an assembly choice exists
        $database  = $cgi->parameter('database'); # compulsory
        my $asname = $cgi->parameter('assemblyname',0); # no test
        $asname = 0 if !$asname; # to have it explicitly defined
        if ($organisms->associate('reads_pending',$database,'dbasename')) {
            $source = $cgi->parameter('source');   # compulsory
            my $redirect = "/cgi-bin/rloader/$database/getform";
            $redirect .= $cgi->postToGet()   if $cgi->MethodGet; 
            $GateKeeper->transfer($redirect) if $cgi->MethodGet;
            $GateKeeper->transfer($redirect) if $cgi->{und_error};
        }
        else {
            $source = 0;
            $cgi->addkey('source',0);
        }

        $GateKeeper->cgiHeader(2); # return string HTML under CGI
        $page = $cgi->openPage('ARCTURUS READS loader');
        $page->address('ejz@sanger.ac.uk','Ed Zuiderwijk',2);
        $page->frameborder(100,15,'white',10);
        $page->center(1);

        $page->form("$arc_cgi_dir/rloader/arcturus/specify");
        $page->partition(2);
        $page->sectionheader("ARCTURUS READS loader specification for $database",3,0);
        $page->partition(1);
        if ($source == 0) {
            $page->sectionheader("(Named reads taken from experiment depository)",4,1);
        }
        elsif ($source == 1) {
            $page->sectionheader("(PENDING reads taken from experiment depository)",4,1);
        }
        elsif ($source == 2) {
            $page->sectionheader("(PENDING reads taken from ORACLE)",4,1);
        }

        if ($cgi->{und_error} || !$database) {
            $page->errorbox("Please define all form entries");
            $page->add($cgi->PrintVariables());
        }
        else {
# test if the root data directory is defined
            if (!$config{RDD} || $config{RDD} =~ /to be d/) {
                $config{RDD} = `$BADGERDIR/pfind -q $database`;
#              my $repository = new PathogenRepository;
#              $config{RDD} = $repository->getAssemblyDirectory($database); 
             }
    # open assembly database; abort if no assemblies defined
            $assembly  = $organisms->spawn('ASSEMBLY',$database,0,1);
            if ($assembly && $assembly->count() > 0) {
    # get the default assembly name if no assemblyname in CGI input; first try attributes
		my $attributes = $organisms->unpackAttributes($database,'dbasename');
                $asname = $attributes->{anlast} if (!$asname && $attributes->{anlast});
    # if still undefined, just take the first one
                $asname = $assembly->{hashrefs}->[0]->{assemblyname} if (!$asname); 
    # update the data dir name (if assembly has changed)
                my $target = $asname; $target =~ s/\d+/\\d\+/g;
                $config{RDD} =~ s/$target/$asname/;
    # overwrite the preset configuration data with those in ORGANISM attributes if any
                $config{LGF} =~ s/DATABASE/$database/; # log file
                foreach my $key (keys %config) {
                    $config{$key} = $attributes->{$key} if defined($attributes->{$key});
                }
    # overwrite the preset configuration data with those in ASSEMBLY attributes if any
		$attributes = $assembly->unpackAttributes($asname,'assemblyname');
                foreach my $key (keys %config) {
                    $config{$key} = $attributes->{$key} if defined($attributes->{$key});
                }
    # open the form and replace the placeholders
                my $form = form2($source);
                $form =~ s/DATABASE/$database/;
    # build the select list and add to form
                my $selectlist = $assembly->htmlOptions('assemblyname','assemblyname',100,0,$asname);
                $form =~ s/SELECTTAG/$selectlist/ if ($selectlist); # substitute the HTML selectlist
                my $alink = "$arc_cgi_dir/amanager/specify/assembly\?database=$database";
		$alink .= "\&session=$session" if $session;
                $form =~ s/ASSEMBLYLINK/$alink/;
                $page->add($form,0,1); # add the form to the page and preload
    # preload the remaining placeholders with data in %config 
                foreach my $key (keys %config) {
                    $page->preload($key,$config{$key},1) if defined($config{$key});
                }
    # but overwrite with values in CGI input 
                $cgi->delete('RDD'); # could have been changed
                $page->preload('cgi_input',$cgi,1);
    # and add hidden fields  
                $page->ingestCGI();

    # add a three-way button bar and a return link 

                my $text = "Repeat to update this form for a newly chosen assembly, or<br>";
                $text   .= "Continue to start loading READS with these specified values, or<br>";
                $text   .= "Click on the return link to the main UPDATE menu<br>";
                $page->sectionheader($text,4,0);
                my @buttons = ('type=submit value=" Repeat "',
                               'type=submit value="Continue" name="process"',
                               'type=reset  value=" Reset "');
                $page->buttonbartemplate(3,0,\@buttons);                 
                $page->linkbutton('RETURN',$lreturn,0);
            }
            else {
                $page->errorbox("There are no assemblies defined for $database",0,0,'yellow');
                $page->messagebox("Please contact $db_manager or your project manager",$lreturn);
            }
        }
    # close form
        $page->form(0);
        $page->flush();
        $GateKeeper->disconnect;
        exit 0;
    }

    elsif ($option eq 'process') {
        $GateKeeper->cgiHeader(2); # return string HTML under CGI
        $page = $cgi->openPage('ARCTURUS READS loader');
        $page->address('ejz@sanger.ac.uk','Ed Zuiderwijk',2);
        $page->frameborder(100,15,'white',10);
        $page->center(1);

        $database = $cgi->parameter('database'); # redefine database
        if ($organisms->associate('reads_pending',$database,'dbasename')) {
            $source = $cgi->parameter('source');   # compulsory
        }
        else {
            $source = 0;
        }
#print "$cgi->PrintVariables() \n";
#$page->add($cgi->PrintVariables());
#$page->add("source = $source");
    # get assembly 
        $assembly     = $organisms->spawn('ASSEMBLY',$database,0,1);
        $assemblyname = $cgi->parameter('assemblyname'); # translate into number
        $assemblynmbr = $assembly->associate('assembly',$assemblyname,'assemblyname');

        $LOADPERRUN = $cgi->parameter('LPR');
    # test mode
        $TEST   = 1 if $cgi->parameter('testrun',0);
        $logON  = 1 if $cgi->parameter('logON'  ,0);
#        $reload = 1 if $cgi->parameter('reload' ,0);
        $forced = 1 if $cgi->parameter('forceload' ,0);
        $update = 1 if $cgi->parameter('update', 0);
      
    # test form completion
        if ($cgi->{und_error}) {
            $error = "Please define every input field $cgi->{und_error} ";
        }
    # authorisation level 100 required
        elsif (!$GateKeeper->authorize(100,{returnPath => "/$database/process",silently => 1})) {
            $error = $GateKeeper->{report}; # authorisation failed
        }
    # okay, now assign read specifications
        elsif ($source == 2) {
	    $gbfilter = 'ORACLE';
            $fnfilter = 'PENDING';
            $SCHEMA   = $cgi->parameter('SCH');
            $PROJECT  = $cgi->parameter('PRO');
        }
        else {
            $ROOTDATADIR = $cgi->parameter('RDD');
            $GELMINDDIR  = $cgi->parameter('GMD');
            $SCFREADDIR  = $cgi->parameter('SCF');
            if ($source == 0) {
                $fnfilter   = $cgi->parameter('FNF');
                $gbfilter   = $cgi->parameter('GBF');
                my $EXCLUDE = $config{EKS};
                @excludekeys = split /\s/,$EXCLUDE if ($EXCLUDE);
            }
            elsif ($source == 1) {
 	        $fnfilter = 'PENDING';
                undef @excludekeys;
            }
            my $SEARCH   = $config{SDS};
            @SEARCH_DIR  = split /\s/,$SEARCH if ($SEARCH);          
         }
         $session = $cgi->parameter('session');
         $lreturn .= "\?session=$session" if ($lreturn !~ /session/ && $session); 
         $arc_logfile = $cgi->parameter('LGF') if ($logON);
    }
    else {
        $error = "Invalid option $option for rloader";
    }

# abort on any error; else continue with the main script 

    if ($error) {
        $page->partition(2);
        $page->sectionheader("ARCTURUS READS loader specifications",3,0);
        $page->partition(1);
        $page->sectionheader("Sorry, an error status aborts this loader session",3,1);
# $page->add($cgi->PrintVariables());
        $page->errorbox($error,$lreturn);
        $page->flush();
        $GateKeeper->disconnect;
        exit 0;
    }
}

###############################################################################
# invocation from the command line
###############################################################################
else { # invoked from the command line (ejz/adh only)
    $origin = 0;
    $brtag = "\n";
    $yfont = '';
    $gfont = '';
    $ofont = '';
    $efont = '';
    $rfont = '';
    $bfont = '';

# test user

    $userid = $ENV{USER};
    if ($userid ne 'ejz' && $userid ne 'adh') {
        $GateKeeper->dropDead("user $userid does not have priviledge to run "
                             ."'rloader' from the command line.\nTry the "
                             ."web-based version");
    }

# check input parameters
    if (@ARGV < 2) {
        $GateKeeper->dropDead("specify a database and a source or directory "
                             ."name filter\n  rloader  database  PENDING "
                             ."SUBDIR [test]\n  rloader  database  PENDING "
                             ."ORACLE [SCHEMA] [PROJECT] [test]\n  "
                             ."rloader  database  HARVEST nr-of-days\n");
    }
    $fnfilter = shift @ARGV;
    $gbfilter = shift @ARGV || 0;

    if ($fnfilter eq 'PENDING') {
        $source = 1;
        if ($gbfilter eq 'ORACLE') {
            $source  = 2;
            $SCHEMA  = $config{SCH} if $config{SCH};
            $PROJECT = $config{PRO} if $config{PRO};
            $SCHEMA  = $ARGV[0] if $ARGV[0];
            $PROJECT = $ARGV[1] if $ARGV[1];
            if (!$SCHEMA || !$PROJECT) {
                $GateKeeper->dropDead("no SCHEMA or PROJECT specified for ORACLE data");
            }
        }
        elsif ($gbfilter) {
    # test if gbfilter is a project name; find its root directory ? 
            $config{PDD} = `$BADGERDIR/pfind -q $gbfilter`;
#            my @rootdatadir = `pfind $gbfilter`;
#            chomp $rootdatadir[0];
#            if ($rootdatadir[0] =~ /nfs/) {
#                $config{PDD} = $rootdatadir[0] ;
#                $config{PDD} =~ s/.*(\/nfs\S*)$/$1/;
#                $config{PDD} =~ s/^(.*)$gbfilter$/$1/;
#            }
        }
        else {
            $gbfilter = '';
        }
    }
    elsif ($fnfilter eq 'HARVEST') {
        $GateKeeper->dropDead("Command line invocation HARVEST must have a number of days defined") if !$gbfilter;
    }
    else {
        $GateKeeper->dropDead("Command line invocation only for PENDING files or HARVEST mode");
    }

    $TEST = shift @ARGV;

    my $attributes;
    if ($database && $organisms->associate('dbasename',$database,'dbasename')) {
 # get the default attributes
        if ($attributes = $organisms->unpackAttributes($database,'dbasename')) {
            print STDOUT "Database $database found; attributes retrieved\n";
            foreach my $item (keys %$attributes) {
 #               print STDOUT "item=$item attribute=$attributes->{$item}\n";
                $config{$item} = $attributes->{$item}; # overrides defaults
            }
        }
        else {
            print STDOUT "Database $database found; NO attributes found\n";
        }
    }
    else {
        $GateKeeper->dropDead("Command line invocation aborted: Unknown database $database");
    }
    $arc_logfile = "$arc_log_dir/rloader.$database.log"; # default
 
    $ROOTDATADIR = $config{RUT};
    $ROOTDATADIR = $config{RDD} if $config{RDD};
    $ROOTDATADIR.= $gbfilter.'/' if ($source == 1);
    $ROOTDATADIR =~ s?//?/?g; # remove double slashes
    $GELMINDDIR  = $config{GMD};
    $SCFREADDIR  = $config{SCF};
    my $SEARCH   = $config{SDS};
    @SEARCH_DIR  = split /\s/,$SEARCH if ($SEARCH);          

# get file name filter and global (directory) filter 

    $LOADPERRUN = 1;
    if ($TEST && $TEST =~ /\d/ && $TEST !~ /\D/) {
        $LOADPERRUN = $TEST;
        $TEST = 0;
    }

# open assembly database

    $assembly = $organisms->spawn('ASSEMBLY',$database,0,1);

 foreach my $key (keys %config) {
#     print "key $key  $config{$key}\n";
 }
    print "ROOTDATADIR = $ROOTDATADIR     log file $arc_logfile \n";
#$GateKeeper->disconnect;
#exit;
}

#*********************************** HERE WE GO ********************************

# autoVivify the READS database and connecting tables

my $datamodel = $organisms->spawn('DATAMODEL','arcturus',0,1);
my $readmodel = $organisms->spawn('READMODEL','arcturus',0,1);
my $READS     = $organisms->spawn('READS',$database,0,0);
$READS->autoVivify($database,2); # initialize all dictionary tables in database

# get an inventory of all open database tables

my $hashes = $datamodel->findInstanceOf(0);

# open the PENDING table and the READS2FRAGMENTS table

my $PENDING = $organisms->spawn('PENDING',$database,0,0);
my $RRS2ASS = $organisms->spawn('READS2ASSEMBLY',$database,0,0);


foreach my $key (keys %$hashes) {
#    print "$key $hashes->{$key}$brtag";# if (!$origin);
}
my $links = $READS->traceTable();
foreach my $key (sort keys %$links) {
#    print "key link: $key  $links->{$key}<br> \n";
}

if ($logON || !$origin) {
    open (LOG,">>$arc_logfile") or die "Failed to open $arc_logfile";
    print "LOG opened: $arc_logfile<br>";
} else {
    *LOG = *STDOUT;
}

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# (II) select those reads with file names matching the filter name
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    undef my %dbfiles;
    my $newfiles; my $nr;
    my $reader; 
#my $oracle;

# Get all files in the repository which pass the file name filter

    $reader = ReadsReader->new($READS); # reads from flat files
    $reader->setFatal(0) if ($forced);

    my $dbh = $GateKeeper->{handle};
    if ($fnfilter ne "PENDING") {

        print "Scanning database $database for Previously Processed Reads ... ";
        my $querystring = "SELECT readname FROM $database.PENDING order by record ";
    # get files in Pending
        my $sth = $dbh->prepare ($querystring);
        $sth->execute();
        while (my $dbfile = $sth->fetchrow_array()) {
            $dbfiles{$dbfile}++;
        }
        $nr = keys %dbfiles;
        print "($nr Pending reads found) ... ";
    # get files in READS and add to list
        $querystring = "SELECT readname FROM $database.READS ";
        if ($fnfilter && $fnfilter ne 'HARVEST') {
            print "(using filename filter \"$fnfilter\") ..."; 
            $querystring .= "WHERE readname LIKE \"%${fnfilter}%\" ";
        }

        $sth = $dbh->prepare ($querystring);
        $sth->execute();
        while (my $dbfile = $sth->fetchrow_array()) {
            print "! Double file name $dbfile $brtag" if  $dbfiles{$dbfile};
            $dbfiles{$dbfile}++;
        }
        $sth->finish();
        $nr = keys %dbfiles;

        print "forceload ..." if ($forced);
        print "DONE $brtag $nr files found which have previously been processed$brtag$brtag";
        print "Polling repository $ROOTDATADIR for (new) Reads ...$brtag";
        print "... using" if ($fnfilter || $gbfilter);
        print " name filter \"$fnfilter\""     if ($fnfilter =~ /\S/);
        print " global filter \"$gbfilter\""   if ($gbfilter =~ /\S/); 
        print " $brtag";
    # output in array @$newfiles with names of files in disk
        $newfiles = &getNewReadFiles (\%dbfiles,$ROOTDATADIR,\@excludekeys,$fnfilter,$gbfilter,$LOADPERRUN); 

    # if in harvest mode, add files to PENDING

        if ($fnfilter eq 'HARVEST') {
            foreach my $read (@$newfiles) {
                my @parts = split '/',$read;
                $read = $parts[$#parts];
                print "add to PENDING: $read for assembly nr $assemblynmbr<br>";
                &addPending($read,$assemblynmbr);
            }

            my $npends = $PENDING->count(0,0);
            $organisms->update('reads_pending',$npends,'dbasename',$database);
            $organisms->signature($userid,'dbasename',$database);

            if ($page) {
                my $rreturn = $lreturn;
                $rreturn =~ s/update/rloader/;
                $rreturn =~ s/getmenu/specify/;
                $rreturn .= "\&database=$database\&source=$source\&assemblyname=$assemblyname";
                $page->linkbutton('LOAD MORE',$rreturn,0);
                $page->linkbutton('MAIN MENU',$lreturn,0);
                $page->flush();
            }
            $GateKeeper->dropDead("Use the loader from the command line to load PENDING data");
        }
    }

    else {
        print "Scanning database $database for PENDING Reads only ... ";
        my $querystring = "SELECT readname FROM $database.PENDING order by readname ";
        $querystring .= "limit $LOADPERRUN" if $LOADPERRUN;
# print "querystring: $querystring$brtag";
        my $sth = $dbh->prepare ($querystring);
    # get files in PENDING
        $sth->execute();
        while (my $dbfile = $sth->fetchrow_array()) {
            $dbfiles{$dbfile}++;
        }
        $sth->finish();
        $nr = keys %dbfiles;

        print "forceload ..." if ($forced);

        print "DONE ... $nr pending files found$brtag$brtag";

        undef my @pendingfiles;
        if ($gbfilter && $gbfilter eq "ORACLE") {
    # get the files from Oracle: build array with names to be sent to Oracle reader
            foreach my $key (keys (%dbfiles)) {
                push @pendingfiles, $key;
            }
print "SCHEMA $SCHEMA, PROJECT $PROJECT $brtag";
#            $oracle = ADB_get_caf->new($SCHEMA,$PROJECT); # reads from Oracle database
        # ingest the reads (and store as hashes in ADB_get_caf reader)
print "pending files @pendingfiles $brtag";
#	    my $success = $oracle->getOracleReads(\@pendingfiles);
	    my $success = $reader->fetchOracleData($SCHEMA,$PROJECT,\@pendingfiles);
print "success = $success $brtag";
            undef @pendingfiles if !$success; # protection, forcing controlled exit
        # setup a link to ReadsReader in order to try Oracle if flat file not found
#            $reader->linkToOracle($oracle) if ($success);
# undef @pendingfiles;
        } else {
        # reads are assumed to be in project directory; we test the ROOTDATADIR and
        # if not found, its subdirectories
# print "rdd $ROOTDATADIR SDS: @SEARCH_DIR  $brtag";
            my @subdirs = `ls -d ${ROOTDATADIR}*`;
            foreach my $key (sort keys (%dbfiles)) {
                my $filename = $ROOTDATADIR.$key;
# print "find 1 $key: try $filename$brtag";                     
                if (-e $filename) {
                    push @pendingfiles, $filename;
                } else {
                # try the subdirs
                    my $found = 0;
                    foreach my $subdir (@subdirs) {
                        chomp $subdir;
                        $filename = "$subdir/$key";
# print "find 2 $key: try $filename$brtag";                     
                        if (-e $filename) {
                            push @pendingfiles, $filename;
# print "file $key found: $filename$brtag";
                            $found = 1; 
                            last;
			}
                    }
                    next if ($found);
                # still not found: try the search dirs
                    foreach my $sdir (@SEARCH_DIR) {
                        $filename = $sdir.$key;
# print "find 3 $key: SD '$sdir': try  $filename $brtag"; 
                        if (!(-e $filename)) {
                            my $command = "ls ${sdir}*/$key";
# print "find 4 $key: try $command$brtag"; 
                            $filename = `$command`;
                            chop $filename if ($filename);
                        }
                        if (-e $filename) {
                            push @pendingfiles, $filename;
# print "file $key found: $filename$brtag";
                            $found = 1;
                            last; 
                        }
		    }
                    print "! Failed to locate file $key$brtag" if !$found;
                }
            }
# print "Files:@{pendingfiles}$brtag";
        }
        $newfiles = \@pendingfiles;
    }
  
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# (III) scan the data repository for new read files
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    $nr = @$newfiles;
    print "polling DONE$brtag$brtag";
$LOADPERRUN =~ s/\W/x/g;
    print "$nr new Reads found (of which at most ${LOADPERRUN} will be processed)$brtag$brtag";

    if (!$origin && $TEST && $TEST =~ /^test$/) {
        foreach my $file (@$newfiles) {
            print "$file $brtag";
        }
        $GateKeeper->disconnect;
        print "test mode ended $brtag";
        exit 1;
    }

# update the default settings of ORGANISMS and ASSEMBLY tables

    if ($update) {

        $organisms->packAttribute ($database,'dbasename','attributes','anlast',$assemblyname);
        $organisms->packAttribute ($database,'dbasename','attributes','GMD',$GELMINDDIR);
        $organisms->packAttribute ($database,'dbasename','attributes','SCF',$SCFREADDIR);
        $organisms->packAttribute ($database,'dbasename','attributes','RDD',$ROOTDATADIR);
        my $overallRoot = $ROOTDATADIR; $overallRoot =~ s/\/\w+\/?$/\//; # chop off last subdir
        $organisms->packAttribute ($database,'dbasename','attributes','RUT',$overallRoot);

        if ($source == 2) {
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','SCH',$SCHEMA);
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','PRO',$PROJECT);
        }
        else {
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','RDD',$ROOTDATADIR);
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','LGF',$arc_logfile) if ($logON);
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','LPR',$LOADPERRUN);
            if ($source == 0) {
                $assembly->packAttribute ($assemblyname,'assemblyname','attributes','GBF',$gbfilter);
                $assembly->packAttribute ($assemblyname,'assemblyname','attributes','FNF',$fnfilter);
            }
        }
    }

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# (IV) go through all those new files and add the reads to the database
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#    my $encoder = Compress->new(); # default encoding string for DNA ('ACGT- ')

    my $tested = 0;
    my $loaded = 0;
    my $errors = 0;
    my $warning = 0;
    my $ignored = 0;

    my $timestamp = $organisms->timestamp(0);
    print LOG "\nNEW SESSION $timestamp\n" if ($logON);

    undef my %assemblycount;

    foreach my $file (@{$newfiles}) {

        last if ($LOADPERRUN-- <= 0);

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (0) Get the Read information for the next file
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        $errors = 0;
        $warning = 0;

   # treat a consensus file differently from a standard read

        my ($scm, $qcm);
        my $entry;
        my $isStdRead;

        $tested++;
        if ($file =~ /split/i && $file =~ /con|repeat|exon/i) {

            $isStdRead = 0; # it's a consensus file

            print STDOUT "${brtag}Processing consensus read $file ($tested) ...$brtag";
          
            $entry = $reader->newRead($file,1);

            $scm = 2; # switch to Huffman encoding
            $qcm = 2; # Huffman encoding
 
# my $text = $reader->list($origin,1);
# print STDOUT "$brtag $text $brtag";
	}
        else {

            $isStdRead = 1; # it's a standard read

            print STDOUT "${brtag}Processing experiment file $file ($tested) ...$brtag";

            if ($entry = $reader->newRead($file)) {
                $reader->format(); # test conformity to Sanger format
                $reader->ligation();
                $reader->strands();
                $reader->chemistry();
            }
            $scm = 1; # standard triplet encoding for DNA
            $qcm = 1; # number substitution on quality data
            $qcm = 3; # Huffman compression on quality difference data
        }

# skip this file on error

        print LOG "\n" if $logON;
        my ($summary, $errorstatus) = $reader->status(2,$origin);
        print STDOUT "$summary"; # either plain text or HTML
        if (!$entry || $errorstatus) {
            my $fulltext = $reader->list(0,1); # full list in plain text
            $ignored++;
            next if (!$entry || $TEST);
            print LOG "$fulltext\n" if ($logON && !$TEST);
# add the entry to PENDING if not already done
            my $add = &addPending ($entry->{ID},$assemblynmbr);
            print STDOUT "${rfont}$add$efont$brtag";
            next; 
        }
        elsif ($logON) {
           ($summary, $errorstatus) = $reader->status(2,0);
            print LOG "$summary";
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (1) Encode strings and test if coded lengths match
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        if (my $error = $reader->encode($scm, $qcm)) {
            $error =~ s/\n/$brtag/g;
            print STDOUT "ERROR: $ofont$error$efont$brtag";
            print LOG "$error\n" if ($logON);
print $reader->list($origin,1);
            last if ($error =~ /Invalid/);
            next;
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# 
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        if ($TEST) {
	    my $text = $reader->list($origin,1);
            print STDOUT "$brtag $text $brtag";
            next;
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (4) Insert a new row into reads by defining new primary key and add values
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          
        my $text = "Insert new data into READS ...";
        my $update = $reader->insert();
        $text .= "... $update READ items entered into database";
        print STDOUT "$text$brtag\n";
        print LOG "$text\n" if $logON;

        undef my $readhash;
        if ($update <= 0) {
            print STDOUT "! Read insert $ofont FAILED $efont$brtag";
            my $fulltext = $reader->list(1,0);
            print STDOUT "$fulltext";
            print LOG "$fulltext\n" if ($logON);
            $errors++;
        }
         
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (5) Read the DNA en Quality data from the database and test against originals   
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        else {
# read back of data 
            print STDOUT "Readback of Sequence and Quality data .. ";
            if (my $error = $reader->readback) {
                $error =~ s/\n/$brtag/g;
                print STDOUT "ERROR: $ofont$error$efont$brtag";
                print LOG "$error\n" if ($logON);
print $reader->list($origin,1);
                $errors = 1;
            }
            else {
                print STDOUT "${gfont}PASSED$efont$brtag";
            }
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (6?) if any problem encountered, rollback all changes made; else reset rollbacks
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        foreach my $key (keys %$hashes) {
# reset if $errors == 0, else undo updates 
            $hashes->{$key}->rollback($errors) unless ($errors && $key =~ /PENDING|SESSION/);
        }
        if ($errors && $READS->{qerror} =~ /already\sexists/) {
            $PENDING->delete('readname',$entry->{ID}) if $entry->{ID};
        }
        elsif ($errors) {
            $ignored++;
# add the entry to PENDING if not already done
            my $add = &addPending ($entry->{ID},$assemblynmbr);
            print STDOUT "${rfont}$add$efont$brtag" if ($add);
        }
        elsif (!$errors) {
            $loaded++;
            my $assemblynumber = $assemblynmbr; # use current specification
    # check if the entry was in PENDING
            if (my $hashref = $PENDING->associate('hashref',$entry->{ID},'readname')) {
    # get the assemblynumber
                $assemblynumber = $hashref->{assembly} || 0;             
    # and clear the entry if it was in pending
                $PENDING->delete('readname',$entry->{ID});
            }
    # add the entry to READS2ASSEMBLY
#            my $read_id = $READS->associate('read_id',$entry->{ID},'readname');
            my $read_id = $readhash->{read_id};
            if (!$RRS2ASS->newrow('read_id',$read_id,'assembly',$assemblynumber)) {
                print "$RRS2ASS->{qerror}$brtag";
                $RRS2ASS->status(1); # reset the error status
            }
            else {
                $assemblycount{$assemblynumber}++;
            }
        }
        else {
            $ignored++;
            print STDOUT "${bfont}read $entry->{ID} is already loaded$efont$brtag";
        }
        print STDOUT "$brtag";
# next file
    }

    $RRS2ASS->flush();

# closing down: timestamps on altered tables

    my $list = 1; $list = 2 if $cgi;
    $userid = $GateKeeper->{USER} if !$userid;
    $organisms->historyUpdate($userid,0,$list);

    print STDOUT "${brtag}Updating counters and closing database$brtag$brtag";

    foreach my $assemblynumber (keys (%assemblycount)) {
        my $areads = $RRS2ASS->count("assembly=$assemblynumber",0);
        print "assembly $assemblyname (nr $assemblynumber) reads counted: $areads $userid$brtag";
        $assembly->update('reads',$areads,'assemblyname',$assemblyname);
        $assembly->signature($userid,'assemblyname',$assemblyname);
    }

    my $nreads = $READS->count(0,0);
    $organisms->update('reads_loaded' ,$nreads,'dbasename',$database);
    my $npends = $PENDING->count(0,0);
    $organisms->update('reads_pending',$npends,'dbasename',$database);
    $organisms->signature($userid,'dbasename',$database);

    $GateKeeper->disconnect;

# closing line

    my $report = "END of SESSION: $tested reads processed, $loaded loaded, ";
    $report .= " $yfont$ignored ignored$efont because of errors" if (!$TEST);
    print STDOUT "$report$brtag";
    print LOG "$report\n" if $logON;

    if ($page) {
        my $rreturn = $lreturn;
        $rreturn =~ s/update/rloader/;
        $rreturn =~ s/getmenu/specify/;
        $rreturn .= "\&database=$database\&assemblyname=$assemblyname";
        $page->linkbutton('LOAD MORE',$rreturn,0);
        $page->linkbutton('MAIN MENU',$lreturn,0);
        $page->flush();
    }

    exit 0;

########################################## addPending #################################

sub addPending {
    my $readname = shift;
    my $fragment = shift;

# add the entry to PENDING if not already done

    my $report = "read $readname to be added to PENDING ...";
    if (!$PENDING->associate('record',$readname,'readname',-1)) {
  
        my $add = $PENDING->newrow('readname',$readname,'assembly',$fragment);

        $report .= "... DONE"   if $add;
        $report .= "... FAILED" if !$add;
    }
    else {
        $report .= "... SKIPPED";
    }
    return $report;
}

########################################## getNewReadFiles ###############################################

sub getNewReadFiles {
    my $dbfiles   = shift;  # hash with existing file names in database
    my $directory = shift;  # top directory of data depository
    my $excluders = shift;  # reject filters
    my $flnfilter = shift;  # file name filter (file name only)
    my $glbfilter = shift;  # global filter (on file name and path)
    my $MAXREAD   = shift;

    my $DEBUG = 0;

    my $file;

    my @dirs = `ls $directory`;

    $MAXREAD = 1000 if (!defined($MAXREAD));
 
my $nrr = keys %$dbfiles;
print "directory $directory $brtag dbfiles $nrr $brtag" if $DEBUG;
print "exclude: @{$excluders}${brtag}filter : $flnfilter$brtag gbfilter : $glbfilter$brtag" if ($DEBUG);
$MAXREAD = 10 if ($DEBUG);

    undef my @newReads;
DIR:foreach my $sdname (@dirs) {
    # analyse next directory name, get files and analyse file names
        chomp $sdname; # cleanup
#print "testing dir $sdname<br>";
        next DIR if ($glbfilter =~ /\S/ && $sdname !~ /$glbfilter/);
        foreach my $exclude (@{$excluders}) {
print "rejected directory: $sdname  $brtag" if ($sdname =~ /$exclude/ && $DEBUG);
            next DIR if ($sdname =~ /$exclude/); # exact match
        }

       (my $subdir = "$directory/$sdname/") =~ s/\/\//\//g;

        print "... scanning directory $subdir$brtag";

        my $find = "find $subdir";
        $find .= " -atime $glbfilter" if ($flnfilter eq "HARVEST");
print "find: $find $brtag" if $DEBUG;
        if ($flnfilter && $flnfilter ne 'HARVEST') {
            open (FILE,"find $subdir | grep $flnfilter |") || die "cannot open directory";
        } else {
            open (FILE,"find $subdir |") || die "cannot open directory";
        }

        my $filetest = 0;
        my $filecount = 0;
NEXT:   while (defined($file=<FILE>)) {
            chomp $file; # cleanup
print "test file $file$brtag" if ($DEBUG);
            $filetest++; # keep track
        # test against filters
print "reject $file ($flnfilter)$brtag" if ($flnfilter && !($file =~ /$flnfilter/) && $DEBUG);
            next NEXT if ($flnfilter =~ /\S/ && $flnfilter ne 'HARVEST' && !($file =~ /$flnfilter/));
            next NEXT if ($glbfilter =~ /\S/ && !($file =~ /$glbfilter/));
        # test against allowed pattern and get shortname
print "reject $file$brtag" if (!($file =~ /^$subdir(\S+\/)?[\w\-\.]+\.\w\d?\w*$/) && $DEBUG);
            next NEXT if (!($file =~ /^$subdir(\S+\/)?([\w\-\.]+\.(\w\d?\w*)$)/));
            my $shortname = $2;
	    next NEXT if (!($shortname =~ /\.\w\d?$/ || $shortname =~ /\.\w\d\w*$/));
print "shortname = $shortname $brtag" if ($DEBUG);
            next NEXT if ($dbfiles->{$shortname} && (!$DEBUG || $DEBUG <= 1));
        # find possible directories beneath the $subdir
            my $subdirname = $file;
            $subdirname =~ s/$subdir//; # remove the top directory
        # test against rejection strings
            foreach my $exclude (@{$excluders}) {
print "rejected file: $file $exclude $brtag" if ($subdirname =~ /$exclude/i && $DEBUG);
                next NEXT if ($subdirname =~ /$exclude/i);
            }
        
            last if ($MAXREAD-- <= 0);
            push @newReads, $file;
            $filecount++;
print "new file: $file $brtag" if($DEBUG);
        }
        print "... $filetest files tested, $filecount accepted$brtag";
        close FILE;
        last DIR if ($MAXREAD <= 0);
    }
    \@newReads;
}

########################################## forms #################################

sub form1 {
    my $form;
    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH 100%>";
    $form .= "<TR><TD><INPUT TYPE='radio' NAME='source' VALUE=0 checked></TD>";
    $form .= "<TD>By Read Name Filter</TD><TD>from:</TD><TD>Experiment Directories</TD></TR>";
    $form .= "<TR><TD><INPUT TYPE='radio' NAME='source' VALUE=1></TD>";
    $form .= "<TD>PENDING Reads</TD><TD>from:</TD><TD>Experiment Directories</TD></TR>";
    $form .= "<TR><TD><INPUT TYPE='radio' NAME='source' VALUE=2></TD>";
    $form .= "<TD>PENDING Reads</TD><TD>from:</TD><TD>ORACLE database</TD></TR>";
    $form .= "</TABLE>";

    return $form;
}

sub form2 {
    my $source = shift;

    my $form;

    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH 100%>";
    if ($source == 0 || $source == 1) {
        $form .= "<TR><TH ALIGN=LEFT>Data directory root</TH>";
        $form .= "<TD COLSPAN=2><INPUT NAME='RDD' SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";
        $form .= "<TR><TH ALIGN=LEFT>Gelminder directory</TH>";
        $form .= "<TD COLSPAN=2><INPUT NAME='GMD'  SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";
        $form .= "<TR><TH ALIGN=LEFT>SCF directory name</TH>";
        $form .= "<TD COLSPAN=2><INPUT NAME='SCF'  SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";

        if ($source == 0) {
            $form .= "<TR><TH ALIGN=LEFT>Filename Filter</TH>";
            $form .= "<TD><INPUT NAME='FNF' SIZE=16 MAXSIZE=64 VALUE=''></TD>";
            $form .= "<TD>&nbsp</TD></TR>";
            $form .= "<TR><TH ALIGN=LEFT>Directory Filter</TH>";
            $form .= "<TD><INPUT NAME='GBF' SIZE=16 MAXSIZE=64 VALUE=''></TD>";
            $form .= "<TD>&nbsp</TD></TR>";
        }
    }

    elsif ($source == 2) {
        $form .= "<TR><TH ALIGN=LEFT>Oracle Schema Name</TH>";
        $form .= "<TD><INPUT NAME='SCH'  SIZE=16 MAXSIZE=32 VALUE=''></TD>";
        $form .= "<TD>&nbsp</TD></TR>";
        $form .= "<TR><TH ALIGN=LEFT>Oracle Project Name</TH>";
        $form .= "<TD><INPUT NAME='PRO' SIZE=16 MAXSIZE=32 VALUE=''></TD>";
        $form .= "<TD>&nbsp</TD></TR>";
    }

    $form .= "<TR><TH ALIGN=LEFT>DATABASE Assembly Name</TH><TD>SELECTTAG</TD>";
    $form .= "<TD><A href=\"ASSEMBLYLINK\">ADD NEW ASSEMBLY</A></TD></TR>";
#    $form .= "<TD><b>Check</b> <INPUT type=checkbox name=testrun> for TEST run </TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Load a maximum of </TH>";
    $form .= "<TD><INPUT VALUE='1' SIZE=5 NAME='LPR'> reads</TD>";
    $form .= "<TD><b>Check</b> <INPUT type=checkbox name=forceload> for FORCED load </TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Check <INPUT type=checkbox name=logON checked> for log file</TH>";
    $form .= "<TD COLSPAN=2><INPUT NAME='LGF' SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";

    $form .= "<TR><TH AKIGN=LEFT>Check <INPUT type=checkbox name=testrun> for TEST run </TH>";
    $form .= "<TH ALIGN=RIGHT COLSPAN=2> Check <INPUT type=checkbox name=update> for update of defaults </TH></TR>";
    $form .= "</TABLE>";

    return $form;
}

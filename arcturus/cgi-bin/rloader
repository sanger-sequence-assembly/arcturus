#!/usr/local/bin/perl5.004

#############################################################################
#
# Upload Reads into ARCTURUS database
#
#############################################################################

use strict; # Constraint variables declaration before using them

BEGIN { 
   $ENV{ORACLE_HOME} = '/usr/local/oracle';
   $ENV{ORACLE_SID}  = 'inform';
   $ENV{TWO_TASK}    = 'sids';
   $ENV{PERL5LIB}   .= ':/usr/local/badger/bin';
   $ENV{PERL5LIB}   .= ':/nfs/pathsoft/arcturus/dev/lib';
   $ENV{PATH}       .= ':/usr/local/badger/bin';
#   use lib '/nfs/pathsoft/arcturus/dev/lib';
}

use GateKeeper; 
use ReadsReader;
use PathogenRepository;

##############################################################################
# get configuration data, open CGI and MySQL Database
##############################################################################

my %options = (eraiseMySQL => 1, errorToNull => 0, writeAccess => 1);
my $GateKeeper = GateKeeper->new('mysql',\%options);

my ($cgi, $void, $database, $option, $origin, $session);

# how is this script invoked?

if ($cgi = $GateKeeper->cgiHandle(1)) {
   ($void, $database, $option) = split ('/',$GateKeeper->origin());
    my $alternate = $GateKeeper->lookup('database');
    $database = $alternate if $alternate;
#    $database = $GateKeeper->lookup('database') if $GateKeeper->lookup('database');
#    $database = $GateKeeper->lookup('organism') if !$database;
#    $database = 'arcturus if !$database';
    $option = 'getform' if !$option;
}
else {
    $database = shift @ARGV;
}

my $organisms = $GateKeeper->dbHandle($database,{returnTableHandle => 1});

##############################################################################
# MAIN
##############################################################################

my %config;
$config{RDD} = "<to be defined>";
$config{SDS} = ''; # default search sub-directories
# $config{SDS} = join ' ',@{$GateKeeper->lookup("SEARCH_DIR")}; # default search sub-directories
$config{GMD} = $GateKeeper->lookup("GELMINDDIR");
$config{SCF} = $GateKeeper->lookup("SCFREADDIR");
$config{EKS} = join ' ',@{$GateKeeper->lookup("excludekeys")}; # default reject strings
#$config{PRO} = $GateKeeper->lookup("PROJECT",0); # for Oracle reads
#$config{SCH} = $GateKeeper->lookup("SCHEMA" ,0);  # for Oracle reads
$config{LPR} = $GateKeeper->lookup("LOADPERRUN");
$config{FNF} = '';
$config{GBF} = '';

# all of the above may be overwritten by 'attributes' data from ORGANISMS or ASSEMBLY 

my $arc_cgi_dir = $GateKeeper->lookup('ARC_CGI_DIR');
my $arc_log_dir = $GateKeeper->lookup('ARC_LOG_DIR');
my $arc_tmp_dir = $GateKeeper->lookup('ARC_TMP_DIR');
my $db_manager  = $GateKeeper->lookup('db_manager'); 
my $BADGERDIR   = $GateKeeper->lookup('BADGERDIR');

my $signame = $GateKeeper->lookup('signature_name');
my $sigmail = $GateKeeper->lookup('signature_mail');

$config{LGF} = "$arc_log_dir/rloader.DATABASE.log"; # default logfile

my ($LOADPERRUN,$GELMINDDIR,$ROOTDATADIR,$SCFREADDIR,$SCHEMA,$PROJECT,$LOGFILE);
my ($FNF, $GBF, @SEARCH_DIR, @excludekeys);

my ($action, $page, $confirm);
my ($userid  , $project , $assembly, $assemblyname, $assemblynmbr);
my ($fnfilter, $gbfilter, $source, $rloader, $forced, $update, $pending);
my ($arc_logfile, $logON, $TEST, $abortfile);
$abortfile = $GateKeeper->lookup('abortfile');

my ($break, $gfont, $yfont, $ofont, $rfont, $efont, $bfont);

###############################################################################
# invokation via web: first "getmenu", then the "specify" and "" option
###############################################################################

if ($cgi) {
    $origin = 1;
# used as cgi scripts
    $break = "<br>";
    $gfont = "<FONT COLOR=lightgreen>";
    $yfont = "<FONT COLOR=yellow>";
    $ofont = "<FONT COLOR=orange>";
    $rfont = "<FONT COLOR=red>";
    $bfont = "<FONT COLOR=blue>";
    $efont = "</FONT>";

# redefine option if a "specify" option comes with process defined, else get form

    $option = 'process' if ($option eq 'specify' && $GateKeeper->lookup('process',0));

# preprocessing of input info


    undef my $error;
    if ($option eq 'getform') {
        $page = $GateKeeper->GUI('READS loader');
        $page->form("$arc_cgi_dir/rloader/$database/specify");
        $page->add("<BR><BR>ARCTURUS READS loader specifications<P><P>",0,0,"size=+1");
        my %options = (mask=>'0110000001111000001',
                       headColor=>'FAFAD2',cellColor=>'CCCCCC',linkColor=>'E2E2FF');
        if ($database eq 'arcturus') {
            my $table = $organisms->htmlTable(\%options);
            $page->add($table,0,0,"size=-1");
            $page->sectionheader("Select a Database and Read specification",4,0);
            $page->add($organisms->htmlOptions('dbasename','database',20,0),0,0);
        }
        else {
#            my %options = (mask=>'0110000001111000001',
#                           headColor=>'FAFAD2',cellColor=>'CCCCCC',linkColor=>'E2E2FF');
            my $table = $organisms->htmlTable(\%options,'dbasename',$database);
            $cgi->addkey('database',$database);
            $page->add($table);
            $page->sectionheader("Select a Read specification",4,0);
        }
        $page->add(&form1(),0,1);
        $page->submitbuttonbar(0,0,0);
        $page->ingestCGI();
        $page->form(0);
        $page->flush();
        $GateKeeper->disconnect;
        exit 0; 
    }
    elsif ($option eq 'specify') {
# get source, database, and whether an assembly choice exists
        $database  = $GateKeeper->lookup('database',1); # compulsory
        my $asname = $GateKeeper->lookup('assemblyname',0); # no test
        $asname = 0 if !$asname; # to have it explicitly defined
        if ($pending = $organisms->associate('reads_pending',$database,'dbasename')) {
            $source = $GateKeeper->lookup('source',1);  # compulsory
            my $redirect = "/cgi-bin/rloader/$database/getform";
            $GateKeeper->redirect($redirect) if $cgi->MethodGet;
            $GateKeeper->redirect($redirect) if $GateKeeper->cgiError(0);
        }
        else {
            $source = 0;
            $cgi->addkey('source',0);
        }

        $GateKeeper->cgiHeader(2); # return string HTML under CGI
        $page = $cgi->openPage('ARCTURUS READS loader');
        my $signame = $GateKeeper->lookup('signature_name');
        my $sigmail = $GateKeeper->lookup('signature_mail');
        $page->address($sigmail,$signame,2);
        $page->frameborder(100,15,'white',10);
        $page->center(1);

        $page->form("$arc_cgi_dir/rloader/arcturus/specify");
        $page->partition(2);
        $page->sectionheader("ARCTURUS READS loader specification for $database",3,0);
        $page->partition(1);
        if ($source == 0) {
            $page->sectionheader("(Named reads taken from experiment depository)",4,1);
        }
        elsif ($source == 1) {
            $page->sectionheader("(PENDING reads taken from experiment depository)",4,1);
        }
        elsif ($source == 2) {
            $page->sectionheader("(PENDING reads taken from ORACLE)",4,1);
        }

        if (!$database) {
            $page->errorbox("Please define all form entries: missing database name");
            $page->add($cgi->PrintVariables());
        }
        elsif (!$GateKeeper->cgiError(1)) {
    # open assembly database; abort if no assemblies defined
            $assembly = $organisms->spawn('ASSEMBLY',$database,0,1);
            if ($assembly && $assembly->count() > 0) {
    # get the default assembly name if no assemblyname in CGI input; first try attributes
		my $attributes = $organisms->unpackAttributes($database,'dbasename');
                $asname = $attributes->{anlast} if (!$asname && $attributes->{anlast});
    # if still undefined, just take the first one
                $asname = $assembly->{hashrefs}->[0]->{assemblyname} if (!$asname); 
    # update the data dir name (if assembly has changed)
                my $target = $asname; $target =~ s/\d+/\\d\+/g;
                $config{RDD} =~ s/$target/$asname/ if $config{RDD};
    # overwrite the preset configuration data with those in ORGANISM attributes if any
                $config{LGF} =~ s/DATABASE/$database/; # log file
                foreach my $key (keys %config) {
                    $config{$key} = $attributes->{$key} if defined($attributes->{$key});
                }
    # overwrite the preset configuration data with those in ASSEMBLY attributes if any
		$attributes = $assembly->unpackAttributes($asname,'assemblyname');
                foreach my $key (keys %config) {
                    $config{$key} = $attributes->{$key} if defined($attributes->{$key});
                }
    # next handles the case where RDD remained defined
                if ((!$config{RDD} || $config{RDD} =~ /to be d/) && $asname ne 'BLOB') {
                    my $repository = new PathogenRepository;
                    $config{RDD} = $repository->getAssemblyDirectory($asname);
                    $config{RDD} =~ s/\/assembly//; 
# print "RDD taken from Repository:  $config{RDD} $break";
                }
    # open the form and replace the placeholders
                my $form = form2($source);
                $form =~ s/DATABASE/$database/;
    # build the select list and add to form
                my $selectlist = $assembly->htmlOptions('assemblyname','assemblyname',100,0,$asname);
                $form =~ s/SELECTTAG/$selectlist/ if ($selectlist); # substitute the HTML selectlist
                my $alink = "$arc_cgi_dir/amanager/specify/assembly\?database=$database";
		$alink .= "\&session=$session" if $session;
                $form =~ s/ASSEMBLYLINK/$alink/;
    # oracle data 
                if ($source == 2) {
                    my $schema = $organisms->associate('schema',$database,'dbasename');
                    $form =~ s/\<s\>/$schema/i if $schema;
                    my $project = $assembly->associate('oracleproject',$asname,'assemblyname');
                    $form =~ s/\<p\>/$project/i if $project;
                }
                $page->add($form,0,1); # add the form to the page and preload
    # preload the remaining placeholders with data in %config 
                foreach my $key (keys %config) {
                    $page->preload($key,$config{$key},1) if defined($config{$key});
                }
    # but overwrite with values in CGI input 
                $cgi->delete('RDD'); # could have been changed
                $page->preload('cgi_input',$cgi,1);
    # and add hidden fields  
                $page->ingestCGI();

    # add a three-way button bar and a return link 

                my $text = "Rebuild to update this form for a newly chosen assembly, or$break";
                $text   .= "Continue to start loading READS with the specified values";
                $text   .= ", or${break}Click on the return link to change the data source$break" if $pending;
                $page->sectionheader($text,4,0);
                my @buttons = ('type=submit value=" Rebuild "',
                               'type=submit value="Continue" name="process"',
                               'type=reset  value=" Reset "');
                $page->buttonbartemplate(3,0,\@buttons);
                my $lreturn = "$arc_cgi_dir/rloader/$database/getform".$cgi->postToGet(0,'source');
                $page->linkbutton('RETURN',$lreturn,0) if $pending;
            }
            else {
                $page->errorbox("There are no assemblies defined for $database",0,0,'yellow');
                my $count = $assembly->count() || 0;
                $page->messagebox("assembly $assembly $count");
                $page->messagebox("Please contact $db_manager or your project manager");
            }
        }
    # close form
        $page->form(0);
        $page->flush();
        $GateKeeper->disconnect;
        exit 0;
    }

    elsif ($option eq 'process') {
        $GateKeeper->cgiHeader(2); # return string HTML under CGI
        $page = $cgi->openPage('ARCTURUS READS loader');
        $page->address($sigmail,$signame,2);
        $page->frameborder(100,15,'white',10);
        $page->center(1);

        $database = $GateKeeper->lookup('database'); # redefine database
        if ($organisms->associate('reads_pending',$database,'dbasename')) {
            $source = $GateKeeper->lookup('source');   # compulsory
        }
        else {
            $source = 0;
        }
    # get assembly 
        $assembly     = $organisms->spawn('ASSEMBLY',$database,0,1);
        $assemblyname = $GateKeeper->lookup('assemblyname'); # translate into number
        $assemblynmbr = $assembly->associate('assembly',$assemblyname,'assemblyname');

        $LOADPERRUN = $GateKeeper->lookup('LPR');
    # test mode
        $TEST   = 1 if $GateKeeper->lookup('testrun',0);
        $logON  = 1 if $GateKeeper->lookup('logON'  ,0);
#        $reload = 1 if $GateKeeper->lookup('reload' ,0);
        $forced = 1 if $GateKeeper->lookup('forceload' ,0);
        $update = 1 if $GateKeeper->lookup('update', 0);
      
    # test form completion
        if (my $status = $GateKeeper->cgiError(0)) {
            $error = "Please define every input field $status ";
        }
    # authorisation level 100 required
        elsif (!$GateKeeper->authorize(100,{returnPath => "/$database/process",silently => 1})) {
            $error = $GateKeeper->{error}; # authorisation failed
        }
    # okay, now assign read specifications
        elsif ($source == 2) {
	    $gbfilter = 'ORACLE';
            $fnfilter = 'PENDING';
            $SCHEMA   = $GateKeeper->lookup('SCH');
            $PROJECT  = $GateKeeper->lookup('PRO');
        }
        else {
            $ROOTDATADIR = $GateKeeper->lookup('RDD');
            $GELMINDDIR  = $GateKeeper->lookup('GMD');
            $SCFREADDIR  = $GateKeeper->lookup('SCF');
            if ($source == 0) {
                $fnfilter   = $GateKeeper->lookup('FNF');
                $fnfilter =~ s/^.*\b(HARVEST)\b.*$/$1/; # remove any blanks
                $gbfilter   = $GateKeeper->lookup('GBF');
                my $EXCLUDE = $config{EKS};
                @excludekeys = split /\s/,$EXCLUDE if ($EXCLUDE);
            }
            elsif ($source == 1) {
 	        $fnfilter = 'PENDING';
                undef @excludekeys;
            }
            my $SEARCH   = $config{SDS};
            @SEARCH_DIR  = split /\s/,$SEARCH if ($SEARCH);          
        }
        $session = $GateKeeper->lookup('session');
        $arc_logfile = $GateKeeper->lookup('LGF') if ($logON);
    }
    else {
        $error = "Invalid option $option for rloader";
    }

# abort on any error; else continue with the main script 

    if ($error) {
        $page->partition(2);
        $page->sectionheader("ARCTURUS READS loader specifications",3,0);
        $page->partition(1);
        $page->sectionheader("Sorry, an error status aborts this loader session",3,1);
        $page->errorbox($error);
        $page->flush();
        $GateKeeper->disconnect;
        exit 0;
    }
}

###############################################################################
# invocation from the command line
###############################################################################
else { # invoked from the command line (ejz/adh/pathdb only)
    $origin = 0;
    $break = "\n";
    $yfont = '';
    $gfont = '';
    $ofont = '';
    $efont = '';
    $rfont = '';
    $bfont = '';

# test user

    $userid = $ENV{USER};
    if ($userid ne 'ejz' && $userid ne 'adh' && $userid ne 'pathdb') {
        $GateKeeper->dropDead("user $userid does not have priviledge to run "
                             ."'rloader' from the command line.\nTry the "
                             ."web-based version");
    }

# check input parameters
    if (@ARGV < 2) {
        $GateKeeper->dropDead("specify a database and a source or directory "
                             ."name filter\n  rloader  database  PENDING "
                             ."assembly [LPR or test]\n  rloader  database  PENDING "
                             ."ORACLE assembly [forced] [LPR or test]\n  "
                             ."rloader  database  HARVEST nr-of-days\n");
    }
    $fnfilter = shift @ARGV;
    $gbfilter = shift @ARGV;
    my $assembly_id = $gbfilter || 'BLOB'; # default assembly

    $fnfilter =~ s/^.*\b(HARVEST)\b.*$/$1/; # remove any blanks

    if ($fnfilter eq 'PENDING') {
        $source = 1;
        if ($gbfilter eq 'ORACLE') {
            $source  = 2;
            $SCHEMA  = $organisms->associate('schema',$database,'dbasename');
            $assembly_id =  shift @ARGV || 'BLOB';
        }
#        elsif ($gbfilter && $gbfilter =~ /\D/) {
# test if gbfilter is a project name; find its root directory ? 
#print "testing II project $gbfilter \n";
#            $config{PDD} = `$BADGERDIR/pfind -q $gbfilter > /dev/null 2>&1`;
#        }
        elsif (!defined($gbfilter)) {
            $gbfilter = '';
        }
    }
    elsif ($fnfilter eq 'HARVEST') {
        $GateKeeper->dropDead("Command line invocation HARVEST must have a number of days defined") if !$gbfilter;
        $assembly_id =  shift @ARGV || 'BLOB';
    }
    else {
        $GateKeeper->dropDead("Command line invocation only for PENDING files or HARVEST mode");
    }

    $TEST = shift @ARGV;
    if ($TEST eq 'forced') {
        $forced = 1;
        $TEST = shift @ARGV;      
    }

    $arc_logfile = "$arc_log_dir/rloader.$database.log"; # default

    print "\n\n\n";
    my $attributes;
    if ($database && $organisms->associate('dbasename',$database,'dbasename')) {
# get the default attributes
        if ($attributes = $organisms->unpackAttributes($database,'dbasename')) {
            print STDOUT "Attributes retrieved for database $database\n";
            foreach my $item (keys %$attributes) {
# print STDOUT "item=$item attribute=$attributes->{$item}\n";
                $config{$item} = $attributes->{$item}; # overrides defaults
            }
        }
        else {
            print STDOUT "Database $database found; NO attributes found\n";
        }
    }
    else {
        $GateKeeper->dropDead("Command line invocation aborted: Unknown database $database");
    }

# open assembly database

    $assembly = $organisms->spawn('ASSEMBLY',$database,0,1);
# try to identify the assembly; first try assembly name
    if ($assemblynmbr = $assembly->associate('assembly',$assembly_id,'assemblyname')) {
        $assemblyname = $assembly_id;
    }
# or try a number
    elsif ($assemblyname = $assembly->associate('assemblyname',$assembly_id,'assembly')) {
        $assemblynmbr = $assembly_id;
    }
    else {
        print "last query on $assembly->{tablename} $assembly->{lastQuery} $assembly->{errors}\n";
        $GateKeeper->dropDead("Command line invocation aborted: Unknown assembly $assembly_id");
    }

    $PROJECT = $assembly->associate('oracleproject',$assemblynmbr,'assembly') if ($source == 2);

    if ($attributes = $assembly->unpackAttributes($assemblynmbr,'assembly')) {

        my @items = keys %$attributes;
        if (@items) {
            print STDOUT "Assembly $assemblynmbr found; attributes retrieved\n";
            foreach my $item (keys %$attributes) {
# print STDOUT "item=$item attribute=$attributes->{$item}\n";
                $config{$item} = $attributes->{$item}; # overrides defaults
                $logON = 1 if $config{LGF};
            }
        }
        else {
            print STDOUT "NO assembly attributes found\n";
        }
    }
    else {
        print STDOUT "Assembly $assemblynmbr found; NO attributes found\n";
    }
 
    $ROOTDATADIR = $config{RUT};
    $ROOTDATADIR = $config{RDD} if $config{RDD};
    $ROOTDATADIR =~ s?//?/?g; # remove double slashes
    $GELMINDDIR  = $config{GMD};
    $SCFREADDIR  = $config{SCF};
    my $SEARCH   = $config{SDS};
    @SEARCH_DIR  = split /\s/,$SEARCH if ($SEARCH);          
    my $EXCLUDE = $config{EKS};
    @excludekeys = split /\s/,$EXCLUDE if ($EXCLUDE);

# get file name filter and global (directory) filter 

    $LOADPERRUN = 1;
    if ($TEST && $TEST =~ /\d/ && $TEST !~ /\D/) {
        $LOADPERRUN = $TEST;
        $TEST = 0;
    }

#    print "ROOTDATADIR = $ROOTDATADIR\nlog file $arc_logfile \n";
#$GateKeeper->dropDead("Test run exit: $fnfilter $gbfilter $LOADPERRUN");
}

#*********************************** HERE WE GO ********************************

# autoVivify the READS database and connecting tables

my $datamodel = $organisms->spawn('DATAMODEL','arcturus',0,1);
my $readmodel = $organisms->spawn('READMODEL','arcturus',0,1);
my $READS     = $organisms->spawn('READS',$database,0,0);
$READS->autoVivify($database,2); # initialize all dictionary tables in database
#$READS->setMultiLineInsert(100);

# get an inventory of all open database tables

my $hashes = $datamodel->getInstanceOf(0);

# open the PENDING table and the READS2FRAGMENTS table

my $PENDING = $organisms->spawn('PENDING',$database,0,0);
my $RRS2ASS = $organisms->spawn('READS2ASSEMBLY',$database,0,0);
$RRS2ASS->setMultiLineInsert(100);

foreach my $key (keys %$hashes) {
#    print "$key $hashes->{$key}$break";# if (!$origin);
}
my $links = $READS->traceTable();
foreach my $key (sort keys %$links) {
#    print "key link: $key  $links->{$key}$break \n";
}

if ($logON || !$origin) {
 #   open (LOG,">>$arc_logfile") or die "Failed to open $arc_logfile";
    print "LOG opened: $arc_logfile $break";
    $logON=0;
} else {
    *LOG = *STDOUT;
}

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# (II) select those reads with file names matching the filter name
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    undef my %dbfiles;
    my $newfiles; my $nr;
    my $reader; 
#my $oracle;

# Get all files in the repository which pass the file name filter

    $reader = ReadsReader->new($READS); # reads from flat files
    $reader->setFatal(0) if ($forced);

    my $dbh = $GateKeeper->{handle};

    if (!$GateKeeper->ping) {
        print "!! MySQL database connection has gone away $break";
        $GateKeeper->environment;
        exit 0;
    }
    elsif ($fnfilter ne "PENDING") {

        print "Scanning database $database for Previously Processed Reads ... ";
        my $querystring = "SELECT readname FROM $database.PENDING order by record ";
    # get files in Pending
        my $sth = $dbh->prepare ($querystring);
        if ($sth->execute()) {
            while (my $dbfile = $sth->fetchrow_array()) {
                $dbfiles{$dbfile}++;
            }
        }
        else {
            print "query failed: '$querystring' $break $break";
            $page->flush;
            $GateKeeper->disconnect;
            exit;
        }
        $nr = keys %dbfiles;
        print "($nr Pending reads found) ... ";
    # get files in READS and add to list
        $querystring = "SELECT readname FROM $database.READS";
        if ($fnfilter && $fnfilter ne 'HARVEST') {
            print "(using filename filter \"$fnfilter\") ..."; 
            $querystring .= "WHERE readname LIKE \"%${fnfilter}%\" ";
        }
#        my $aref = $dbh->selectcol_arrayref($querystring);
#	print "aref=$aref $break";
#        my $len = @$aref; print "length $len $break";

        $sth = $dbh->prepare ($querystring); # print "$querystring $break";
        if ($sth->execute()) {
#print "executed $break";
#            my $aref = $sth->fetchall_arrayref();
#            print "aref=$aref $break";
#            my $len = @$aref; print "length $len $break";
#my $line = 0;
            while (my $dbfile = $sth->fetchrow_array()) {
#$line++; print "$line $dbfile " if (!($line % 10000) || $line > 260000);
                print "! Double file name $dbfile $break" if  $dbfiles{$dbfile};
                $dbfiles{$dbfile}++;
#print "hashed $break";
            }
#print "sampled $break";
        }
        else {
            print "query failed: '$querystring' $break $break";
            $page->flush;
            $GateKeeper->disconnect;
            exit;
        }
        $sth->finish();
        $nr = keys %dbfiles;

        print "DONE $break $nr files found which have previously been processed$break$break";
        if ($nr == 0 ) {
            print "NULL result: query = '$querystring' $break $break";
        }
        print "Polling repository $ROOTDATADIR for (new) Reads ...$break";
        print "... using" if ($fnfilter || $gbfilter);
        print " name filter \"$fnfilter\""     if ($fnfilter =~ /\S/);
        print " global filter \"$gbfilter\""   if ($gbfilter =~ /\S/); 
        print "  (forceload)" if ($forced);
        print " $break";
    # output in array @$newfiles with names of files in disk

        $GateKeeper->dropDead("ABORTED: $ROOTDATADIR") if ($ROOTDATADIR =~ /\<.*\>/);

        $newfiles = &getNewReadFiles (\%dbfiles,$ROOTDATADIR,\@excludekeys,$fnfilter,$gbfilter,$LOADPERRUN); 

    # if in harvest mode, add files to PENDING

        if ($fnfilter eq 'HARVEST') {
            $PENDING->setMultiLineInsert(200);
            my $loaded = 0;
            my $np = $PENDING->count(0);
            foreach my $read (@$newfiles) {
                my @parts = split '/',$read;
                $read = $parts[$#parts];
#                print "add to PENDING: $read for assembly nr $assemblynmbr$break";
#                &addPending($read,$assemblynmbr);
                $PENDING->newrow('readname',$read,'assembly',$assemblynmbr);
                $loaded++;
            }
            $PENDING->flush();
            my $npends = $PENDING->count(0);
            $np = $npends - $np;
            print "$break $np filenames added to PENDING ($loaded) $break";

#            $organisms->update('reads_pending',$npends,'dbasename',$database);
#            $organisms->signature($userid,'dbasename',$database);

            $LOADPERRUN = 0;
#            $GateKeeper->dropDead("Use the loader from the command line to load PENDING data");
        }
    }

    else {
        print "Scanning database $database for PENDING Reads only ... ";
        my $querystring = "SELECT PENDING.readname FROM $database.PENDING left join ";
        $querystring .= "$database.READS where PENDING.record=READS.readname and READS.readname is null ";
        $querystring .= "order by readname ";
#        my $querystring = "SELECT readname FROM $database.PENDING order by readname ";
        $querystring .= "limit $LOADPERRUN" if $LOADPERRUN;
 print "querystring: $querystring$break";
        my $sth = $dbh->prepare ($querystring);
    # get files in PENDING
        $sth->execute();
        while (my $dbfile = $sth->fetchrow_array()) {
            $dbfiles{$dbfile}++;
        }
        $sth->finish();

#        $nr = keys %dbfiles;
#        print "... $nr pending files found${break}Testing against READS table ... ";
#        foreach my $key (keys %dbfiles) {
# test if read already loaded to weed out possible double entries
#            if ($READS->associate('read_id',$key,'readname')) {
#                $PENDING->delete('readname',$key);
#                delete $dbfiles{$key};
#            } 
#        }

        $nr = keys %dbfiles;
        print "DONE ... $nr (new) pending reads found";
        if (!$nr && $PENDING->count()) {
            print "WARNING! $database.PENDING contains duplicate readnames$break"; 
        }

        print "  (forceload)" if ($forced);
        print "$break$break";

        undef my @pendingfiles;
        if ($gbfilter && $gbfilter eq "ORACLE") {
# get the files from Oracle
print "SCHEMA $SCHEMA, PROJECT $PROJECT ${break}"; 
            if (!$SCHEMA || !$PROJECT) {
                $GateKeeper->dropDead("no SCHEMA or PROJECT specified for ORACLE data");
            }
# build array with names to be sent to Oracle reader
            foreach my $key (keys (%dbfiles)) {
                push @pendingfiles, $key;
            }
# print "pending files @pendingfiles $break";
	    my $success = $reader->fetchOracleData($SCHEMA,$PROJECT,\@pendingfiles);
print "success = $success $break";
            undef @pendingfiles if !$success; # protection, forcing controlled exit
# undef @pendingfiles;
        } 
        else {
# reads are assumed to be in project directory; we test the ROOTDATADIR and its subdirectories
# print "rdd $ROOTDATADIR  $break";
            my @subdirs = `ls -d ${ROOTDATADIR}/*`;
# print "sub @subdirs $break";
            my $counter = 0;
            undef my $previous;
            foreach my $key (sort keys (%dbfiles)) {
                my $filename = $ROOTDATADIR.$key;
                $counter++; print STDOUT "trying to find file $key ($counter) $break" if ($counter%1000 == 0);
# print "find 1 $key: try $filename$break";                     
                if (-e $filename) {
                    push @pendingfiles, $filename;
                } 
                else {
# try the subdirs; first try the previous one (to speed up)
                    if ($previous) {
                        $filename = "$previous/$key";
# print "using previous $previous file $key found: $filename$break";
                        if (-e $filename) {
                            push @pendingfiles, $filename;
                            next; 
                        }
                    }
                    my $found = 0;
                    foreach my $subdir (@subdirs) {
                        chomp $subdir;
                        $filename = "$subdir/$key";
# print "find 2 $key: try $filename$break";                     
                        if (-e $filename) {
                            push @pendingfiles, $filename;
# print "file $key found: $filename$break";
                            $previous = $subdir;
                            $found = 1; 
                            last;
			}
                    }
                    next if ($found);
# still not found: try the search dirs
                    foreach my $sdir (@SEARCH_DIR) {
                        $filename = $sdir.$key;
# print "find 3 $key: SD '$sdir': try  $filename $break"; 
                        if (!(-e $filename)) {
                            my $command = "ls ${sdir}*/$key";
# print "find 4 $key: try $command$break"; 
                            $filename = `$command`;
                            chop $filename if ($filename);
                        }
                        if (-e $filename) {
                            push @pendingfiles, $filename;
# print "file $key found: $filename$break";
                            $found = 1;
                            last; 
                        }
		    }
                    print "! Failed to locate file $key$break" if !$found;
                }
            }
# print "Files:@{pendingfiles}$break";
        }
        $newfiles = \@pendingfiles;
    }
  
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# (III) scan the data repository for new read files
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    $nr = @$newfiles;
    print "polling DONE ($nr new files) $break$break";
$LOADPERRUN =~ s/\W/x/g;
    print "$nr new Reads found (of which at most ${LOADPERRUN} will be processed)$break$break";

    if (!$origin && $TEST && $TEST =~ /^test$/) {
        foreach my $file (@$newfiles) {
            print "$file $break";
        }
        $GateKeeper->disconnect;
        print "test mode ended $break";
        exit 1;
    }

# update the default settings of ORGANISMS and ASSEMBLY tables

    if ($update) {
#print "update source $source$break";
#print "update GMD SCF RDD RUT$break";
        $organisms->packAttribute ($database,'dbasename','attributes','anlast',$assemblyname);
        $organisms->packAttribute ($database,'dbasename','attributes','GMD',$GELMINDDIR);
        $organisms->packAttribute ($database,'dbasename','attributes','SCF',$SCFREADDIR);
        $organisms->packAttribute ($database,'dbasename','attributes','RDD',$ROOTDATADIR);
        my $overallRoot = $ROOTDATADIR; $overallRoot =~ s/\/\w+\/?$/\//; # chop off last subdir
        $organisms->packAttribute ($database,'dbasename','attributes','RUT',$overallRoot);

        if ($source == 2) {
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','SCH',$SCHEMA);
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','PRO',$PROJECT);
        }
        else {
#print "update RDD LGF LPR   assemblyname $assemblyname$break";
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','RDD',$ROOTDATADIR);
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','LGF',$arc_logfile) if ($logON);
            $assembly->packAttribute ($assemblyname,'assemblyname','attributes','LPR',$LOADPERRUN);
            if ($source == 0) {
#print "update GBF FNF$break";
                $assembly->packAttribute ($assemblyname,'assemblyname','attributes','GBF',$gbfilter);
                $assembly->packAttribute ($assemblyname,'assemblyname','attributes','FNF',$fnfilter);
            }
        }
    }

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# (IV) go through all those new files and add the reads to the database
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#    my $encoder = Compress->new(); # default encoding string for DNA ('ACGT- ')

    my $tested = 0;
    my $loaded = 0;
    my $errors = 0;
    my $warning = 0;
    my $ignored = 0;

    my $timestamp = $organisms->timestamp(0);
    print LOG "\nNEW SESSION $timestamp\n" if ($logON);

    my $consensus = $GateKeeper->lookup('consensus');

    undef my %assemblycount;

    foreach my $file (@{$newfiles}) {

        last if ($LOADPERRUN-- <= 0);

        $file =~ s?//?/?g; # remove possible double slashes
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (0) Get the Read information for the next file
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        $errors = 0;
        $warning = 0;

# treat a consensus file differently from a standard read

        my $scm = 99;
        my $qcm = 99;

        my $entry;
        my $isStdRead;

        $tested++;
        if ($file =~ /split/i && ($file =~ /con|repeat|exon/i || $consensus)) {

            $isStdRead = 0; # it's a consensus file

            print STDOUT "${break}Processing consensus read $file ($tested) ...$break";
          
            $entry = $reader->newRead($file,1); # 1 for consensus file

#            $scm = 2; # switch to Huffman encoding
#            $qcm = 2; # Huffman encoding
 
	}
        else {

            $isStdRead = 1; # it's a standard read

            print STDOUT "${break}Processing experiment file $file ($tested) ...$break";

            if ($entry = $reader->newRead($file)) {
                $reader->format(); # test conformity to Sanger format
                $reader->ligation();
                $reader->strands();
                $reader->chemistry();
            }
#            $scm = 1; # standard triplet encoding for DNA
#            $qcm = 1; # number substitution on quality data
#            $qcm = 3; # Huffman compression on quality difference data
        }

# skip this file on error

        print LOG "\n" if $logON;
        my ($summary, $errorstatus) = $reader->status(2,$origin);
        print STDOUT "$summary"; # either plain text or HTML
        if (!$entry || $errorstatus) {
            my $fulltext = $reader->list(0,1); # full list in plain text
            $ignored++;
            next if (!$entry || $TEST);
            print LOG "$fulltext\n" if ($logON && !$TEST);
# add the entry to PENDING if not already done
            my $add = &addPending ($entry->{ID},$assemblynmbr);
            print STDOUT "${rfont}$add$efont$break";
            next; 
        }
        elsif ($logON) {
           ($summary, $errorstatus) = $reader->status(2,0);
            print LOG "$summary";
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (1) Encode strings and test if coded lengths match
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        if (my $error = $reader->encode($scm, $qcm)) {
            $error =~ s/\n/$break/g;
            print STDOUT "ERROR: $ofont$error$efont$break";
            print LOG "$error\n" if ($logON);
#print $reader->list($origin,1);
            last if ($error =~ /Invalid/);
            next;
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# 
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        if ($TEST) {
	    my $text = $reader->list($origin,1);
            print STDOUT "$break $text $break";
            next;
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (4) Insert a new row into reads by defining new primary key and add values
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          
        my $text = "Insert new data into READS ...";
        my $update = $reader->insert();
        $text .= "... $update READ items entered into database";
        print STDOUT "$text$break\n";
        print LOG "$text\n" if $logON;

        undef my $readhash;
        if ($update <= 0) {
            print STDOUT "! Read insert $ofont FAILED $efont$break";
            my $fulltext = $reader->list(1,0);
            print STDOUT "$fulltext";
            print LOG "$fulltext\n" if ($logON);
            $errors++;
        }
         
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (5) Read the DNA en Quality data from the database and test against originals   
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        else {
# read back of data 
            print STDOUT "Readback of Sequence and Quality data .. ";
            if (my $error = $reader->readback) {
                $error =~ s/\n/$break/g;
                print STDOUT "ERROR: $ofont$error$efont$break";
                print LOG "$error\n" if ($logON);
#print $reader->list($origin,1);
                $errors = 1;
            }
            else {
                print STDOUT "${gfont}PASSED$efont$break";
            }
        }

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  (6?) if any problem encountered, rollback all changes made; else reset rollbacks
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        foreach my $key (keys %$hashes) {
# reset if $errors == 0, else undo updates 
            $hashes->{$key}->rollback($errors) unless ($errors && $key =~ /PENDING|SESSION/);
        }
#        $reader->rollBack($error,'PENDING|SESSION');
        if ($errors && $READS->{qerror} =~ /already\sexists/) {
            $PENDING->delete('readname',$entry->{ID}) if $entry->{ID};
            $ignored++;
        }
        elsif ($errors) {
            $ignored++;
# add the entry to PENDING if not already done
            my $add = &addPending ($entry->{ID},$assemblynmbr);
            print STDOUT "${rfont}$add$efont$break" if ($add);
        }
        elsif (!$errors) {
            $loaded++;
            my $assemblynumber = $assemblynmbr; # use current specification
# print "assembly $assemblynmbr $break";
    # check if the entry was in PENDING
            if (!$cgi && $assemblynmbr) {
                $PENDING->delete('readname',$entry->{ID});
            }
            elsif (my $hashref = $PENDING->associate('hashref',$entry->{ID},'readname')) {
    # get the assemblynumber
                $assemblynumber = $hashref->{assembly} || 0;             
    # and clear the entry if it was in pending
                $PENDING->delete('readname',$entry->{ID});
            }
     # add the entry to READS2ASSEMBLY
            my $read_id = $READS->associate('read_id',$entry->{ID},'readname');
#            my $read_id = $readhash->{read_id};
            if (!$RRS2ASS->newrow('read_id',$read_id,'assembly',$assemblynumber)) {
                print "$RRS2ASS->{qerror}$break";
                $RRS2ASS->status(1); # reset the error status
            }
            else {
                $assemblycount{$assemblynumber}++;
            }
        }
        else {
            $ignored++;
            print STDOUT "${bfont}read $entry->{ID} is already loaded$efont$break";
        }
        print STDOUT "$break";
# next file
        if ($LOADPERRUN%100 == 0 && $abortfile && (-e $abortfile)) {
            $LOADPERRUN = 0;
            print "${break}ABORT command received $break$break";
            unlink $abortfile;
        }
    }

    print STDOUT "${break}Flushing tables$break";
    $READS->flush(1); # flush all

# closing down: timestamps on altered tables

    my $list = 1; $list = 2 if $cgi;
    $userid = $GateKeeper->{USER} if !$userid;
    $organisms->historyUpdate($userid,0,$list);

    print STDOUT "${break}Updating counters and closing database$break$break";

    foreach my $assemblynumber (keys (%assemblycount)) {
        my $areads = $RRS2ASS->count("assembly=$assemblynumber");
        print "assembly $assemblyname (nr $assemblynumber) reads counted: $areads $userid$break";
        $assembly->update('reads',$areads,'assemblyname',$assemblyname);
        $assembly->signature($userid,'assemblyname',$assemblyname);
        if ($assembly->associate('progress',$assemblyname,'assemblyname') eq 'other') {
            $assembly->update('progress','in shotgun','assemblyname',$assemblyname);
        }
    }

    my $nreads = $READS->count(0);
    $organisms->update('reads_loaded' ,$nreads,'dbasename',$database);
    my $npends = $PENDING->count(0);
    $organisms->update('reads_pending',$npends,'dbasename',$database);
    $organisms->signature($userid,'dbasename',$database);
    $GateKeeper->disconnect;

# closing line

    my $report = "END of SESSION: $tested reads processed, $loaded loaded, ";
    $report .= " $yfont$ignored ignored$efont" if (!$TEST);
    print STDOUT "$report$break$break";
    print LOG "$report\n" if $logON;

    if ($page) {
        my $rreturn = "$arc_cgi_dir/rloader/$database/specify";
        $rreturn .= $cgi->postToGet(1,'database','assemblyname','source','session');
        $page->linkbutton('LOAD MORE',$rreturn,0);
        $page->flush();
    }

    my $csroot = $GateKeeper->prepareFork('harmonize');
    my $harmonize = "$csroot/harmonize organisms copy";
    $harmonize .= " >> $arc_tmp_dir/harmonize.log" if $cgi;
    system ($harmonize);  

    exit 0;

########################################## addPending #################################

sub addPending {
    my $readname = shift;
    my $fragment = shift;

# add the entry to PENDING if not already done

    my $report = "read $readname to be added to PENDING ...";
    if (!$PENDING->associate('record',$readname,'readname',-1)) {
  
        my $add = $PENDING->newrow('readname',$readname,'assembly',$fragment);

        $report .= "... DONE"   if $add;
        $report .= "... FAILED" if !$add;
    }
    else {
        $report .= "... SKIPPED";
    }
    return $report;
}

########################################## getNewReadFiles ###############################################

sub getNewReadFiles {
    my $dbfiles   = shift;  # hash with existing file names in database
    my $directory = shift;  # top directory of data depository
    my $excluders = shift;  # reject filters
    my $flnfilter = shift;  # file name filter (file name only)
    my $glbfilter = shift;  # global filter (on file name and path)
    my $MAXREAD   = shift;

    my $DEBUG = 0;

    $directory =~ s/^\s+|\s+$//; # chop leading blanks, trailing blanks

    my $file;

    my @dirs = `ls $directory`;

    $MAXREAD = 1000 if (!defined($MAXREAD));
 
#$DEBUG = 1 if ($directory =~ /MUST/);
my $nrr = keys %$dbfiles;
print "directory $directory $break dbfiles $nrr $break" if $DEBUG;
print "exclude: @{$excluders}${break}filter : $flnfilter$break gbfilter : $glbfilter$break" if ($DEBUG);
$MAXREAD = 10 if ($DEBUG);

    undef my @newReads;
DIR:foreach my $sdname (@dirs) {
    # analyse next directory name, get files and analyse file names
        chomp $sdname; # cleanup
print "testing dir $sdname$break" if $DEBUG;
        next DIR if ($glbfilter =~ /\S/ && $sdname !~ /$glbfilter/);
        foreach my $exclude (@{$excluders}) {
print "rejected directory: $sdname  $break" if ($sdname =~ /$exclude/ && $DEBUG);
            next DIR if ($sdname =~ /$exclude/); # exact match
        }

       (my $subdir = "$directory/$sdname/") =~ s/\/\//\//g;

        print "... scanning directory $subdir$break";

        my $find = "find $subdir";
        $find .= " -atime $glbfilter" if ($flnfilter eq "HARVEST");
print "find: $find $break" if $DEBUG;
        if ($flnfilter && $flnfilter ne 'HARVEST') {
            open (FILE,"find $subdir | grep $flnfilter |") || die "cannot open directory";
        } else {
            open (FILE,"find $subdir |") || die "cannot open directory";
        }

        my $filetest = 0;
        my $filecount = 0;
NEXT:   while (defined($file=<FILE>)) {
            chomp $file; # cleanup
my $l = length($file);	    print "1 test file $file  (length $l)$break" if ($DEBUG);
            $filetest++; # keep track
        # test against filters
print "1 reject $file ($flnfilter)$break" if ($flnfilter && !($file =~ /$flnfilter/) && $DEBUG);
            next NEXT if ($flnfilter =~ /\S/ && $flnfilter ne 'HARVEST' && !($file =~ /$flnfilter/));
            next NEXT if ($glbfilter =~ /\S/ && !($file =~ /$glbfilter/));
        # test against allowed pattern and get shortname
if (!($file =~ /^$subdir(\S+\/)?[\w\-\.]+\.\w\d?\w*$/) && $DEBUG) {
    print "2 reject $file$break";
    print "file |$file|  subdir |$subdir|$break";
}
            next NEXT if (!($file =~ /^$subdir(\S+\/)?([\w\-\.]+\.(\w\d?\w*)$)/));
            my $shortname = $2;
print "shortname = $shortname $break" if ($DEBUG);
	    next NEXT if (!($shortname =~ /\.\w\d?$/ || $shortname =~ /\.\w\d\w*$/));
            next NEXT if ($dbfiles->{$shortname} && (!$DEBUG || $DEBUG <= 1));
        # find possible directories beneath the $subdir
            my $subdirname = $file;
            $subdirname =~ s/$subdir//; # remove the top directory
        # test against rejection strings
            foreach my $exclude (@{$excluders}) {
print "rejected file: $file (exclude $exclude) $break" if ($subdirname =~ /$exclude/i && $DEBUG);
                next NEXT if ($subdirname =~ /$exclude/i);
            }
print "NEW FILE: $file  (maxread= $MAXREAD) $break" if $DEBUG;
            last if ($MAXREAD-- <= 0);
            push @newReads, $file;
            $filecount++;
print "new file: $file $break" if($DEBUG);
        }
        print "... $filetest files tested, $filecount accepted$break";
        close FILE;
        last DIR if ($MAXREAD <= 0);
    }
    \@newReads;
}

########################################## forms #################################

sub form1 {
    my $form;
    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH 100%>";
    $form .= "<TR><TD><INPUT TYPE='radio' NAME='source' VALUE=0 checked></TD>";
    $form .= "<TD>By Read Name Filter</TD><TD>from:</TD><TD>Experiment Directories</TD></TR>";
    $form .= "<TR><TD><INPUT TYPE='radio' NAME='source' VALUE=1></TD>";
    $form .= "<TD>PENDING Reads</TD><TD>from:</TD><TD>Experiment Directories</TD></TR>";
    $form .= "<TR><TD><INPUT TYPE='radio' NAME='source' VALUE=2></TD>";
    $form .= "<TD>PENDING Reads</TD><TD>from:</TD><TD>ORACLE database</TD></TR>";
    $form .= "</TABLE>";

    return $form;
}

sub form2 {
    my $source = shift;

    my $form;

    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH 100%>";
    if ($source == 0 || $source == 1) {
        $form .= "<TR><TH ALIGN=LEFT>Data directory root</TH>";
        $form .= "<TD COLSPAN=2><INPUT NAME='RDD' SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";
        $form .= "<TR><TH ALIGN=LEFT>Gelminder directory</TH>";
        $form .= "<TD COLSPAN=2><INPUT NAME='GMD'  SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";
        $form .= "<TR><TH ALIGN=LEFT>SCF directory name</TH>";
        $form .= "<TD COLSPAN=2><INPUT NAME='SCF'  SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";

        if ($source == 0) {
            $form .= "<TR><TH ALIGN=LEFT>Filename Filter</TH>";
            $form .= "<TD><INPUT NAME='FNF' SIZE=16 MAXSIZE=64 VALUE=''></TD>";
            $form .= "<TD>&nbsp</TD></TR>";
            $form .= "<TR><TH ALIGN=LEFT>Directory Filter</TH>";
            $form .= "<TD><INPUT NAME='GBF' SIZE=16 MAXSIZE=64 VALUE=''></TD>";
            $form .= "<TD>&nbsp</TD></TR>";
        }
    }

    elsif ($source == 2) {
        $form .= "<TR><TH ALIGN=LEFT>Oracle Schema Name</TH>";
        $form .= "<TD><INPUT NAME='SCH'  SIZE=16 MAXSIZE=32 VALUE='<S>'></TD>";
        $form .= "<TD>&nbsp</TD></TR>";
        $form .= "<TR><TH ALIGN=LEFT>Oracle Project Name</TH>";
        $form .= "<TD><INPUT NAME='PRO' SIZE=16 MAXSIZE=32 VALUE='<P>'></TD>";
        $form .= "<TD>&nbsp</TD></TR>";
    }

    $form .= "<TR><TH ALIGN=LEFT>DATABASE Assembly Name</TH><TD>SELECTTAG</TD>";
    $form .= "<TD><b>Check</b> <INPUT type=checkbox name=consensus> for CONSENSUS data </TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Load a maximum of </TH>";
    $form .= "<TD><INPUT VALUE='1' SIZE=5 NAME='LPR'> reads</TD>";
    $form .= "<TD><b>Check</b> <INPUT type=checkbox name=forceload> for FORCED load </TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Check <INPUT type=checkbox name=logON checked> for log file</TH>";
    $form .= "<TD COLSPAN=2><INPUT NAME='LGF' SIZE=32 MAXSIZE=64 VALUE=''></TD></TR>";

    $form .= "<TR><TH AKIGN=LEFT>Check <INPUT type=checkbox name=testrun> for TEST run </TH>";
    $form .= "<TH ALIGN=RIGHT COLSPAN=2> Check <INPUT type=checkbox name=update> for update of defaults </TH></TR>";
    $form .= "</TABLE>";

    return $form;
}

#!/usr/local/bin/perl -w

#############################################################################
#
# auxilliary script to update specific database tables (re: 'create' script)
#
#############################################################################

use strict;

use GateKeeper; 
use Compress;

##############################################################################
# unbuffered output
##############################################################################

open(STDERR,">&STDOUT") || die "Can't dump to STDOUT: $!\n";
select(STDERR); $| = 1; # Make unbuffered.
select(STDOUT); $| = 1; # Make unbuffered.

##############################################################################
# get configuration data, open CGI and MySQL Database
##############################################################################

my $GateKeeper = GateKeeper->new('mysql',{insistOnCGI => 1});

my $config     = $GateKeeper->configHandle();

my $cgi        = $GateKeeper->cgiHandle();

my ($void,$action,$database,$tablename) = split ('/',$GateKeeper->origin);

my $organisms  = $GateKeeper->dbHandle($database,{returnTableHandle => 1});

$GateKeeper->cgiHeader(2); # return string plain

##############################################################################
# MAIN
##############################################################################

my $USERSUPPORT = $config->get("USERSUPPORT");
my $db_manager  = $config->get("db_manager");    
my $arc_cgi_dir = $config->get("ARC_CGI_DIR");  
my $arc_htm_dir = $config->get("ARC_HTML_DIR");

my $page = $GateKeeper->GUI('ARCTURUS ASSEMBLY-TRACKING DATABASE');
#$page->address('ejz@sanger.ac.uk','Ed Zuiderwijk',2);
#$page->frameborder(100,15,'white',15);

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# open the ORGANISMS table in arcturus
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

my $loadinfo  = $organisms->unpackAttributes($database); # ($database,'dbasename','attributes');

#$page->partition(2);
$page->sectionheader("ARCTURUS assembly tracking database: INGEST",3,0);
#$page->partition(1);
#$page->center(1);

# protect against unintended usage of this script

if ($cgi->parameter('database') ne "$database" || $cgi->parameter('tablename') ne $tablename) {
    $page->errorbox("This script is invoked in an invalid manner",0,0,'yellow');
    $page->add($cgi->PrintVariables);
}

elsif ($action eq 'specify' && $tablename eq 'STSTAGS') {
#    $page->center(1);
    $page->sectionheader("Please define input data files for STS tags",4,0); 
    $page->form("$arc_cgi_dir/tmanager/compare/$database/$tablename");
    my $comment = "Note: if the filenames submitted contain the wildcard ";
    $comment   .= "symbol '*' the tag data<br>for several assemblies of the ";
    $comment   .= "$database genome may be checked and updated";
    $page->messagebox($comment,0,1,'yellow');
    $page->add(&ststagsform,0,1); 
    $page->preload('stsmapfile',$loadinfo->{stsmap});
    $page->preload('stsfasfile',$loadinfo->{stsfas});
    $page->preload('stsepcfile',$loadinfo->{stsepc});
    $page->ingestCGI();
    $page->submitbuttonbar(1,0,0);
#    my $reject = "$arc_cgi_dir/update/arcturus/getmenu";
#    $page->linkbutton('REJECT',$reject,0);
}

elsif ($action eq 'specify' && $tablename eq 'CLONEMAP') {

#    $page->center(1);
    $page->sectionheader("Please define input data file for the Physical Map",4,0); 
    $page->form("$arc_cgi_dir/tmanager/compare/$database/$tablename");
    my $comment = "Note: if the filename submitted contains the wildcard ";
    $comment   .= "symbol '*' the physical<br>maps for several assemblies of the ";
    $comment   .= "$database genome may be checked and updated";
    $page->messagebox($comment,0,1,'yellow');
    $page->add(&physmapform,0,1); 
    $page->preload('physmapfile',$loadinfo->{physmap});
#    $cgi->delete('confirm'); $cgi->delete('submit');
    $page->ingestCGI();
    $page->submitbuttonbar(1,0,0);
#    my $reject = "$arc_cgi_dir/update/arcturus/getmenu";
#    $page->linkbutton('REJECT',$reject,0);
}


elsif ($action eq 'specify' && $tablename eq 'CLONES2CONTIG') {
# this needs a subroutine scanning through the contigs
# select READS.clone,READS2CONTIG.contig_id,READS2CONTIG.pcstart,READS2CONTIG.pcfinal
# from READS,READS2CONTIG (where READS2CONTIG.read_id = READS.read_id AND contig_id=<n>)
# what about CONTIGS2SCAFFOLD astatus :(CONTIGS2SCAFFOLD.contig_id=READS2CONTIG.contig_id
# AND CONTIGS2SCAFFOLD.astatus = 'N')
# go through all lines and find the position range of each clone_id 
}

elsif ($action eq 'specify' && $tablename eq 'STS2CONTIG') {
# this requeres a subroutine parsing the STS file linking contig names (or alias) to
# tags. First build a table of tags positions by parsing the file; then query the
# contigs table for contig_id and STStags table for tag_id; then add those tags not 
# already stored to database
}

elsif ($action eq 'specify') {
#    $page->center(1);
    $page->errorbox("Invalid table $tablename");
#    my $reject = "$arc_cgi_dir/update/arcturus/getmenu";
#    $page->linkbutton('BACK TO MAIN',$reject,0);
}

#************************** process STS maps ******************************

elsif ($action eq 'compare' && $tablename eq 'STSTAGS') {

    my $stsmapfile = $cgi->parameter('stsmapfile') || 0;
    my $stsfasfile = $cgi->parameter('stsfasfile') || 0;
    my $stsepcfile = $cgi->parameter('stsepcfile') || 0;
    my $fulltest   = $cgi->parameter('fulltest')   || 0;
    my $cleanup    = $cgi->parameter('cleanup')    || 0;
    my $update     = $cgi->parameter('update')     || 0;
    my $confirm    = $cgi->parameter('confirm')    || 0;
    my $identify   = $cgi->parameter('identify')   || 0;
    my $password   = $cgi->parameter('PASSWORD')   || 0;
    $fulltest = 1 if ($cleanup);

    undef my $updates;

#    $page->center(1);
    $page->form("$arc_cgi_dir/tmanager/compare/$database/$tablename");
    $page->sectionheader("Update STS tags database",4,1);

# if CONFIRM is specified a username and password have to be defined

    if ($confirm eq 'CONFIRM') {
        my $people = $organisms->spawn('USERS','arcturus',0,1);
        my $PASSWORD = $people->associate('password',$identify,'userid') || 0;
        if (!$password || !$PASSWORD || !$cgi->VerifyEncrypt($password,$PASSWORD)) {
            $confirm = -1; # suppress some subsequent output
        }     
    }
    else {
        $confirm = 0; # disable
    }

# set up the encoder module

    my $encoder = new Compress('ACGTN ');

# open ststags database and store the data in a hash

    my $ststags = $organisms->spawn('STSTAGS',$database,0,1);
    my $hashrefs = $ststags->{hashrefs}; # array of hashes for the STS data
# build the inverse hash with tagname as a key (test name)
    undef my %tagnamehash;
    foreach my $hash (@$hashrefs) {
        my $name = $hash->{name};
        $tagnamehash{$name} = $hash if ($name);
        $updates .= "! Input error on table STSTAGS<br>" if (!$name);
# if full test is to be done, expand the DNA data here, if they are compressed
        my $sequence = $tagnamehash{$name}->{sequence};
        if ($tagnamehash{$name}->{scompress}) {
           (my $length,$sequence) = $encoder->sequenceDecoder($sequence,1);
	    $sequence =~ s/\s+$//; # remove trailing blanks
            $tagnamehash{$name}->{sequence} = $sequence; # expanded DNA 
#	   print "$name $sequence<br>\n";
        }
    }

# %tagnamehash contains the data already stored in the database 
# parse the data files: tick off the tags already in tagnamehash if !$fulltest

    undef my %tagEntry;
    $updates .= &parseSTSfile ($stsfasfile, \%tagEntry);
    $updates .= &parseSTSfile ($stsepcfile, \%tagEntry);
# flag entries which already occur in the database table
    foreach my $tag (keys %tagEntry) {
        my $status = 0;
        $status = 1 if ($tagnamehash{$tag});
        $tagEntry{$tag}->{status} = $status;
    }
# %tagEntry contains hashrefs to tagdata read from files; %tagnamehash those 
# in database now collect the mapping data for those tags appearing on stsmapfile
    $updates .= &parseSTSmap ($stsmapfile, \%tagEntry);
    if (!$fulltest) {
# cleanup the hash: remove tags which have already been loaded
        foreach my $tag (keys %tagEntry) {
            delete $tagEntry{$tag} if ($tagEntry{$tag}->{status} != 2);
        }
    }
# test completeness and consistence of data in %tagEntry against database
    undef my @newtags;
    if ($fulltest || $cleanup) {
        my @keys = ('sequence','slength','assembly','linkage','position');
        foreach my $tag (sort keys (%tagEntry)) {
	    my $hash = $tagEntry{$tag};
        # if the tag already exists in the database, test against newentry
            if (my $table = $tagnamehash{$tag}) {
                undef my $mismatch;
                undef my $notfound;
                foreach my $key (@keys) {
# print "key=$key  defined=defined($table->{$key}) value=$table->{$key}<br>";
                    if (defined($table->{$key}) && defined($hash->{$key})) {
                    # test if both are numerical
                        if ($table->{$key} !~ /[^\d\.]/ && $hash->{$key} !~ /[^\d\.]/) {
                            my $evaluate = $table->{$key} - $hash->{$key};
                            $hash->{$key} = $table->{$key} if ($evaluate == 0);
                        }
                        if ($table->{$key} ne $hash->{$key}) {
                            $mismatch .= "  existing STSTAGS $key value |$table->{$key}|";
                            $mismatch .= " conflicts with new value |$hash->{$key}|\n"; 
                        }
                    }
                    elsif (!defined($hash->{$key})) {
                        $notfound++; # signal missing table data
                    }
                }
                $updates .= "Description mismatch for tag $tag\n$mismatch" if ($mismatch);
                push @newtags, $hash if ($notfound && !$mismatch);
                push @newtags, $hash if ($mismatch && $cleanup);
            }
        # if the tag does not exist in the database, add to new tags list
            else {
# print "tag $name not in database<br>";
                push @newtags, $hash;
            }
        }
    }
    else {
        foreach my $tag (sort keys %tagEntry) {
            push @newtags, $tagEntry{$tag};
        }
    }
    my $newtags = @newtags;
    $updates .= "$newtags tags to be added or updated\n";
    $updates =~ s/\n/<br>/g;
    $page->messagebox($updates,0,1);

# now add to the database

    my @keys = ('sequence','scompress','slength','assembly','linkage','position');
    my $count = 0;
    $updates = "";
    foreach my $hash (@newtags) {
# skip nulled hah values 
        if ($hash) {
            $count++;
            my $name = $hash->{name};
# print "newrow name=$name ";
            if (my $sequence = $hash->{sequence}) {
                $hash->{scompress} = 0; # default no compression
               (my $length,$sequence) = $encoder->sequenceEncoder($sequence,1);
                $hash->{sequence} = $sequence if ($sequence); # encoded DNA 
                $hash->{scompress} = 1 if ($sequence);
            }
         
            if (!$tagnamehash{$name}) {
                $updates .= "New tag $name ";
                if ($confirm eq 'CONFIRM') {
                    $updates .= "added: ";
                    $ststags->newrow('name',$name);
                }
                else {
                    $updates .= "to be  added: ";
                }
            }
 	    else {
                $updates .= "Data for tag $name updated: ";
            }
            foreach my $key (@keys) {
                $updates .= "$key .. ";
                if (defined($hash->{$key}) && $confirm eq 'CONFIRM') {
                    $ststags->update($key,$hash->{$key},'name',$name);
                    $updates .= "DONE, ";
                }
                elsif (!defined($hash->{$key})) {
                    $updates .= "MISSING!, ";
                }
            }
            $updates .= "<br>";
        }
    }
#$updates .= "MISSING";
    if ( $confirm ne 'CONFIRM' && $confirm >= 0 && $updates =~ /MISSING/) {
        $page->warningbox("There are missing tag items",0);
        $page->messagebox($updates,0,0);
        $page->sectionheader("Be sure before you continue!",4,1);
    }
    elsif ($confirm eq 'CONFIRM' && $updates =~ /MISSING/) {
        $page->messagebox($updates,0,1);
    }

    my $return = "$arc_cgi_dir/tmanager/specify/$database/STSTAGS";
    $return .= "\?tablename=$tablename\&database=$database\&identify=ejz";
    if ($confirm eq 'CONFIRM' && $count > 0) {
        my $message = "$count tags processed";
    # updating organism database by through link to separate action item
        if ($update) {
            $update  = $organisms->packAttribute($database,'dbasename','attributes','stsmap',$stsmapfile);
            $update += $organisms->packAttribute($database,'dbasename','attributes','stsfas',$stsfasfile);
            $update += $organisms->packAttribute($database,'dbasename','attributes','stsepc',$stsepcfile);
            $message .= "<br>Default filenames updated" if $update;
	}
        $page->messagebox($message,$return,0);
        $ststags->historyLogger($identify); # update history table
    }
    elsif ($confirm >= 0 && $count > 0) {
        $page->ingestCGI();
        $page->sectionheader("Please provide your password again and confirm",3,0);
        $page->identify('00',0,1);
        $page->confirmbuttonbar($return,1);
    }
    elsif ($confirm >= 0) {
        $page->messagebox("No new tags found",$return,1,'yellow');
    }
    else {
        $page->errorbox("Invalid or Missing password for user $identify");
    }
#
}

#****************************** processing Physical Maps ***********************

elsif ($action eq 'compare' && $tablename eq 'CLONEMAP') {

    $page->form("$arc_cgi_dir/tmanager/compare/$database/$tablename");

    my $confirm = $cgi->parameter('confirm');
    $confirm = 0 if (!$confirm || $confirm ne 'CONFIRM'); 
    my $fulltest = $cgi->parameter('fulltest');
    my $addclone = $cgi->parameter('addclone');

    my $physmapfile = $cgi->parameter('physmapfile');

# open ststags database and store the data in a hash

    my $physmap = $organisms->spawn('CLONEMAP',$database,0,1);
    my $hashrefs = $physmap->{hashrefs}; # array of hashes for the clone data
# build the inverse hash with clone name as a key to register clones already loaded
    undef my $report;
    undef my %clonehash;
    foreach my $hash (@$hashrefs) {
        my $name = $hash->{clonename};
        $report .= "! Duplicate clone name $name on table CLONEMAP<br>" if ($clonehash{$name});
        $clonehash{$name} = $hash if ($name);
        $report .= "! Input error on table CLONEMAP<br>" if (!$name);
    }
    $page->add($report) if ($report);

# parse the data file with the physical map; report what's found on the file(s)

    undef my @mapentry;
    $report = &parsePMfile ($physmapfile,\@mapentry);
    my $count = @mapentry;
    $page->sectionheader("$count items found on file(s) $physmapfile",4,0);
    $page->add($report) if ($fulltest);

# identify the assembly and clones therein and list what's actually in database

    my $clones   = $organisms->spawn('CLONES',  $database,0,1);
    my $assembly = $organisms->spawn('ASSEMBLY',$database,0,1);

    undef my $updates;
    my ($afound, $anotfound);
    my ($cfound, $cnotfound);
    $report = '<TABLE BORDER=0 CELLPADDING=2>';
    foreach my $entry (@mapentry) {
        my $name;
# first try if there is a clone name; else it should be an assembly entry
        if ($name = $entry->{clonename}) {
# test if there is a clone of that name in CLONES
            if (my $clone = $clones->associate('clone',$name,'clonename')) {
                $cfound .= ' '.$name;
	    }
            else {
                $cnotfound .= ' '.$name;
            # add the clone to the CLONES table
                if ($addclone) {
                    $report .= "<TR><TD>New clone name</TD><TD>$name</TD><TD>to be added to CLONES </TD>";
                    $updates++;
                    if ($confirm eq 'CONFIRM') {
                        my $status = $clones->counter('clonename',$name,0);
                        $status = $clones->update('origin','Physical Map') if $status;
                        $report .= "<TD BGCOLOR='yellow'> DONE </TD>" if $status;
                        $report .= "<TD BGCOLOR='orange'>FAILED</TD>" if !$status;
                    }
                }
            }
        }
        elsif ($name = $entry->{assembly}) {
# test if there is an assembly of that name in ASSEMBLY
            if (my $number = $assembly->associate('assembly',$name,'assemblyname')) {
                $afound .= ' '.$name;
            }
            else {
                $anotfound .= ' '.$name;
           }
        }
        else {
            $report .= "Missing 'clone' or 'assembly' key<br>";
        }
    }
    $report .= "</TABLE>";
    my $table = "<TABLE BORDER=1 CELLPADDING=2 WIDTH=90%>";
    $table .= "<TR><TH>&nbsp</TH><TH>Found</TH><TH>Not Found</TH></TR>";
    $afound = "&nbsp" if !$afound;  $anotfound = "&nbsp" if !$anotfound;
    $table .= "<TR><TH>Assembly</TH><TD>$afound</TD><TD>$anotfound</TD></TR>";
    $cfound = "&nbsp" if !$cfound;  $cnotfound = "&nbsp" if !$cnotfound;
    $table .= "<TR><TH>Clones</TH><TD>$cfound</TD><TD>$cnotfound</TD></TR>";
    $table .= "</TABLE>";
    $page->add($table) if $fulltest;
    $page->add($report) if $updates;

# now weedout the new enties for CLONEMAP; separate clone and assembly info

    undef my $missing;
    $report = '<TABLE BORDER=0 CELLPADDING=2>';
    my $testExisting = $report; # another table
    undef my @newclones;
    foreach my $entry (@mapentry) {
        my $name;
        if (($name = $entry->{clonename}) && !(my $hash = $clonehash{$name})) {
            push @newclones, $entry;
	}
# comparison of data for clone already existing in CLONEMAP (i.e. %clonehash)
        elsif ($name = $entry->{clonename}) {
             my $aname = $entry->{assembly};
             my $anmbr = $assembly->associate('assembly',$aname,'assemblyname');
             undef my $different;
             $different .= 'clonename ' if ($hash->{clonename} ne $entry->{clonename});
             $different .= 'cpkbstart ' if ($hash->{cpkbstart} ne $entry->{cpkbstart});
             $different .= 'cpkbfinal ' if ($hash->{cpkbfinal} ne $entry->{cpkbfinal});
             $different .= 'assembly '  if ($hash->{assembly}  ne $anmbr);
             if ($different) {
                 $testExisting .= "<TR><TD>mismatch for existing clone $name:</TD><TD>$different</TD></TR>";
             }
             else {
                 $testExisting .= "<TR><TD>clone $name tested OK</TD></TR>";
	     }
        }
# process assembly info: add to 
        elsif ($name = $entry->{assembly}) {
            my $size = $assembly->associate('size',$name,'assemblyname');
        # size is defined if the assembly exists in the database
            if (defined($size) && $size != $entry->{size}) {
                $report .= "<TR><TD>New size for assembly $name </TD>";
                $report .= "<TD>:</TD><TD>$entry->{size}</TD>";
                $updates++;
                if ($confirm eq 'CONFIRM') {
                    my $status = $assembly->update('size',$entry->{size},'assemblyname',$name);
                    $report .= "<TD BGCOLOR='yellow'> DONE </TD>" if $status;
                    $report .= "<TD BGCOLOR='orange'>FAILED</TD>" if !$status;
                }
            }
            elsif (!defined($size) && $fulltest) {
                $report .= "<TR><TD COLSPAN=2>Assembly $name does not exist</TD>";
            }
            elsif (!defined($size)) {
                $missing++;
            }
            $report .= "</TR>";
        }
    }
    $testExisting .= "</TABLE>";
    $page->add($testExisting) if ($testExisting =~ /mis/ || $fulltest);
    $report .= "</TABLE>";
    $page->add($report);
    $page->messagebox("$missing other assemblies are missing from the database",0,0,'yellow') if ($missing);
    $count = @newclones;
    $page->sectionheader("New data for $count Clones found",4,0);

# add the clone data to the physical map table
 
    $count = 0;   
    $table =  '<TABLE BORDER=0 CELLPADDING=2>';
    $table .= '<TR><TH>Clone</TH><TH colspan=2>Assembly</TH>';
    $table .= '<TH COLSPAN=2>Position (Kbase)</TH></TR>';
    foreach my $entry (@newclones) {
        my $name = $entry->{clonename};
        my $aname = $entry->{assembly};
        my $cps  = $entry->{cpkbstart};
        my $cpf  = $entry->{cpkbfinal};
        if (my $anmbr = $assembly->associate('assembly',$aname,'assemblyname')) {
            $table .= "<TR><TD>$name</TD><TD>$anmbr</TD><TD>($aname)</TD>";
            $table .= "<TD>$cps</TD><TD>$cpf</TD>";
            $count++; $updates++;
            if ($confirm && $confirm eq 'CONFIRM') {
                my $status = $physmap->newrow('clonename',$name,'assembly',$anmbr);
                $status = $physmap->update('cpkbstart',$cps) if $status;
                $status = $physmap->update('cpkbfinal',$cpf) if $status;
                $table .= "<TD BGCOLOR='yellow'> DONE </TD>" if $status;
                $table .= "<TD BGCOLOR='orange'>FAILED</TD>" if !$status;
            }
            $table .= "</tr>";
        }
        elsif ($fulltest) {
            $table .= "<TR><TD>$name</TD><TD>&nbsp</TD><TD>($aname)</TD>";
            $table .= "<TD>$cps</TD><TD>$cpf</TD><TD>Ignored: assembly not recognized</TD>";
            $table .= "</tr>";
        }
    }
    $table .= "</TABLE>";
    $page->sectionheader("New data for $count Clones to be entered",4,0);    
    $page->add($table,0,1) if $count;

# confirm button

    my $reject = "$arc_cgi_dir/tmanager/specify/$database/$tablename";
    $reject .= "\?database=$database\&tablename=$tablename";
    if ($confirm ne 'CONFIRM' && $updates) {
        $page->ingestCGI($cgi);
        $page->confirmbuttonbar($reject,0);
    }
    else {
        $page->linkbutton('CONTINUE',$reject);
    }

# $page->add($cgi->PrintVariables());
}   


else {
    print "Invalid option $action for INGEST\n";
}

# $organisms->historyUpdate($userid,0,1);
 
$page->form(0);
$page->flush();
$GateKeeper->disconnect;
exit 0;

########################################## forms ###############################

sub ststagsform {
    my $form;

    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH 100%>";
    $form .= "<TR><TH ALIGN=LEFT>Generic name of STS maps</TH>";
    $form .= "<TD COLSPAN=2><INPUT NAME='stsmapfile' SIZE=40 MAXSIZE=64 VALUE=''></TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>STS Tags (fas) data file</TH>";
    $form .= "<TD COLSPAN=2><INPUT NAME='stsfasfile' SIZE=40 MAXSIZE=64 VALUE=''></TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>STS Tags (epc) data file</TH>";
    $form .= "<TD COLSPAN=2><INPUT NAME='stsepcfile' SIZE=40 MAXSIZE=64 VALUE=''></TD></TR>";
    $form .= "<TR><TH ALIGN=LEFT>Check <INPUT type=checkbox name='update'> "; 
    $form .= "for update defaults  </TH>";
    $form .= "<TH ALIGN=LEFT>Check <INPUT type=checkbox name='fulltest'> "; 
    $form .= "for full test</TH>";
    $form .= "<TH ALIGN=LEFT>Check <INPUT type=checkbox name='cleanup'> "; 
    $form .= "for cleanup</TH></TR>";
    $form .= "</TABLE>";

    return $form;
}


sub physmapform {
    my $form;

    $form  = "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH 80%><TR>";
    $form .= "<TH ALIGN=LEFT>Generic name of Physical Maps</TH>";
    $form .= "<TD COLSPAN=1><INPUT NAME='physmapfile' SIZE=40 MAXSIZE=64 VALUE=''></TD>";
    $form .= "</TR><TR>";
    $form .= "<TD>&nbsp</TD><TH ALIGN=LEFT>Check  <INPUT type=checkbox name='addclone'> ";
    $form .= " to add clones to database</TH>";
    $form .= "</TR><TR>";
    $form .= "<TD>&nbsp</TD><TH ALIGN=LEFT>Check  <INPUT type=checkbox name='fulltest'> ";
    $form .= " for a full test</TH>";
    $form .= "</TR></TABLE>";

    return $form;
}

####################################### file parsers ##############################

sub parseSTSfile {

    my $filename = shift;
    my $tagEntry = shift;

# alocate an array for output if not already done so with input parameter

    undef my %output;
    $tagEntry = \%output if (!defined($tagEntry));
    
    undef my $report;

# open the file and parse the lot

    if (open (TAGFILE,"$filename")) {
        my $count = 0;
        undef my $line; my $onemore = 0;
        undef my ($tag, $assembly, $DNA, $length);
        while (defined($line = <TAGFILE>) || $onemore) {
            if ($DNA && ($onemore || $line =~ /([G\d+|P\w+]\.)/i)) {
    # if the tag name already appears as key hash signal a duplicate value
                if ($tagEntry->{$tag}) {
                    $report .= "Duplicate tag name $tag ignored on $filename<br>";
                }
            # data are not found for this tag: add to hashlist @$tagEntry
                else {
                    undef my %entry;           
                    $entry{name}  = $tag     ; $entry{sequence} = $DNA;
                    $entry{slength} = $length; $entry{assembly} = $assembly;
                    $entry{status} = 0; # newly added
                    $tagEntry->{$tag} = \%entry;
                    $count++;                   
                }
                last if ($onemore);        
            } 
        # parse input record
            if ($line =~ /\>([G|P]\w+)\.mal(\d+)/) {  # specific for Malaria tags
                $tag = $1; $assembly = $2; undef $DNA;
            }
            elsif ($line =~ /^\s*([acgtn]+)\s*$/i) { # continuous DNA
                $DNA .= $1; $length = length($DNA);
            }
            elsif ($line =~ /([G|P]\w+)\.mal(\d+)\s+([acgtn]+)\s+([acgtn]+)\s+(\d+)/i) {
                $tag = $1; $assembly = $2;
                $DNA = $3.' '.$4;
                $length = $5;
            }
	    else {
		print "ignored $line <br>";
            }
        # set onemore to force a final pass through the loop
            $onemore = 1 if (eof(TAGFILE)); 
        }
        $report .= "$count STS tags read from $filename\n";
    }
    else {
        $report .= "! STS tags file $filename cannot be opened: $!\n";
    }

    return $tagEntry,$report;
}

####################################### parseSTSmap ##############################

sub parseSTSmap {
# collect mapping data for tags appearing in $namehash
    my $filename = shift;
    my $namehash = shift; # hash of hashes with tag data in fas and epcr files
    my $newentry = shift;

# allocate space for output list

    undef my %newentry;
    $newentry = \%newentry if (!$newentry);

    undef my $report;

    open (FILE,"ls $filename |") || return $newentry,"! STS tags map file $filename cannot be opened: $!\n";

    my $file;
    while (defined($file=<FILE>) && open (MAPFILE,"$file")) {
        next if ($file =~ /old/i);
        my $count = 0;
        my $assembly = 0; # default unknown
        $assembly = $2 if ($file =~ /\/(\w+?)(\d+)\.stsmap/i);
        undef my $line; 
        undef my ($tag, $position, $linkage);
        while (defined($line = <MAPFILE>)) {
            next if ($line !~ /\S/);
        # process data in variables on reading a new identifier
            if ($line =~ /^\s*([\w|\.]+)\s+(\-?\d+[\.|\d]*)\s/) {
            # *.stsmap format
                $tag = $1; $position = $2; $linkage = 0;
                undef $position if ($position < 0);
            # test if the tag is in the master table
                if (!defined($namehash->{$tag})) {
                    $report .= "Tag $tag does not appear in the input list\n";
                }
            # test if the tag is in the master table by testing status
                elsif ($namehash->{$tag}->{status}) {
                    $report .= "Tag $tag is already loaded\n";
                }
            # test if the tag & position has been seen before
	        elsif (defined($namehash->{$tag}->{position})) {
	            $report .= "Duplicate tag $tag for assembly $assembly on $file ";
                    $report .= "previously seen in assembly $namehash->{$tag}->{assembly}\n";
	        }
            # okay, add the map data (to the other data for this tag)
	        else {
                    $namehash->{$tag}->{position} = $position if (defined($position));
                    $namehash->{$tag}->{linkage}  = $linkage;
                    $namehash->{$tag}->{assembly} = $assembly;
                    $namehash->{$tag}->{status}   = 2; # map added
                    $count++;
                }               
	    }
        # here possibly other format e.g. happy map files
            else {
                $line =~ s/\s+/ /g; # delete redundant blanks
                $report .= "Input not reckognized: $line\n";
            }            
        }
        $report .= "$count tag mappings read from $file\n";
    }

# return in $newentry the reference to the hash of taghashes encountered on $filename

    return $report;
}


####################################### parsePMfile ##############################

sub parsePMfile {
    my $filename = shift;
    my $newentry = shift;

    undef my @newentry;
    $newentry = \@newentry if (!$newentry);

    open (FILE,"ls $filename |") || return $newentry,"! Physical Map file $filename cannot be opened: $!\n";

    my $file;
    my $report = "<TABLE BORDER=0 CELLPADDING=2>";
    my $yel = "bgcolor='yellow'"; my $gre = "bgcolor='lightgreen'";
    while (defined($file=<FILE>) && open (MAPFILE,"$file")) {
        next if ($file =~ /old/i);
        chomp $file;
        undef my $ASSEMBLY;
        $ASSEMBLY = $1 if ($file =~ /\/(\w+?\d+)\.physmap/i);
        $report .= "<TR><TD $yel>! Assembly could not be determined from file name $file</TD></TR>" if !$ASSEMBLY;
        undef my $line; my $count = 0;
        undef my ($clone, $pstart, $pfinal,$assembly);
        while (defined($line = <MAPFILE>)) {
            next if ($line !~ /\S/);
        # process data in variables on reading a new identifier
            if ($line =~ /(\w+)\s+(\d+)\s+(\d+)\s/) {
                if (!$assembly) {
                    if ($ASSEMBLY) {
                        $assembly = uc($ASSEMBLY);
                        $report .= "<TR><TD $gre>! Assembly name $assembly taken from file name</TD></TR>";
                        undef my %entry;
                        $entry{assembly} = $assembly;
                        push @$newentry,\%entry;
                    }
                    else {
                        $report .= "<TR><TD $yel>! Unknown assembly name for file $file</TD></TR>";
                    }
                }
                undef my %entry;
                $entry{clonename} = $1;
                $entry{cpkbstart} = $2;
                $entry{cpkbfinal} = $3;
                $entry{assembly} = $assembly;
                if ($2 > 0 && $3 > 0) {
                    push @$newentry,\%entry;
                    $count++;
                }
            }
            elsif ($line =~ /(\w+?(\d+))\s+(\d+)\s?$/) {
                undef my %entry;
                $entry{assembly} = $1;
                $entry{fraction} = $2;
                $entry{size}     = $3;
                push @$newentry,\%entry;
                $assembly = $1;
            }
            else {
                $report .= "<TR><TD>Unrecognized input: $line</TD></TR>";
            }
	}
        $report .= "<TR><TD>$count clone positions found on file $file</TD></TR>";
    }

    $report .= "</TABLE>";

    return $newentry,$report;
}

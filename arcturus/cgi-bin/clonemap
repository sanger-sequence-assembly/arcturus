#!/usr/local/bin/perl -w

#############################################################################
# Upload Contigs into ARCTURUS database
#############################################################################

use strict;

use GateKeeper;

##############################################################################
# unbuffered output
##############################################################################

open(STDERR,">&STDOUT") || die "Can't dump to STDOUT: $!\n";
select(STDERR); $| = 1; # Make unbuffered.
select(STDOUT); $| = 1; # Make unbuffered.

##############################################################################
# get configuration data, open CGI and MySQL Database
##############################################################################

my $GateKeeper = GateKeeper->new('mysql');

my $config     = $GateKeeper->configHandle();

my $cgi        = $GateKeeper->cgiHandle(1);

my $origin = $GateKeeper->origin(2) || '';
my ($void, $database, $action) = split '/',$origin;

my $organisms  = $GateKeeper->dbHandle($database,{returnTableHandle => 1});

$GateKeeper->focus;

# this script may be run:
# (1) from the arcturus GUI under CGI
# (2) spawned from a script running under CGI
# (3) from the command line (at the moment no id check)
   
#$GateKeeper->cgiHeader(1) if ($cgi && !@ARGV); # return string plain
$GateKeeper->cgiHeader(1); # return string plain

##############################################################################
# MAIN
##############################################################################

my $USERSUPPORT = $config->get("USERSUPPORT");
my $db_manager  = $config->get("db_manager");      
my $arc_cgi_dir = $config->get('ARC_CGI_DIR');
my $arc_log_dir = $config->get('ARC_LOG_DIR');

my ($assembly, $assemblyname, $assemblynmbr);
my ($projects, $projectname, $projectnmbr);

#my ($brtag, $gfont, $yfont, $ofont, $rfont, $efont);
my $brtag = "\n"; # , $gfont, $yfont, $ofont, $rfont, $efont);

###############################################################################

# my $users = $organisms->spawn('USERS','arcturus',0,1);

###############################################################################
# open all database tables required
###############################################################################

my $rrtocc   = $organisms->spawn("READS2CONTIG",$database,0);
my $cctopp   = $organisms->spawn("CONTIGS2SCAFFOLD",$database,0);
my $cltocc   = $organisms->spawn("CLONES2CONTIG",$database,0);
#my $cltopp   = $organisms->spawn("CLONES2PROJECT",$database,0);

# get all current contigs

my $TEST = 1;

my @choices = ('N','C');
my $contigs = $cctopp->associate('contig_id',\@choices,'astatus');
print "query: $cctopp->{lastQuery} \n";

if (ref($contigs) ne 'ARRAY') {
    my @contigs;
    $contigs[0] = $contigs if $contigs;
    $contigs = \@contigs;
}

my $nc = @$contigs; print "$nc contigs found \n";

# go through all contigs and collect the clones

my $limit = 10;
foreach my $contig (@$contigs) {
# get the reads for this contig as hashes
    my $query = "contig_id = $contig and label >= 10";
    my $maps = $rrtocc->associate('hashrefs','where',$query,-1);
    if (ref($maps) ne 'ARRAY') {
        undef my @maps;
        $maps[0] = $maps;
        $maps = \@maps;
    }
    my $nmap = @$maps;
    print "$nmap reads-to-contig maps found for contig $contig\n";
# get the clones
    undef my %clones;
    foreach my $hash (@$maps) {
        $clones{$hash->{clone}}++;
    }
    my $nclone = keys %clones;
    print "Contig $contig: $nclone clones found in $nmap read maps\n" if $nmap;
# for each clone, get the reads and determine the range
    foreach my $clone (keys %clones) {
# determine the covering range of reads on the contig
        undef my $ccf;
        undef my $ccs;
        undef my $rlgt;
        undef my $nrds;
        foreach my $hash (@$maps) {
            if ($hash->{clone} eq $clone) {
                my $rs = $hash->{prstart};
                my $rf = $hash->{prfinal};
                my $cs = $hash->{pcstart};
                my $cf = $hash->{pcfinal};
                my $or = $hash->{label};
            # test ordering
                if (($or%2) && $cf > $cs) {
                    print "contig $contig: ordering error ";
                    print "(label $or  contig range $cs-$cf  read: $rs-$rf)\n"; 
                } 
                elsif (!($or%2) && $cs > $cf) {
                    print "contig $contig: ordering error ";
                    print "(label $or  contig range $cs-$cf  read: $rs-$rf)\n"; 
                }
                else {
#                    print "contig $contig: ordering okay\n";
# update begin and end of contig region
                    $nrds++; # number of reads
                    $rlgt += ($rf-$rs+1); # total read length covered
                    if ($or%2) {
                        $ccs = $cf if (!$ccs || $cf < $ccs); # counter aligned
                        $ccf = $cs if (!$ccf || $cs > $ccf);
                    }
                    else {
                        $ccs = $cs if (!$ccs || $cs < $ccs); # aligned
                        $ccf = $cf if (!$ccf || $cf > $ccf);
                    }
                }
            }
        }
# results
        my $cover = $rlgt/(abs($ccf-$ccs)+1);
        print "  clone $clone nreads=$nrds $rlgt contig $ccs-$ccf (cover=$cover)\n";
        my $status = 1;
        if (!$TEST && $cltocc->newrow('clone_id',$clone,'contig_id',$contig)) {
            $status = 0 if ($status && !$cltocc->update('ocp_start',$ccs));
            $status = 0 if ($status && !$cltocc->update('ocp_final',$ccf));
            $status = 0 if ($status && !$cltocc->update('reads',$nrds));
            $status = 0 if ($status && !$cltocc->update('cover',$cover));
        }
        elsif (!$TEST) {
            print "  Insert new row failed\n";
        }
    }
    last if !$limit--;
}

##############################################################################
# closing down
##############################################################################

print STDOUT "${brtag}Time stamping modified tables$brtag";

my $userid = $GateKeeper->currentUser;
$organisms->historyUpdate($userid,0,1); # history update 
$organisms->signature($userid,'dbasename',$database);

print STDOUT "${brtag}Closing database$brtag$brtag";
$GateKeeper->disconnect;
exit 0;













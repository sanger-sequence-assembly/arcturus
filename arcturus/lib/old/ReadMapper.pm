package ReadMapper;

#############################################################################
#
# map a READ onto a contig 
#
#############################################################################

use strict;

use Devel::MyTimer;

#############################################################################
# Global variables
#############################################################################

my %ReadMapper; # all readmapper instances on key readname

# declare database handles to READS, READS2CONTIG, READEDITS and PENDING table

my $READS; # READS database table handle
my $RR2CC; # READS2CONTIG
my $EDITS; # READEDITS
my $PENDS; # PENDING
my $RR2AA; # READS2ASSEMBLY

my $LIGATIONS; # handle autogenerated in testAttributes
my $SVECTORS;  # handle autogenerated in testAttributes
my $CVECTORS;  # handle autogenerated in testAttributes

my $DBS = 0; # default no database search if data not found in table caches

my $piecemealwise = 0; # default no tidy-up of mappings to earlier contigs

my %ligations; # hash for ligation values to be tested in READS repair mode

my $DEBUG = 0;
my $TIMER = 1;
my $MyTimer;


my $break;


#############################################################################
# constructor init: initialise the global (class) variables
#############################################################################

sub init {
# create a romp instance read object to facilitate access to class variables
    my $prototype = shift;
    my $tblhandle = shift;

    my $class = ref($prototype) || $prototype;
    my $self  = {};

# get table handles used in this module

    $READS = $tblhandle->spawn('READS');
    $RR2CC = $tblhandle->spawn('READS2CONTIG');
    $EDITS = $tblhandle->spawn('READEDITS');
    $PENDS = $tblhandle->spawn('PENDING');
    $RR2AA = $tblhandle->spawn('READS2ASSEMBLY');

    $break = &break; # output line break

    $MyTimer = new MyTimer;

    bless ($self, $class);

    return $self;
}


###############################################################################
# constructor new: create a handle to a stored read
###############################################################################

sub new {
# create an instance read object 
    my $prototype = shift;
    my $readname  = shift;

    my $class = ref($prototype) || $prototype;
# test if an exiting ReadMapper of this name exists
    return $ReadMapper{$readname} if $ReadMapper{$readname};

    my $self  = {};

    $self->{names}    = []; # read name, contig name (+history?)
    $self->{dbrefs}   = []; # database data read_id, pend_id, contig_id 
    $self->{edits}    = {}; # editing hash
    $self->{tags}     = []; # array of hashes for read tags

    $self->{read2pad} = {}; # mapping read (segment) to padded read
    $self->{padtocon} = []; # mapping padded read to contig
    $self->{read2con} = {}; # mapping read (segment) to contig
    $self->{contocon} = []; # for possible contig to contig alignment info

    $self->{counts}   = []; # counters
    $self->{marked}   = ''; # marker 'N' or 'M' for deprecation status
    $self->{series}   = []; # array with generations of mappings for this read
    $self->{status}   = {}; # error status report

    $self->{biology}  = {}; # hash for bio-info
    $self->{quality}  = []; # various quality boundaries
    $self->{clone}    =  0; # clone-id (re: contig map)

    $self->{report}   = ''; # extended reporting

# store the name of this read in the instance variable
 
    my $names  = $self->{names};
    $names->[0] = $readname;

# set the references to the ARCTURUS database to 0

    my $dbrefs = $self->{dbrefs};
    @$dbrefs = (0,0,0,0);

# initialize counts

    my $counts = $self->{counts};
    @$counts = (0,0,0,0,0,-1,-1);

# initialize error status

    my $status = $self->{status};
    $status->{errors}   = 0;
    $status->{inerrors} = 0;
    $status->{warnings} = 0;
    $status->{inputlog} = '';

# add the name of this read to the class variable %ReadMapper

    $ReadMapper{$readname} = $self;

    bless ($self, $class);
    return $self;
}

###############################################################################

sub setPMWise {
    my $self = shift;
    my $pmw  = shift;

    $piecemealwise = $pmw;
}

###############################################################################

sub onCompletion {
# to be run after all data for this read have been collected e.g. read from CAF
    my $self   = shift;
    my $test   = shift;
    my $repair = shift;

    &quality($self,0,0,-1); # (final) update quality range

    &testAttributes($self,$repair) if ($test || $repair); # optional repair of READS info
}

###############################################################################

sub setAttribute {

    my $self  = shift;
    my $item  = shift;
    my $value = shift;
    my $list  = shift;

    return if (!$item || !defined($value));

    if ($self->{biology}->{$item} && $self->{biology}->{$item} ne $value) {

        if ($list) {
            print STDOUT "!Read $self->{names}->[0]: Inconsistent ";
            print STDOUT "attribute $item: new value $value against ";
            print STDOUT "previously found $self->{biology}->{$item}$break";
        }
    }
    else {
        $self->{biology}->{$item} = $value;
    }
}

###############################################################################

sub testAttributes {
# test attribute e.g. ligation/clone/vectors against read data; repair if possible
    my $self     = shift;
    my $repair   = shift;

    my $report = '';
    if (my $read_id = $self->isInDataBase(1,0)) {

# get data from READS for this read

        my $query = "select ligation,svector,cvector,clone from <self> where read_id=$read_id";
        my $hashrefs = $READS->query($query,0,0);
        return 0 if !$hashrefs; # protection

        my $biology = $self->{biology};

# sequence vector

        my $svector = $biology->{svector}; # name read from e.g. caf file
        $svector = 0  if ($svector && $svector =~ /unknown/i);
        if ($svector && !$hashrefs->[0]->{svector}) {
            $report .=  "Attempt to repair missing Sequence Vector for read $read_id (set to $svector)$break"; 
            undef my $error;
            $SVECTORS = $READS->spawn('SEQUENCEVECTORS') if !$SVECTORS;
            $SVECTORS->build(1) if !$SVECTORS->associate('hashrefs'); # just to be sure
            if ($repair && $SVECTORS) {
                $SVECTORS->counter('name',$svector,1);
	        $svector = $SVECTORS->associate('svector',$svector,'name');                
                $READS->update('svector',$svector,'read_id',$read_id) if  $svector;
                $error = "failure to update table SEQUENCEVECTORS"    if !$svector;
            }
            elsif ($repair) {
                $error = "missing instance of table SEQUENCEVECTORS";
            }
            $report .= "! Could not repair 'svector' for read $read_id: $error" if $error;
        }
        elsif ($repair && $repair > 1 && $svector) {
    # full repair mode, replacing incorrect data, to be developed
        }

# cloning vector
        
        my $cvector = $biology->{cvector};
        $cvector = 0  if ($cvector && $cvector =~ /unknown/i);
        if ($cvector && !$hashrefs->[0]->{cvector}) {
            $report .=  "Attempt to repair missing Cloning Vector for read $read_id (set to $cvector)$break"; 
            undef my $error;
            $CVECTORS = $READS->spawn('CLONINGVECTORS') if !$CVECTORS;
            $CVECTORS->build(1) if !$CVECTORS->associate('hashrefs'); # just to be sure
            if ($repair && $CVECTORS) {
                $CVECTORS->counter('name',$cvector,1);
	        $cvector = $CVECTORS->associate('cvector',$cvector,'name');
                $READS->update('cvector',$cvector,'read_id',$read_id) if $cvector;
                $error = "failure to update table CLONINGVECTORS"    if !$cvector;
            }
            elsif ($repair) {
                $error = "missing instance of table CLONINGVECTORS";
            }
            $report .= "! Could not repair 'cvector' for read $read_id: $error $break" if $error;
        }
        elsif ($repair && $repair > 1 && $svector) {
    # full repair mode, replacing incorrect data, to be developed
        }

# ligations
# print "$break repair LIGATIONS ($report) $break";

        $LIGATIONS = $READS->spawn('LIGATIONS') if !$LIGATIONS;
        if (keys %ligations == 0 && $LIGATIONS) {
            $LIGATIONS->build(1) if !$LIGATIONS->associate('hashrefs'); # just to be sure
            if (my $hashrefs = $LIGATIONS->associate('hashrefs')) {
                foreach my $hash (@$hashrefs) { # select undefined ligations
                    $ligations{$hash->{ligation}} = $hash if ($hash->{identifier} =~ /^(U\d+|99999)$/);
                }
            }
            $ligations{00} = 0 if (keys %ligations == 0); # add dummy 
        }
        
        my $identifier = $biology->{ligation}; # as read from e.g. caf file
        if ($identifier && $identifier ne '99999') {
            undef my $error;
            if ($repair && (my $hash = $ligations{$hashrefs->[0]->{ligation}})) {
	        print "read $read_id $hashrefs->[0]->{ligation}$break";
# okay, this read has an undefined or incomplete ligation referenced in READS
                $SVECTORS = $READS->spawn('SEQUENCEVECTORS') if !$SVECTORS;
                $SVECTORS->build(1) if !$SVECTORS->associate('hashrefs'); # just to be sure
                $report .= "Attempt to repair ligation $hashrefs->[0]->{ligation} ($hash->{identifier}) ";
                $report .= "with $identifier for read $read_id (read clone $hashrefs->[0]->{clone})$break"; 
                if (my $status = $LIGATIONS->counter('identifier',$identifier,1)) {
                    my $ligation = $LIGATIONS->associate('ligation',$identifier,'identifier');
                    if ($status == 2) {
                        $LIGATIONS->update('silow',$biology->{silow})  if defined($biology->{silow});
                        $LIGATIONS->update('silow',$biology->{sihigh}) if defined($biology->{sihigh});                                    $LIGATIONS->update('clone',$biology->{clone})  if defined($biology->{clone});             
                        $svector = $SVECTORS->associate('svector',$svector,'name') if $svector;
                        $LIGATIONS->update('svector',$svector) if $svector;
# print "NEW LIGATION $ligation:"; foreach my $key (keys %$biology) { print " $key $biology->{$key}"; } print "$break";
                        $LIGATIONS->update('origin' , 'C');
                    }
# replace ligation in read, update counter table for old ligation (check clone id)
                    $READS->update('ligation',$ligation,'read_id',$read_id);
                    $LIGATIONS->counter('ligation',$hashrefs->[0]->{ligation},-1);
                }
                else {
#                    $LIGATIONS->rollback();
                    print "Failed to add a new line to LIGATIONS$break";
                }
            }
            elsif ($ligations{$hashrefs->[0]->{ligation}}) {
                $report .= "Undefined ligation in read $read_id to be replaced by $identifier $break";
            }
            $report .= "! Could not repair 'ligations' for read $read_id: $error" if $error;
        }
    }
    return $report;
}

###############################################################################
# The next 4 subs define the mapping of the current read
###############################################################################

sub edit {
# load edits for this read: store an edit instruction in the 'edits' hash
    my $self = shift;
    my $base = shift;
    my $edit = shift;
  
    my $edits  = $self->{edits};
    my $counts = $self->{counts};

    $edit = ' '.$edit  if (length($edit) == 1); # prepend single char with blank
    if (defined($edits->{base}) && length($edits->{$base}) > 2) {
        print "too many edits on base $base in $self->{names}->[0]: old '$edits->{$base}' new '$edit'$break";
    }
    else {
        $counts->[0]++ if !$edits->{$base};
        $edits->{$base} .= $edit;
    }

#print "edit $self->{names}->[0]: base $base  edit $edit count $counts->[0] '$edits->{$base}'$break"  if ($self->{names}->[0] eq 'mal4U12g9.p1t');
}

###############################################################################

sub alignToCaf {
# load caf alignment(s) for this read
    my $self  = shift;
    my $block = shift; # input array of length 4 with mapped positions

# @$block: [0] padded start; [1] pfinal ; [2] read start; [3] rfinal 

    my $read2pad = $self->{read2pad};
    my $counts   = $self->{counts};
    my $status   = $self->{status};
    my $quality  = $self->{quality}; # default quality range

    my $report = "alignToCaf input: @$block$break";

# test the input information: sections must be equal length and direction

    undef my $error;
    if (@$block == 4) {
    # test length and orientation of alignments
        my $rlgt = $block->[1] - $block->[0];
        my $clgt = $block->[3] - $block->[2];
        if ($rlgt == 0 && $block->[0] == 0) {
            $error = "zero length block specification";
        } 
        elsif ($rlgt != $clgt) {
            $error = "block length/orientation mismatch ($rlgt<>$clgt)";
        } 
        else {
# get the hash value (string!) for this alignment ('999999' used as terminator)
            $counts->[1]++; # it's the next alignment
            my $hash = sprintf ("%06d",$counts->[1]);
# my $hash = "00000$counts->[1])";
# $hash =~ s/.*(\d{6})$/$1/;         
            @{$read2pad->{$hash}} = @$block;
            my $next = @$quality || 0;
            my $default = $quality->[$next];
            $default->[0] = $block->[2] if (!$default->[0] || $block->[2] < $default->[0]);
            $default->[1] = $block->[3] if (!$default->[1] || $block->[3] > $default->[1]);
            $default->[2] = 1; # overall window
        }
    } 
    else {
        $error = "incomplete alignToCaf data";
    }

# test error reporting

    if ($error) {
        $status->{inerrors}++;
        $status->{inputlog} .= "! Invalid mapping info: @{$block} : $error$break";
        $report .= "alignToCaf error: $error$break";
    }

    $self->{report} .= $report;
}

################################################################################

sub alignToContig {
# load contig alignment (should be only one!) for this read (after padding)
    my $self     = shift;
    my $block    = shift; # input array of length 4 with mapped positions

# block[0] = begin on contig, [1] end; block[2] = begin on SCF (tracefile), [3] end

    my $padtocon = $self->{padtocon};
    my $counts   = $self->{counts};
    my $status   = $self->{status};

# test the input: sections must be equal length but may have opposite direction

    my $report = "alignToContig input: @$block$break";

    my $error;
    if (@$block == 4) {
    # test length and orientation of alignment
        my $clength = $block->[1] - $block->[0];
        my $rlength = $block->[3] - $block->[2];

        if ($rlength != -$clength && $rlength != $clength) {
            $error = "block length mismatch ($rlength<>$clength)";
        } 
        else {
            @$padtocon = @$block;
            $counts->[2] = 1; # signal alignment as defined
        # determine alignment direction
            $self->{align} = 0; # default co-aligned
            $self->{align}++ if ($rlength == -$clength);
        }
    } 
    else {
        $error = "missing data (block @{$block})$break";
    }

# test error status

    if ($error) {
        $status->{inerrors}++;
        $status->{inputlog} .= "! Invalid align to contig: @{$block} : $error$break";
        $report .= "alignToContig error: $error$break";
        undef @$padtocon;
    }

    $self->{report} .= $report;
}

################################################################################

sub quality {
# define quality range (for independent check)
    my $self = shift;
    my $ql   = shift;
    my $qr   = shift;
    my $type = shift; # 0 for quality, 1 enabling window, 2 blocking window

    my $counts  = $self->{counts};
    my $status  = $self->{status};
    my $quality = $self->{quality};

# load range in internal storage.

    if ($type == 0 && $ql > 0 && $ql <= $qr) {
        $counts->[3] = $ql;
        $counts->[4] = $qr;
    }
    elsif ($type == 0) {
        $status->{inerrors}++;
        $status->{inputlog} .= "! Invalid quality range data: $ql $qr$break";
    }
    elsif ($type > 0) {
        my $next = @$quality || 0;
        $quality->[$next]->[0] = $ql;
        $quality->[$next]->[1] = $qr;
        $quality->[$next]->[2] = $type;
    }

# analyse the stored info ($type < 0 effective only if no quality range defined

# my $list = 0; $list = 1 if ($self->{names}->[0] eq 'J773Ca4.q2t');

    if (($counts->[3] <= 0 || $counts->[4] <= 0) && $type < 0) {
# use enabling window only if quality window absent
#print "quality test: counts @$counts $break" if $list;
        foreach my $window (@$quality) {
#print "quality test: window @$window $break" if $list;
	    if ($window->[2] == 1) { 
                $counts->[3] = $window->[0] if (!$counts->[3] || $counts->[3] < $window->[0]);
                $counts->[4] = $window->[1] if (!$counts->[4] || $counts->[4] > $window->[1]);
            }
        }
#print "after test: counts @$counts $break" if $list;
    }

# filter through masking ranges once initial estimate is made

    if ($counts->[3] > 0 && $counts->[4] > 0) {
        foreach my $window (@$quality) {
	    if ($window->[2] >= 2) { # blocking window
                if ($window->[0] <= $counts->[3] && $window->[1] >= $counts->[3]) {
                    $counts->[3] = $window->[1] + 1;
                }
                if ($window->[0] <= $counts->[4] && $window->[1] >= $counts->[4]) {
                    $counts->[4] = $window->[0] - 1;
                }
            }
        }
    }
}

################################################################################

sub addTag {
# store all tags encountered in this read in an array of hashes
    my $self  = shift;
    my $name  = shift; 
    my $sbase = shift;
    my $fbase = shift;
    my $info  = shift;

    my $status = $self->{status};
    my $rdtags = $self->{tags};

    undef my %newtag;
    $newtag{tagname}  = $name;
    $newtag{trpstart} = $sbase;
    $newtag{trpfinal} = $fbase;
    $newtag{taglabel} = $info;
    push @$rdtags, \%newtag;

    return @$rdtags+0;
}

################################################################################

sub etest {
# test/compare current edits with any existing previous edits (after isInDataBase)
    my $self = shift;

    undef my %oedits; # old edits

    my $nedits = $self->{edits}; # newedits
    my $counts = $self->{counts};
    my $status = $self->{status};
    my $result = $status->{errors};

# if counts[5] >= 0 this test has already been done 

    my $report = "++++ ReadMapper $self->{names}->[0] etest: @$counts $break";

    my $read_id = $self->isInDataBase(0,0);

    if ($read_id && $counts->[5] < 0) {

# find any existing edit instructions for this read in the database
# if there is, compare stored one with current one; deprecate if different

        $MyTimer->timer('etest',0) if $TIMER; 

        $counts->[5] = 0;
        my $edits = $EDITS->cacheRecall($read_id); # look in cached data first
        $edits = $EDITS->associate ('hashrefs',$read_id,'read_id') if ($DBS && !$edits);
# edits is now a reference to an array of hashes with edit information
        if (ref($edits) eq 'ARRAY' && @$edits) {
            foreach my $edithash (@$edits) {
                $report .= "ReadMapper edit:$edithash->{base} $edithash->{'edit'} $edithash->{deprecated}$break";
                if ($edithash->{deprecated} ne 'Y') {
                    my $base = $edithash->{base};
                    $oedits{$base} = $edithash->{'edit'};
                    $counts->[5]++;
		}
            }

# compare stored edits with new specification

            my $isDifferent = 0;
            foreach my $base (keys (%oedits)) {
                my $edit = $nedits->{$base};
                $edit = "Not Defined" if (!defined($nedits->{$base}));
                if (defined($oedits{$base}) && 
                (!defined($nedits->{$base}) || $oedits{$base} ne $nedits->{$base})) {
                    $isDifferent++;
                    $status->{warnings}++;
                    $status->{diagnosis} .= "! Inconsistent edit base $base: ";
                    $status->{diagnosis} .= " old=$oedits{$base} new=$edit$break";
	        }
	    }
            foreach my $base (keys (%$nedits)) {
                if (!defined($oedits{$base})) {
                    $isDifferent++;
                    $status->{warnings}++;
                    $status->{diagnosis} .= "! Inconsistent edit base $base: ";
                    $status->{diagnosis} .= "newly defined edit=$nedits->{$base}$break";                    
		}
            }


            if ($counts->[0] != $counts->[5]) {
                $isDifferent = 99;
                $status->{warnings}++;
                $status->{diagnosis} .= "! Inconsistent number of edits: ";
                $status->{diagnosis} .= "old=$counts->[5] new=$counts->[0]$break";
            }
        # now deprecate the old edits if different from current lot
            if ($isDifferent) {
                $status->{diagnosis} .= "! Previous edits for read $read_id are to be deprecated$break";
                $counts->[5] = 0;
            }
            else {
                $status->{diagnosis} .= "  Edits for $read_id already in database$break";
            }
            print "$status->{diagnosis} $break" if $DEBUG;
	}
        $MyTimer->timer('etest',1) if $TIMER; 
    }

    elsif (!$read_id) {
        $status->{diagnosis} .= "! Read $read_id not found in READS database$break";
        $status->{errors}++;
    }

    return $counts->[5];
}

# output $counts->[5] is either 0 if no edits are found in database or previous
# edits have been deprecated, or > 0 if edits are already stored in database,
# or < 0 if the read has not been found in the READS database

################################################################################
# mtest: test mappings and compare with any existing mappings in earlier
#        generations;
################################################################################

sub mtest {
# test/compare currrent mappings with any existing previous mappings 
    my $self = shift;
    my $list = shift; # for test purposes

    undef my %oldmaps;

    my $read2con = $self->{read2con}; # hash reference to (new) read-to-contig alignment
    my $con2con  = $self->{contocon}; # hash reference to contig-to-contig alignments
    my $dbrefs   = $self->{dbrefs};
    my $counts   = $self->{counts};
    my $status   = $self->{status};
    my $gen      = $self->{series};

# if counts[6] >= 0 this test has already been done 

    my $read_id = $self->isInDataBase(0,0);

    my $REPORT = "${break}++++ MTEST for ReadMapper $self->{names}->[0] ($read_id) @$counts ++++$break";

    if ($read_id && $counts->[6] < 0) {

        $MyTimer->timer('mtest',0) if $TIMER;

        my @read2conKeys = sort keys %$read2con;

        my %generations;
        my %deprecation;
        my %cgeneration;
        my $notDeprecated; # protect against case of only deprecated alignments
        $counts->[6] = 0;
        $dbrefs->[3] = 0; # for contig in previous generation
        @$con2con = (0,0,0,0,0,0); # have all elements defined
        my $previous = ''; # for string list of earlier contigs
        my $isDifferent = 0;

# find any existing mappings for this read in the database (first try cached data)

        my $dbmaps = $RR2CC->cacheRecall($read_id);
        $dbmaps = $RR2CC->associate ('hashrefs',$read_id,'read_id',-1,'deprecated,label') if ($DBS && !$dbmaps); 
# dbmaps is a reference to an array of hashes with existing mapping info in the database
        if (ref($dbmaps) eq 'ARRAY' && @$dbmaps > 0) {
# there are mappings of this read in the database; make an inventory for each generation
            $notDeprecated = 0;
            foreach my $map (@$dbmaps) {
                my $generation = $map->{generation};
                my $deprecated = $map->{deprecated};
                if ($deprecated ne 'Y') {
                    $generations{$generation}++;
                    $cgeneration{$generation} = $map->{contig_id};
                    $deprecation{$generation} = $deprecated;
                    $notDeprecated++; # there is at least one map
                }
                $REPORT .= "mapping: generation $generation deprecation $deprecated $break";
            }
        }

# if there is, compare stored map with new one; deprecate if different

        if ($notDeprecated && @$dbmaps > 0) {
    # get lastly loaded previous generation (could be 0)
            @$gen = sort keys %generations;
            $dbrefs->[3] = $cgeneration{$gen->[0]}; # the most recent generation number
            $REPORT .= "Generations counted: @$gen; last linking contig=$dbrefs->[3]$break";
    # get deprecation profile over generations
            my $deprecation;
            foreach my $generation (@$gen) {
                $deprecation .= $deprecation{$generation};
            }
            $REPORT .= "Deprecation profile: $deprecation $break";

    # test this generation inventory: there are only three combinations allowed
    # - there is only 1 generation = 0 or 1: only 'N' allowed (because it must be the first 
    #    occurance of this read in any contig); if G=0, the read has been processed earlier
    # - there are two generations: either 0 and 1 or 1 and n; in both cases 'MN' is required
    # - there are three generations, 0, 1 and n where 'MMN' is required
    # any other combination indicates a corrupted structure of the mapping table

            undef my $error;
            if (@$gen == 1 && ($gen->[0] > 1 || $deprecation ne 'N')) {
                $error .= "assignment status $deprecation (must be N) " if ($deprecation ne 'N');
                $error .= "first generation = @$gen (should be 0 or 1)" if ($gen->[0] > 1);
        # repair generation not necessary (filling in generation 1 not meaningful)
        # repair deprecation: set flag to 'N' on mappings not equal 'Y'
                my $where = "read_id = $read_id AND generation = $gen->[0] AND deprecated != 'Y'";
                $RR2CC->update('deprecated','N','where',$where);
            }
            elsif (@$gen == 2 && (($gen->[1] != 1 && $gen->[0] != 1) || $deprecation ne 'MN')) {
                $error .= "deprecation sequence $deprecation (should be MN)" if ($deprecation ne 'MN');
                $error .= "generation sequence @$gen (0 1 or 1 n)" if ($gen->[1] != 1 && $gen->[0] != 1);
        # possible repair on generations: delete the generation between 1 and n (will be done by reaper)
        # possible repair on deprecation: NN to NY (to be implemented) 
            }
            elsif (@$gen == 3 && ($gen->[1] != 1 || $deprecation ne 'MMN')) {
                $error .= "deprecation sequence $deprecation (must be MMN)" if ($deprecation ne 'MMN');
                $error .= "generation sequence @$gen (0 1 n)" if ($gen->[1] != 1);
        # possible repair on generations: delete the generation between 1 and n (will be done by reaper)
        # possible repair on deprecation: MNN to MNY, NNN & NMN to NYY(to be implemented)
             }
            elsif (@$gen > 3) {
                $error .= "Too many mapping generations @$gen$break";
        # possible repair to generations: delete the generation between 1 and n (will be done by reaper)
        # possible repair to deprecation: MMMN will be done by reaper, M..N..N to M..NYYY
            }
        # none of the above errors is fatal (reaper will sort out repair)
            $REPORT .= "Errors in mappings of this read $read_id: $error$break$break" if $error;
            $REPORT .= "No errors detected$break" if !$error;                
       

    # now collect the mapping profile for each generation and all contigs referred to by this read
    # store the maps of the last previous occurrence of this read in @crange (i.e. generation 1)

            undef my %profile;
            foreach my $map (@$dbmaps) {
                my @lastmap;
                my $label = $map->{label};
                my $deprecated = $map->{deprecated};
                my $generation = $map->{generation};
            # memorize the last previous mapping: should be generation 1 or possibly 0 for a new one
                my $consider = 0;
                $consider = 1 if ($generation == 1);
                $consider = 1 if (@$gen == 1 && $generation == 0);
                if ($consider && $deprecated ne 'Y' && $label <= 11) {
                    $lastmap[0] = $map->{prstart};
                    $lastmap[1] = $map->{prfinal};
                    $lastmap[2] = $map->{pcstart};
                    $lastmap[3] = $map->{pcfinal};
                    @{$oldmaps{$map}} = @lastmap;
            # get range on contig; $m ensures ascending order comparison
                    my $segment = $lastmap[3] - $lastmap[2];
                    my $m = 2; $m = 3 if ($segment < 0); # $m measures alignment inversion
                    $con2con->[0] = $lastmap[$m]   if (!$counts->[6] || $lastmap[$m]   < $con2con->[0]);
                    $con2con->[1] = $lastmap[5-$m] if (!$counts->[6] || $lastmap[5-$m] > $con2con->[1]);
                    if ($con2con->[2] && ($con2con->[2] != $m) && $segment) {
                        $status->{diagnosis} .= "! Inconsistent alignment orientation$break";
                        $status->{errors}++;
                        $isDifferent++; 
                    }
                    elsif ($segment) {
                        $con2con->[2] = $m; # temporary storage; left 0 if only single base segments
                    }
                    $counts->[6]++;
                }
                my $contig = $map->{contig_id};
                if ($label >= 10) {
                    my $status = 'S'; # 'Single' record (stored in lastmap hash)
                    $status = 'F' if ($label > 11); # 'Final' record (not stored in lastmap hash)
                    $status = lc($status) if ($deprecated eq 'Y');
                    $deprecated = $status;
                }
                $profile{$contig} .= $deprecated;
            }

    # test the alignment profiles for the read segments in each generation

            foreach my $contig (keys %profile) {
                undef my $report;
                $previous .= ' ' if $previous;
                $previous .= $contig; 
    # test contig for consistence: should be either 'YYYYf', 's', 'NNNNF','MMMMF' or 'S'
    # cleanup deprecated mappings in same generation alongside active mappings
                my $mapping = $profile{$contig};
                if ($mapping =~ /[MNS]/ && $mapping =~ s/[Yfs]//g) {
                    $status->{diagnosis} .= "! Redundant deprecated mappings from contig ";
                    $status->{diagnosis} .= "$contig to read $read_id (to be) removed$break";
                    my $maps = "read_id=$read_id and contig_id=$contig and generation=0 and deprecated='Y'";
                    $RR2CC->delete('where',$maps);
                }

                if ($mapping =~ /^(Y{2,}f|s)$/) {
                    $report .= "Deprecated mapping of read $read_id ";
                } 
                elsif ($mapping =~ /^([NM]{2,}F|S)$/) {
                    $report .= "Standard mapping of read $read_id ";
                }
                else {
                    $report .= "Incomplete or inconsistent mapping of read $read_id ";
                    $isDifferent = 1; # force deprecation of all current mappings
                }
                $REPORT .= "$report ($mapping) to contig $contig$break";
	    }
	}
        elsif (@read2conKeys > 0) {
#        elsif (keys %$read2con > 0) {
             $isDifferent = 1; # It's the first mapping of this read: force 'N' label
        }

# compare previously stored map with new specification (if any; should be identical apart from shift)

        $REPORT .= "intermediate ReadMapper status: isDifferent=$isDifferent previous=$previous$break";

        if ($counts->[6]) {

	    $REPORT .= "Testing existing ($counts->[6]) alignments against $counts->[1] new ones $break";

            if ($counts->[1] > 0) {
        # test the previous alignments against the current data 
                my $m = $con2con->[2];
        # get range for current (new) readmap to the new contig
                my $first = 1;
                $con2con->[4] = 0;
                my $alignments = 0;
                foreach my $alignment (@read2conKeys) {
#                foreach my $alignment (keys (%$read2con)) {
                    my @thismap = @{$read2con->{$alignment}};
                    my $segment = $thismap[3] - $thismap[2];
                    my $l = 2; $l = 3 if ($segment < 0);
                    $con2con->[2] = $thismap[$l]   if ($first || $thismap[$l]   < $con2con->[2]);
                    $con2con->[3] = $thismap[5-$l] if ($first || $thismap[5-$l] > $con2con->[3]);
                    $con2con->[4] = 1 if ($segment && $l != $m); # signal alignment inversion to ContigBuilder
                    $alignments++; # total of padded alignments
                    $first = 0;
                }
                $REPORT .= "! $con2con->[4] alignment inversion(s) detected$break" if $con2con->[4];

                my $oldrange = $con2con->[1] - $con2con->[0];
                my $newrange = $con2con->[3] - $con2con->[2];

                $REPORT .= "ReadMapper read nr $dbrefs->[0] aligned to previous contig(s): $previous$break";
                if ($alignments == $counts->[6] && $oldrange == $newrange) {
        # numbers and overall range are identical; now test each individual mapping segment
                    undef my $offset;
                    foreach my $alignment (@read2conKeys) {
#                    foreach my $alignment (keys (%$read2con)) {
        # get range for current (new) readmap to the new contig
                        my @thismap = @{$read2con->{$alignment}};
                        $REPORT .= "Testing alignment @thismap$break";
                        my $found = 0; 
                        my $error = 0;
                # find the matching alignment on the read in previous map, then compare contig alignments 
                        foreach my $map (keys (%oldmaps)) {
                            my @lastmap = @{$oldmaps{$map}};
                            if ($lastmap[0] == $thismap[0] && $lastmap[1] == $thismap[1]) {
                                $found++; # there should be only one alignment
                # get the "shift" between the contig maps; if inverted, use mirror image
                                if ($con2con->[4]) {
                                    $lastmap[2] = -$lastmap[2];
                                    $lastmap[3] = -$lastmap[3];
print "reversal detected in  read nr $dbrefs->[0] $break";
                                }
                # the offset between the maps should be identical for all mapped read segments
                                my $shift = $thismap[2] - $lastmap[2];
                                $offset = $shift if !defined($offset);
                                $error = $map if ($shift != $offset);
                                $shift = $thismap[3] - $lastmap[3];
                                $error = $map if ($shift != $offset);

                                $REPORT .= "old alignment: @{lastmap}$break";
                                $REPORT .= "new alignment: @{thismap}$break";
                            }
			}

                        if ($error) {                     
                # the mapping range does not match
                            $isDifferent++;
                            $REPORT .= "! Inconsistent alignment, ";
                            $REPORT .= "old: @{$oldmaps{$error}}, new: @{thismap}$break";
 	                } 
                        elsif ($found == 0) {
                # no matching alignment found; update contig ranges
                            $isDifferent++;
                            $REPORT .= "! Alignment @{thismap} not matched$break";
                        }
                        elsif ($found > 1) {
                            $isDifferent++;
                            $REPORT .= "! Multiple alignments ($found) for @{thismap}$break";
                        }
         	    }
                    $con2con->[5] = $offset; # register shift between contigs
                }
  	        elsif ($counts->[1] != $counts->[6]) {
        # the maps are different in number of alignments and possibly in total range covered
                    $status->{warnings}++;
                    $REPORT .= "! Inconsistent number of alignments: in database ";
                    $REPORT .= "$counts->[6] new: $counts->[1]$break";
                    $isDifferent = 99;
                }
                else {
        # the maps are different in total range covered
                    $isDifferent = 99;
                }
            } 
            else {
            #  there is no current (new) mapping info ($counts->[1]=0)
                $status->{errors}++;
                $REPORT .= "There is mapping info in database but no new info$break";
                $isDifferent = 99;
            }
        }

        $REPORT .= "intermediate ReadMapper status: isDifferent=$isDifferent previous=$previous$break";

    # now deprecate the old mappings if they are different from current ones

        my $report;
        if ($isDifferent && $previous) {
    # the alignments to a previous contig are different from those 
    # to the new contig; old alignments have to be superseded
            &deprecate($self);
            $report .= " New alignments of this read $dbrefs->[0] to the new contig:";
            $report .= " $con2con->[0]-$con2con->[1] to $con2con->[2]-$con2con->[3] $break";
            $con2con->[4] += 2; # signal deprecated readmap to ContigBuilder
        }
        elsif ($isDifferent && !$previous) {
    # this alignment has not been seen before
            $report = " First time assembly of read $dbrefs->[0] $break";
            $self->{marked} = 'N';
            $counts->[6] = 0;
        }
        elsif (@read2conKeys) {
#        elsif (keys %$read2con) {
    # the alignments to the previous contig are identical to those to the new
    # contig, apart from a (possible) shift;
            $report = "Alignments are identical to those to a contig in generation $gen->[0]$break";   
            $self->{marked} = 'M' if ($gen->[0]  > 0); # mark for delete by reaper
            $self->{marked} = 'X' if ($gen->[0] == 0); # mark as already stored for new generation
        }
        else {
    # the read is completely empty (after alignment)
            &deprecate($self) if $counts->[6]; # deprecate existing data
            $con2con->[4] = -1; # signal empty mapping to ContigBuilder
        }
        $status->{diagnosis} .= $report if $report;

$REPORT .= "$report$break" if $report;
$self->{report} .= $REPORT;
&reporter($self,0) if ($isDifferent && $previous); # TEMPORARY TEST
        $MyTimer->timer('mtest',1) if $TIMER;
    }
    elsif (!$read_id) {
        $status->{diagnosis} .= "! Read $read_id not found in READS database$break";
        $status->{errors}++;
    }

    return $counts->[6];
}

# output $counts->[6] is either 0 if no alignment data are found in database or
# if previous alignment data have been deprecated, or > 0 if alignments are 
# already stored in database (in which case $dbrefs->[3] has the contig_id in which
# it first occurred), or < 0 if the read has not been found in the READS database

################################################################################

sub deprecate {
    my $self = shift;
    my $text = shift;

    my $counts = $self->{counts};
    my $status = $self->{status};
    my $update = 0;

    if (my $read_id = $self->isInDataBase(0,0)) {

# deprecate alignments to contigs of previous generations; only first ('N')
# suffices because mappings marked 'M' will be removed with &reaper afterwards

        return if ($self->{marked} eq 'N'); # already done previously

        $RR2CC->update('deprecated','Y','where',"read_id = $read_id AND deprecated = 'N'");

        $status->{diagnosis} .= "! Previously archived alignments for read $read_id are deprecated";
        $status->{diagnosis} .= " ($text)" if $text;
        $status->{diagnosis} .= "$break"; 
        $status->{warnings}++;

# signal no (valid) data in database 

        $self->{marked} = 'N'; # treat as new read appearing for the first time
        $counts->[6] = 0;      # will suppress repeat of test and force dump
        $update++;
    }
    elsif (!$read_id) {
        $status->{diagnosis} .= "! Read $read_id not found in READS database$break";
        $status->{errors}++;
    }

    return $update;
}

################################################################################

sub reporter {
    my $self = shift;
    my $home = shift;

    my $report = $self->{report};
    if ($report || $home) {
        print STDOUT "${break}REPORTER";
        print STDOUT " (Origin $home)" if defined($home);
        print STDOUT "$break$report$break" if $report;
    }
}

################################################################################
# This sub dumps the current mappings to database tables (after testing)
################################################################################

sub dump {
# dump edits and mapping in database tables READEDITS and READS2CONTIG
    my $self     = shift;
    my $contig   = shift; # contig ID obtained in ContigBuilder
    my $assembly = shift; # assembly number of the contig

# edit and mapping data can only be dumped if read is in READS and contig exists

    my $dbrefs   = $self->{dbrefs};
    my $status   = $self->{status};
    my $counts   = $self->{counts};
    my $read2con = $self->{read2con};
    my $edits    = $self->{edits};
    my $names    = $self->{names};
    my $marker   = $self->{marked};

$DEBUG = 0; # $DEBUG=1 if ($self->{names}->[0] =~ /mal4N18g10\.p2co17frA/);
print "++++ DUMP for ReadMapper $self->{names}->[0] ($self) counts: @$counts ++++$break" if $DEBUG;

    $MyTimer->timer('RM dump',0) if $TIMER; 

# reinitialize error status

    $status->{errors}    = $status->{inerrors};
    $status->{diagnosis} = $status->{inputlog};
    $status->{warnings}  = 0;

# test validity of alignments; go on if no inconsistencies found
 
    if (&align($self) == 0 && $contig) {

# alignment tested okay: all alignments consistent and contig ID defined
# only proceed if the read is actually present in READS, i.e. reads_id exists

        if (my $read_id = $self->isInDataBase(0,0)) {

$DEBUG = 0; # $DEBUG = 1 if ($read_id == 73701);

    # test edits against possible exiting data in READEDITS
print "ETEST for  ReadMapper $self->{names}->[0]$break" if $DEBUG;
	    &etest($self);

    # counts->[5] = 0 (set in etest) if new edits have to be put into database 

            if ($counts->[0] && !$counts->[5]) {
        # deprecate any existing previous edits for this read
                $EDITS->update('deprecated','Y','read_id',$read_id);
        # now write the edits to database
                foreach my $edithash (keys (%$edits)) {
                   (my $base = $edithash) =~ s/^[0]+//;
        # (NOTE: the next blocks should be replaced by one call to the database)
                    my $edit = $edits->{$edithash};
                    if (!$EDITS->newrow('read_id',$read_id,'deprecated','X')) {
                        $status->{diagnosis} .= "! Failed to add edit entry";
                        $status->{diagnosis} .= " $read_id $base $edit to EDITS";
                        $status->{errors}++;
                    }
                    else {
                        $EDITS->update('base',$base);
                        $EDITS->update('edit',$edit);
                        $EDITS->update('deprecated','N');
                        $counts->[5]++;
                    }
                }
            }

    # test alignment data against possible existing data in READS2CONTIG

            &mtest($self);

    # we store all readmaps of the current generation; afterwards we have to
    # remove copies marked 'M' in previous generation, which leaves us with
    # two copies: the one mapped to the contig in which it first occurred, and
    # the one in the current generation 
    # marker set to X indicates that mappings have been loaded for generation 0
    # previously during an earlier run of a loading script using this module

$DEBUG = 0; # $DEBUG=1 if ($self->{names}->[0] =~ /mal4N18g10\.p2co17frA/);
print "++++ after MTEST for ReadMapper $self->{names}->[0]  counts: @$counts ++++$break" if $DEBUG;

            if ($counts->[1] && $marker ne 'X') {

        # build and add the overall mapping to a table of several alignments

                my $aligntype = 1; # default single alignment in this read
                my @read2conKeys = sort keys %$read2con;
                if (@read2conKeys > 1) {
#                if (keys (%$read2con) > 1) {
                   $aligntype = 0; # multiple alignments
                    undef my @range;
                    my $l = 3 - $self->{align}; my $k = 5 - $l; # 2,3 or 3,2
                    foreach my $alignment (@read2conKeys) {
#                    foreach my $alignment (sort keys (%$read2con)) {
                        my $block = $read2con->{$alignment};
                        @range = @$block  if !@range;
                        $range[0]  = $block->[0]  if ($block->[0]  < $range[0]);
                        $range[1]  = $block->[1]  if ($block->[1]  > $range[1]);
                        $range[$k] = $block->[$k] if ($block->[$k] < $range[$k]);
                        $range[$l] = $block->[$l] if ($block->[$l] > $range[$l]);
                    }
                    $read2con->{'999999'} = \@range;
		    push @read2conKeys, '999999';
                }

                my $clone_id = $self->{clone} || 0;

#$self->list(1) if $DEBUG;
		$MyTimer->timer('RM newline(s)',0) if $TIMER;
                foreach my $alignment (@read2conKeys) {
#                foreach my $alignment (sort keys (%$read2con)) {
# print "alignment key $alignment$break";
                    my @block = @{$read2con->{$alignment}};
                    if (@block != 4) {
                        $status->{diagnosis} .=  "invalid alignment $alignment: @{block}$break";
                        $status->{errors}++;           
                    }

                    else {
                # define label: 0 for one in a series; 1 for a single record; 2 for end series
                        my $label = $aligntype;
                        $label = 2 if ($alignment eq '999999'); # last of a series 
                        $label = $label*10 + $self->{align};    # odd if aligned against contig
                # assemble arrays
                        undef my @columns;
                        undef my @cvalues;
                        push @columns, 'contig_id' ; push @cvalues, $contig;
                        push @columns, 'pcstart'   ; push @cvalues, $block[2];
                        push @columns, 'pcfinal'   ; push @cvalues, $block[3];
                        push @columns, 'read_id'   ; push @cvalues, $read_id;
                        push @columns, 'prstart'   ; push @cvalues, $block[0];
                        push @columns, 'prfinal'   ; push @cvalues, $block[1];
                        push @columns, 'assembly'  ; push @cvalues, $assembly;
                        push @columns, 'clone'     ; push @cvalues, $clone_id;
                        push @columns, 'label'     ; push @cvalues, $label;
                        push @columns, 'generation'; push @cvalues, 0;
                        push @columns, 'deprecated'; push @cvalues, $marker;

                        if ($RR2CC->newrow(\@columns,\@cvalues)) {
                            if ($status->{diagnosis} !~ /\badded/) {
                                $status->{diagnosis} .= "Alignments to contig $contig added: ";
print "Alignments @cvalues to contig $contig (@block) added$break" if $DEBUG;
                            }
                            $status->{diagnosis} .= "x";
                        }
                        else {
                            $status->{diagnosis} .= "! Failed to add alignment $alignment to contig";
                            $status->{diagnosis} .= " $contig (@block) to READS2CONTIG$break";
print "$status->{diagnosis} $break $RR2CC->{lastquery} $break $RR2CC->{qerror} $break";
                            $status->{errors}++;
                        } 
                        $counts->[6]++;
    # and finally update assembly in READS2ASSEMBLY
                        $RR2AA->update('assembly',$assembly,'read_id',$read_id);
                    }
                } 
		$MyTimer->timer('RM newline(s)',1) if $TIMER;
                $status->{diagnosis} .= "$break";
    # here you could do the cleanup of marked mappings of previous generations
                if ($piecemealwise) {
                    my $where = "read_id=$read_id && generation>0 && deprecated='M'";
                    $RR2CC->delete('where',$where);
                }
            }
            elsif ($counts->[1] && $marker eq 'X') {
                $status->{diagnosis} .= "Generation 0 alignments of read $read_id to contig ";
                $status->{diagnosis} .= "$dbrefs->[3] ($contig) are currently stored: dump ";
                $status->{diagnosis} .= "SKIPPED$break";
                $status->{warnings}++; 
# print "$status->{diagnosis}";          
            }
            elsif (!$counts->[1]) {
                $status->{diagnosis} .= "! No CAF alignment defined$break";
                $status->{errors}++;           
            }
            else {
                $status->{diagnosis} .= "Unspecified error in read $read_id: $counts->[1], ";
                $status->{diagnosis} .= "$counts->[2], $dbrefs->[3] $contig$break";
                $status->{errors}++;           
            }
        }
        $dbrefs->[2] = $contig; # memorise current contig for list purposes  
    }
    elsif (!$contig) {
        $status->{diagnosis} .= "! dump failed because of undefined contig reference$break";
        $status->{errors}++;           
    }
    else {
        $status->{diagnosis} .= "! dump failed because of align errors$break";
        $status->{errors}++;           
    }

    $MyTimer->timer('RM dump',1) if $TIMER; 

print "$self->{report}" if $DEBUG;

    if (&status($self,0)) {
        return 0; # failed to dump the alignments or the edits
    }
    elsif (!$dbrefs->[3]) {
        return 1; # alignments (and edits) have been written to database fro this new read
    }
    else {
        return 2; # this read was found to be aligned to contig $dbrefs->[3]
    }
}

###############################################################################
# private function to test alignments
###############################################################################

sub align {
# test if all information is present, then test the mapping itself
    my $self = shift;

    my $counts   = $self->{counts};
    my $padtocon = $self->{padtocon};
    my $read2pad = $self->{read2pad};
    my $read2con = $self->{read2con};
    my $status   = $self->{status};
    my $dbrefs   = $self->{dbrefs};

    $MyTimer->timer('align',0) if $TIMER; 

    my $error = $status->{errors};
 
# count [1]=number of maps, [2]=alignment defined, [4]=quality right
$DEBUG = 0; $DEBUG=1 if ($self->{names}->[0] =~ /mal4N18g10\.p2co17frA/);
print "++++ ALIGN for ReadMapper $self->{names}->[0] ($self) (counts = @$counts)++++$break" if $DEBUG;

    if ($counts->[1] > 0 && $counts->[2] == 1 && ($counts->[4] > 0 || $counts->[3] > 0)) {
# get shift between padded read and contig and its direction
        my ($cntgs, $cntgf, $padds, $paddf) = @{$padtocon};
# ensure ordering on (padded) read is increasing
       ($cntgf, $cntgs, $paddf, $padds) =  @{$padtocon} if ($padds > $paddf);
# determine orientation of mapping on contig
        my $sign = 1.0;
        $sign = -1.0 if ($cntgs > $cntgf);
# get transformation between padded read and contig y = shifts + sign*x
        my $shifts = $cntgs - $sign*$padds;
        my $shiftf = $cntgf - $sign*$paddf;

# test overal quality range for this contig
       
        my $ql = $counts->[3];
        my $qr = $counts->[4];
        my $qlength = $qr - $ql; # quality range
        my $rlength = $paddf - $padds; # read (and contig) section length

        if ($rlength < $qlength) {
    # warning, info only,  to be printed only in case of other warnings or errors
            $status->{diagnosis} .= "  Quality range $ql - $qr not fully covered $padds - $paddf$break";
        } 
        elsif ($rlength > $qlength) {
    # warning always printed: may indicate more serious problem with mapping
            $status->{warnings}++;
            $status->{diagnosis} .= "! Mapped range @{$padtocon}";
            $status->{diagnosis} .= " overflows quality range $ql - $qr$break";
        }


        if (int($shifts-$shiftf) != 0) {
            $status->{errors}++; # shifts must be the same
            $status->{diagnosis} .= "! Corrupted (padded) read-to-contig mapping:";
            $status->{diagnosis} .= " @{$padtocon}, shifts $shifts & $shiftf$break";
        }
        else {
            my $outside = 0;
            foreach my $number (sort keys (%$read2pad)) {
                my ($pstart, $pfinal, $rstart, $rfinal, @dummmy) = @{$read2pad->{$number}};
        # shift between padded read segment and read segment on trace file
                my $shift = $pstart - $rstart;
        # get clipping window for un-padded read section by backtransforming from padded read
                my $wndws = $padds - $shift;
                my $wndwf = $paddf - $shift;
                $rstart = $wndws  if ($rstart < $wndws);
                $rfinal = $wndwf  if ($rfinal > $wndwf);

                if ($rstart <= $rfinal) {
        # positioning is okay, now get mapped range by applying forward translation
                    $read2con->{$number}->[0] = $rstart;                 # unpadded
                    $read2con->{$number}->[1] = $rfinal;
                    $pstart = $rstart + $shift;                          # padded
                    $pfinal = $rfinal + $shift;
                    $read2con->{$number}->[2] = $shifts + $sign*$pstart; # contig
                    $read2con->{$number}->[3] = $shifts + $sign*$pfinal;   
        # now the range $pstart-$pfinal must preferably be inside the quality range
                    if ($pstart < $ql || $pfinal > $qr) {
                        $status->{warnings}++;
                        $status->{diagnosis} .= "! Alignment block $number: $rstart-$rfinal";
                        $status->{diagnosis} .= " (padded: $pstart-$pfinal) outside";
                        $status->{diagnosis} .= " quality window $ql-$qr$break" if ($qr >= $ql);
                        $status->{diagnosis} .= " quality window (vector covers window)$break" if ($qr< $ql);
                    }
print "Alignment block $number to be added: $rstart-$rfinal $break" if $DEBUG;
                }
                else {
                   ($pstart, $pfinal, $rstart, $rfinal, @dummmy) = @{$read2pad->{$number}}; # recall
                    $status->{warnings}++;
                    $status->{diagnosis} .= "! Alignment block $number: $rstart-$rfinal";
                    $status->{diagnosis} .= " (padded: $pstart-$pfinal) outside";
                    $status->{diagnosis} .= " contig window $padds-$paddf$break";
		    $outside++;
                }
            }
# test if there are any intervals left
            if (keys %$read2con == 0) {
                $status->{errors}++;
                $status->{diagnosis} .= "NO read segments found inside contig range$break";
            }
            elsif ($outside) {
                $status->{warnings}++;           
                $status->{diagnosis} .= "$outside read segments outside contig range$break";
            }
        }
    }
    else {
    # error in alignment data
        $status->{errors}++;
        $status->{diagnosis} .= "! Missing mapping information, counts:@{$counts}$break";
        $status->{diagnosis} .= "  Missing CAF alignment(s)$break" if ($counts->[1] == 0);
        $status->{diagnosis} .= "  Missing or invalid alignment to contig$break" if ($counts->[2] != 1);
        $status->{diagnosis} .= "  Invalid or missing Quality Window$break" if ($counts->[4] == 0);
    }

    $MyTimer->timer('align',1) if $TIMER; 

    return $status->{errors} - $error; # will be 0 if no errors
}

################################################################################
# 
################################################################################

sub list {
# short or long list of current status
    my $self = shift;
    my $list = shift;

    my $count    = $self->{counts};
    my $names    = $self->{names};
    my $edits    = $self->{edits};
    my $dbrefs   = $self->{dbrefs};
    my $read2pad = $self->{read2pad};
    my $padtocon = $self->{padtocon};

    print STDOUT "ReadMapper for $names->[0] list:";
    print STDOUT "$count->[0] Edit(s) and $count->[1] Mapping(s)$break";

    if (defined($list) && $list > 0) {
        foreach my $base (sort keys (%$edits)) {
            print STDOUT "edit on $base: $edits->{$base}$break";
        }

        foreach my $number (keys (%$read2pad)) {
            print STDOUT "Map: @{$read2pad->{$number}}$break";
        }
    }
    print STDOUT "Read_id = $dbrefs->[0]; "    if ($dbrefs->[0]);
    print STDOUT "Pending id = $dbrefs->[1]; " if ($dbrefs->[1]);
    print STDOUT "mapped to contig $dbrefs->[2]: @{$padtocon}$break" if ($dbrefs->[2]);
    print STDOUT "linked to earlier contig $dbrefs->[3]$break"       if ($dbrefs->[3]);

    return status ($self,2);
}

###############################################################################

sub status {
# return the hash reference to a named read in the class hash table "reads"
    my $self = shift;
    my $list = shift;

    my $names  = $self->{names};
    my $status = $self->{status};

    my $errors    = $status->{errors};
    my $warnings  = $status->{warnings};
    my $diagnosis = $status->{diagnosis};

    if (defined($list) && $list > 0) {
        my $fonts = &fonts;
        if ($errors || $warnings) {
            my $font = $fonts->{b}; 
            $font = $fonts->{o} if $errors;
            print STDOUT "Status of ReadMapper $names->[0]: ";
            print STDOUT "$font $errors errors $fonts->{e}, $warnings warnings $break";
            print STDOUT "$diagnosis $break" if ($list > 1);
        }
        elsif ($list > 1) {
            print STDOUT "Status of ReadMapper $names->[0]:$fonts->{g} passed $fonts->{e} $break";
        }
        print STDOUT "$self->{report} $break"  if ($list > 2 && $self->{report});
    }

    return $errors;
}

###############################################################################

sub reset {
# resets the errors and warning counters
    my $self = shift;

    my $status = $self->{'status'};
    $status->{errors}    = $status->{inerrors};
    $status->{diagnosis} = $status->{inputlog};
    $status->{warnings}  = 0;
}

###############################################################################

sub delete {
# delete the hashes of this read (irreversible) and remove from reads table
    my $self = shift;

    my $name = $self->{names};
    my $read = $name->[0];

    foreach my $key (keys (%$self)) {
        my $hash = $self->{$key};
        undef %$hash if (ref($hash) eq "HASH");
        undef @$hash if (ref($hash) eq "ARRAY");
    }

    undef %$self;

    delete $ReadMapper{$read};
}

###############################################################################
# Class sub-routines
###############################################################################

sub lookup {
# return the reference to a ReadMapper instance in the class table
    my $self = shift;
    my $read = shift;

# if $read is a name,   return ref to named read 
# if $read is a number, return ref of that number in the table  

    return \%ReadMapper if !$read;

    $MyTimer->timer('lookup',0) if $TIMER; 

    my $result = $ReadMapper{$read};

    if (!$result && !($read =~ /[a-z]/i) && $read =~ /\d+/) {

        foreach my $name (sort keys (%ReadMapper)) {
            if (--$read == 0) {
                $result = $ReadMapper{$name};
                last;
            }
        }
    }

    $MyTimer->timer('lookup',1) if $TIMER; 

    return $result;
}

##################################################################################

sub reaper {
# cleanup all marked readmaps in previous generations
    my $self     = shift;
    my $assembly = shift;

# leave generation  1 untouched! (i.e. do reaper after ageByOne)

    my $where = "generation > 1 AND deprecated = 'M' AND assembly=$assembly";
#print "reaper: delete from READS2CONTIG where $where $break";
    $RR2CC->delete('where',$where) if ($assembly && $assembly > 0);
}

##################################################################################

sub ageByOne {
# increase all generation counters by one
    my $self     = shift;
    my $assembly = shift;

# only apply aging if generation 0 exists

    my $where = "generation=0 AND assembly=$assembly";
    if ($assembly && $assembly > 0 && $RR2CC->count($where)) {
        my $query = "UPDATE <self> set generation=generation+1 WHERE $where";
#print "ageByOne: $query $break";
        $RR2CC->query($query,1);
        &reaper($self,$assembly);
    }
}

##################################################################################

sub endOfLine {
# to be invoked after generation 0 is completed: retire reads in G1 but not in G0
    my $self = shift;

    my $query  = "select G1.read_id from READS2CONTIG as G1 left join READS2CONTIG as G0 ";
    $query .= "on G1.read_id = G0.read_id where G1.label >= 10 and G0.label >= 10 and ";
    $query .= "G0.read_id = NULL";
print "endOfLine query $query$break";
    if (my $hashes = $RR2CC->query($query,0,0)) {
my $length=@$hashes;
print "hashes= $hashes $length $break";
        $RR2CC->update('deprecated','X','read_id',$hashes);     
    }
}

##################################################################################

sub oldinDataBase {
# test where the named read is in the ARCTURUS database
    my $self = shift;
    my $read = shift;
    my $pend = shift;

# if the read is not in the READS database test for it in PENDING table

    my $dbpref = 0;
    my $dbrref = 0;
    
#    if (!$dbrref && defined($read) && !($dbrref=$READS->associate('read_id',$read,'readname'))) {
#        $dbrref = 0; # read not found in READS
#        if (!($dbpref = $PENDS->associate('record',$read,'readname'))) {
#            $dbpref = 0; # read not found in PENDING either
#            if (defined($pend) && $pend && $PENDS->newrow('readname',$read)) {
#                $PENDS->update('assembly',$ASSEMBLY) if $ASSEMBLY;
#                $dbpref = $PENDS->associate('record',$read,'readname');
#            }
#        } 
#    }
    return ($dbrref, $dbpref);
}

################################################################################
# The next 3 subs test if the read is already in READS or perhaps in PENDING
################################################################################

sub isInDataBase {
# test where the read is listed in the ARCTURUS database
    my $self     = shift;
    my $dbprobe  = shift; # probe database if read not in cached table sections
    my $append   = shift; # add the read to PENDING database if not found
    my $assembly = shift; # assembly to be assigned read in PENDING (if added)

    my $names  = $self->{names};
    my $dbrefs = $self->{dbrefs};
    my $status = $self->{'status'};

# if the read is not in the READS database test for it in PENDING table

    $MyTimer->timer('isInDataBase',0) if $TIMER;

    if (!$dbrefs->[0] || !$dbrefs->[1]) {

       ($dbrefs->[0], $dbrefs->[1]) = $self->inDataBase($names->[0],$dbprobe,$append,$assembly);

        if ($dbrefs->[0] && !$dbrefs->[1]) {
            $dbrefs->[1] = -1; # suppress subsequent search as read is in READS
        } 
        elsif (!$dbrefs->[0] && $dbrefs->[1]) {
            $dbrefs->[0] = -1; # suppress subsequent search as read is in PENDING
        }
        elsif ($dbprobe) {
# the read could not be added to the pending list
            $dbrefs->[0] = -1;
            $dbrefs->[1] = -1;
        }
    }

    $MyTimer->timer('isInDataBase',1) if $TIMER;

# return value > 0 only if read present in database READS table

    if ($dbrefs->[0] > 0) {
        return $dbrefs->[0];
    } 
    else {
        return 0;
    }
}

#############################################################################

sub inDataBase {
# test where the named read is in the ARCTURUS database
    my $self     = shift;
    my $readname = shift; # read name
    my $dbsearch = shift || 0; # set true to search database if not found in cache
    my $append   = shift || 1; # set true if a missing read is to be added to PENDING
    my $assembly = shift || 0; # the assembly number 
#    my $list = shift || 0;

# print "inDataBase called from ContigBuilder for read $readname, pen $append $break" if $list;

# first test the (possibly) cached data
# if the read is not in the READS database test for it in PENDING table
# if not found && find, do a query

    my $dbrref = 0;
    my $dbpref = 0;
    my $hashes = 0;

    $MyTimer->timer('inDataBase',0) if $TIMER; 

    if (!$readname) {
        return 0, 0;
    }
# first look in the READS cache
    elsif ($hashes = $READS->cacheRecall($readname)) {
        $dbrref = $hashes->[0]->{read_id} || 0;
        $self->{clone} = $hashes->[0]->{clone};
#print "Read $readname found in READS $dbrref $break";
    }
# then look in the PENDING cache
    elsif ($hashes = $PENDS->cacheRecall($readname)) {
        $dbpref = $hashes->[0]->{record}  || 0;
#print "Read $readname found in PENDING $dbpref $break";
    }
# if not found in either two tables: try find the read in the READS tablehandle
    elsif ($dbsearch) {
        $MyTimer->timer('inDataBase db-lookup',0) if $TIMER; 
        $dbrref = $READS->associate('read_id',$readname,'readname',{useCache => 0});
        $dbpref = $PENDS->associate('record' ,$readname,'readname',{useCache => 0}) if !$dbrref;
        $MyTimer->timer('inDataBase db-lookup',1) if $TIMER; 
    }

    $MyTimer->timer('inDataBase',1) if $TIMER; 

# if read not found in either READS or PENDING : add to PENDING

    if (!$dbrref && !$dbpref && $append) {
        $MyTimer->timer('inDataBase newrow',0) if $TIMER;
        if ($assembly) {
            $dbpref = $PENDS->newrow('readname',$readname,'assembly',$assembly);
        }
        else {
            $dbpref = $PENDS->newrow('readname',$readname);
        }
        $MyTimer->timer('inDataBase newrow',1) if $TIMER;
# error status checking
print "Adding to PENDING: $readname (as $dbpref)$break";
        if (!$dbpref) {
            my $status = $self->{'status'};
            $status->{diagnosis} .= "! Failed to add entry $readname ";
            $status->{diagnosis} .= "to PENDING list$break";
            $status->{warning}++;
        }
    }

    return ($dbrref, $dbpref);
}

#############################################################################

sub preload {
# get database id (level=1) or mapping data (level=2) into hash %readstatus
    my $self  = shift;
    my $reads = shift || 0; # ref to ARRAY with readnames
    my $mask  = shift || '1100';

    my @mask = split //,$mask;

    my $where = '';
    my $query = '';

print "enter ReadMapper preload $reads $mask $break";

print "Building caches ('$mask') $break";

    if ($reads && ref($reads) eq 'ARRAY') {
# array mode
        my $extend = 0;
        my $nblock = 1000;
        my $nr = @$reads;
        my $ns = 1;
        while ($ns <= $nr) {
            my $nf = $ns + $nblock -1;
            $nf = $nr if ($nf > $nr);  
print "ns=$ns  nf=$nf  nr=$nr $break";
            undef my @block;
	    for my $i ($ns .. $nf) {
                push @block, $reads->[$i-1];
#                push @block,(shift @$reads); # if removing buffer
            }
            $ns = $nf + 1;
# get the readname and read_id in the database (READS and PENDING)
            my $where = "where readname in (\"".(join '","',@block)."\")";

            if ($mask[0]) {
print "READS $break";
                $query = "select read_id,readname,clone from <self> $where";    
                $READS->cacheBuild($query,{indexKey=>'readname',extend=>$extend});
# get the read_id's from the readnames, using the cached data
            }
            if ($mask[1]) {
print "PENDS $break";
                $query = "select record,readname from <self> $where";
# print "$query $break";
                $PENDS->cacheBuild($query,{indexKey=>'readname',extend=>$extend});
            }

            if ($mask[2] || $mask[3]) {
# get the read_id's from the readnames, using the cached data
                my @readids;
                foreach my $read (@block) {
                    my $hash = $READS->cacheRecall($read);
                    push @readids,$hash->[0]->{read_id} if $hash;
                }

                if (@readids) {
# cache the read to contig maps
                    $where = "where read_id in (".(join ',',@readids).")";
                    $query = "select *  from <self> $where";
print "RR2CC $break";
# print "$query $break";
                    my %options = (indexKey=>'read_id',extend=>$extend);
                    $options{sortBy} = 'deprecated,label';
                    $RR2CC->cacheBuild($query,\%options) if $mask[2];
                    $options{sortBy} = 'edit,base';
                    $EDITS->cacheBuild($query,\%options) if $mask[3];
                }
            }
            $extend = 1;
        }
    }
# or load whole table
    else {
print "enter ReadMapper preload whole table $reads $break";

        my $query = "select read_id,readname,clone from <self>";
print "$query $break" if $mask[0];
        $READS->cacheBuild($query,{indexKey=>'readname'}) if $mask[0];
        $query = "select record,readname from <self>";
print "$query $break" if $mask[1];
        $PENDS->cacheBuild($query,{indexKey=>'readname'}) if $mask[1];

        $query = "select *  from <self>";
print "$query $break" if $mask[2];
        $RR2CC->cacheBuild($query,{indexKey=>'read_id', sortBy=>'deprecated, label'}) if $mask[2];
print "$query $break" if $mask[3];
        $EDITS->cacheBuild($query,{indexKey=>'read_id', sortBy=>'edit,base'}) if $mask[3];
    }
print "exit preload $break$break";
}

#############################################################################

sub tagList {
# e.g. list = tagList('FTAGS')
    my $self = shift;
    my $name = shift;

    my @TAGS  = ('FINL','FINR','ANNO','COMP','FICM','RCMP','POLY',
                 'REPT','OLIG','COMM');

    my $list  = eval "join '|',\@$name";
}

#############################################################################

sub fonts {

# return a hash with font specifications

    my %font = ( b=>'blue', o=>'orange', g=>'lightgreen', 'y'=>'yellow', e=>'</FONT>');

    foreach my $colour (keys %font) {
        if ($ENV{REQUEST_METHOD}) {
            $font{$colour} = "<FONT COLOR=$font{$colour}>" if ($colour ne 'e');
        }
        else {
            $font{$colour} = " ";
        }
    }

    return \%font;
}

#############################################################################
#############################################################################

# class method: testing before destroying all remaining ReadMapper object

sub flush {

# flush mapping and PENDING tables

    $RR2CC->flush;
    $RR2AA->flush;
    $EDITS->flush;

# test the remaining ReadMapper instances using the currently cached data

print "Flushing ReadMappers$break";
    my @readnames;
    foreach my $readname (keys %ReadMapper) {
        my $instance = $ReadMapper{$readname};
        if ($instance->isInDataBase(0,0)) {
            $instance->delete; # found in READS
        }
        elsif ($instance->{dbrefs}->[1] > 0) {
            $instance->delete; # found in PENDING
        }
        else {
print "NOT FOUND IN CACHE: $readname $break";
            push @readnames,$readname;
        }
    }

    $PENDS->flush;

# @readnames contains all readnames not found in the database
# rebuild caches for these remaining files only; then test again
    
my $nr = @readnames; print "$nr reads to be re-investigated $break";
    return if !@readnames;

    &preload(0,\@readnames,'0100'); # build only PENDING

    foreach my $readname (@readnames) {
        my $instance = $ReadMapper{$readname};
        $instance->isInDataBase(0,1);
        $instance->delete;
    }

# and flush the PENDING table again

    $PENDS->flush;
}
#############################################################################

sub break {

# return the line break appropriate for the environment

    my $break = "\n";

    $break = "<br>" if $ENV{REQUEST_METHOD}; # cosmetics

    return $break;
}

#############################################################################
#############################################################################

sub colophon {
    return colophon => {
        author  => "E J Zuiderwijk",
        id      =>            "ejz",
        group   =>       "group 81",
        version =>             0.9 ,
        date    =>    "16 Mar 2002",
        update  =>    "31 Mar 2003",
    };
}

1;

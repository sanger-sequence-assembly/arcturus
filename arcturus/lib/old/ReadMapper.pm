package ReadMapper;

#############################################################################
#
# map a READ onto a contig 
#
#############################################################################

use strict;

#############################################################################
# Global variables
#############################################################################

my %ReadMapper; # all readmapper instances on key readname

# declare database handles to READS, READS2CONTIG, READEDITS and PENDING table

my $READS; # READS database table handle
my $RR2CC; # READS2CONTIG
my $EDITS; # READEDITS
my $PENDS; # PENDING
my $RR2AA; # READS2ASSEMBLY

my $LIGATIONS; # handle autogenerated in testAttributes
my $SVECTORS;  # handle autogenerated in testAttributes
my $CVECTORS;  # handle autogenerated in testAttributes

my $DBS = 0; # default no database search if data not found in table caches

my $piecemealwise = 0; # default no tidy-up of mappings to earlier contigs

my %ligations; # hash for ligation values to be tested in READS repair mode

my $DEBUG = 0;

my $CGI;
my $break;
my $MyTimer;
my $TIMER;


#############################################################################
# constructor init: initialise the global (class) variables
#############################################################################

sub init {
# create a romp instance read object to facilitate access to class variables
    my $prototype = shift;
    my $tblhandle = shift;

    my $class = ref($prototype) || $prototype;
    my $self  = {};

# get table handles used in this module

    $READS = $tblhandle->spawn('READS');
    $RR2CC = $tblhandle->spawn('READS2CONTIG');
    $EDITS = $tblhandle->spawn('READEDITS');
    $PENDS = $tblhandle->spawn('PENDING');
    $RR2AA = $tblhandle->spawn('READS2ASSEMBLY');

    &setEnvironment; # output line break

    bless ($self, $class);

    return $self;
}


###############################################################################
# constructor new: create a handle to a stored read
###############################################################################

sub new {
# create an instance read object 
    my $prototype = shift;
    my $readname  = shift;

    my $class = ref($prototype) || $prototype;
# test if an exiting ReadMapper of this name exists
    return $ReadMapper{$readname} if $ReadMapper{$readname};

    my $self  = {};

    $self->{names}    = []; # read name, contig name (+history?)
    $self->{dbrefs}   = []; # database data read_id, pend_id, contig_id 
    $self->{edits}    = {}; # editing hash
    $self->{tags}     = []; # array of hashes for read tags

    $self->{read2pad} = {}; # mapping read (segment) to padded read
    $self->{padtocon} = []; # mapping padded read to contig
    $self->{read2con} = {}; # mapping read (segment) to contig
    $self->{contocon} = []; # for possible contig to contig alignment info
    $self->{assemble} = []; # array for assembled from records ..

    $self->{counts}   = []; # counters
    $self->{marked}   = ''; # marker 'N' or 'M' for deprecation status
    $self->{series}   = []; # array with generations of mappings for this read
    $self->{status}   = {}; # error status report

    $self->{biology}  = {}; # hash for bio-info
    $self->{quality}  = []; # various quality boundaries
#    $self->{clone}    =  0; # clone-id (re: contig map)

    $self->{report}   = ''; # extended reporting

# store the name of this read in the instance variable
 
    my $names  = $self->{names};
    $names->[0] = $readname;

# set the references to the ARCTURUS database to 0

    my $dbrefs = $self->{dbrefs};
    @$dbrefs = (0,0,0,0);

# initialize counts

    my $counts = $self->{counts};
    @$counts = (0,0,0,0,0,-1,-1);

# initialize error status

    my $status = $self->{status};
    $status->{errors}   = 0;
    $status->{inerrors} = 0;
    $status->{warnings} = 0;
    $status->{inputlog} = '';

# add the name of this read to the class variable %ReadMapper

    $ReadMapper{$readname} = $self;

    bless ($self, $class);
    return $self;
}

###############################################################################

sub setPMWise {
    my $self = shift;
    my $pmw  = shift;

    $piecemealwise = $pmw;
}

###############################################################################

sub onCompletion {
# to be run after all data for this read have been collected e.g. read from CAF
    my $self   = shift;
    my $test   = shift;
    my $repair = shift;

    &quality($self,0,0,-1); # (final) update quality range

    &testAttributes($self,$repair) if ($test || $repair); # optional repair of READS info
}

###############################################################################

sub setAttribute {

    my $self  = shift;
    my $item  = shift;
    my $value = shift;
    my $list  = shift;

    return if (!$item || !defined($value));

    if ($self->{biology}->{$item} && $self->{biology}->{$item} ne $value) {

        if ($list) {
            print STDOUT "!Read $self->{names}->[0]: Inconsistent ";
            print STDOUT "attribute $item: new value $value against ";
            print STDOUT "previously found $self->{biology}->{$item}$break";
        }
    }
    else {
        $self->{biology}->{$item} = $value;
    }
}

###############################################################################

sub testAttributes {
# test attribute e.g. ligation/clone/vectors against read data; repair if possible
    my $self     = shift;
    my $repair   = shift;

    my $report = '';
    if (my $read_id = $self->isInDataBase(1,0)) {

# get data from READS for this read

        my $query = "select ligation,svector,cvector,clone from <self> where read_id=$read_id";
        my $hashrefs = $READS->query($query,{traceQuery=>0});
        return 0 if !$hashrefs; # protection

        my $biology = $self->{biology};

# sequence vector

        my $svector = $biology->{svector}; # name read from e.g. caf file
        $svector = 0  if ($svector && $svector =~ /unknown/i);
        if ($svector && !$hashrefs->[0]->{svector}) {
            $report .=  "Attempt to repair missing Sequence Vector for read $read_id (set to $svector)$break"; 
            undef my $error;
            $SVECTORS = $READS->spawn('SEQUENCEVECTORS') if !$SVECTORS;
            $SVECTORS->build(1) if !$SVECTORS->associate('hashrefs'); # just to be sure
            if ($repair && $SVECTORS) {
                $SVECTORS->counter('name',$svector,1);
	        $svector = $SVECTORS->associate('svector',$svector,'name');                
                $READS->update('svector',$svector,'read_id',$read_id) if  $svector;
                $error = "failure to update table SEQUENCEVECTORS"    if !$svector;
            }
            elsif ($repair) {
                $error = "missing instance of table SEQUENCEVECTORS";
            }
            $report .= "! Could not repair 'svector' for read $read_id: $error" if $error;
        }
        elsif ($repair && $repair > 1 && $svector) {
    # full repair mode, replacing incorrect data, to be developed
        }

# cloning vector
        
        my $cvector = $biology->{cvector};
        $cvector = 0  if ($cvector && $cvector =~ /unknown/i);
        if ($cvector && !$hashrefs->[0]->{cvector}) {
            $report .=  "Attempt to repair missing Cloning Vector for read $read_id (set to $cvector)$break"; 
            undef my $error;
            $CVECTORS = $READS->spawn('CLONINGVECTORS') if !$CVECTORS;
            $CVECTORS->build(1) if !$CVECTORS->associate('hashrefs'); # just to be sure
            if ($repair && $CVECTORS) {
                $CVECTORS->counter('name',$cvector,1);
	        $cvector = $CVECTORS->associate('cvector',$cvector,'name');
                $READS->update('cvector',$cvector,'read_id',$read_id) if $cvector;
                $error = "failure to update table CLONINGVECTORS"    if !$cvector;
            }
            elsif ($repair) {
                $error = "missing instance of table CLONINGVECTORS";
            }
            $report .= "! Could not repair 'cvector' for read $read_id: $error $break" if $error;
        }
        elsif ($repair && $repair > 1 && $svector) {
# full repair mode, replacing incorrect data, to be developed
        }

# ligations
# print "$break repair LIGATIONS ($report) $break";

        $LIGATIONS = $READS->spawn('LIGATIONS') if !$LIGATIONS;
        if (keys %ligations == 0 && $LIGATIONS) {
            $LIGATIONS->build(1) if !$LIGATIONS->associate('hashrefs'); # just to be sure
            if (my $hashrefs = $LIGATIONS->associate('hashrefs')) {
                foreach my $hash (@$hashrefs) { # select undefined ligations
                    $ligations{$hash->{ligation}} = $hash if ($hash->{identifier} =~ /^(U\d+|99999)$/);
                }
            }
            $ligations{00} = 0 if (keys %ligations == 0); # add dummy 
        }
        
        my $identifier = $biology->{ligation}; # as read from e.g. caf file
        if ($identifier && $identifier ne '99999') {
            undef my $error;
            if ($repair && (my $hash = $ligations{$hashrefs->[0]->{ligation}})) {
	        print "read $read_id $hashrefs->[0]->{ligation}$break";
# okay, this read has an undefined or incomplete ligation referenced in READS
                $SVECTORS = $READS->spawn('SEQUENCEVECTORS') if !$SVECTORS;
                $SVECTORS->build(1) if !$SVECTORS->associate('hashrefs'); # just to be sure
                $report .= "Attempt to repair ligation $hashrefs->[0]->{ligation} ($hash->{identifier}) ";
                $report .= "with $identifier for read $read_id (read clone $hashrefs->[0]->{clone})$break"; 
                if (my $status = $LIGATIONS->counter('identifier',$identifier,1)) {
                    my $ligation = $LIGATIONS->associate('ligation',$identifier,'identifier');#
                    if ($status == 2) {
                        $LIGATIONS->update('silow',$biology->{silow})  if defined($biology->{silow});
                        $LIGATIONS->update('silow',$biology->{sihigh}) if defined($biology->{sihigh});                                    $LIGATIONS->update('clone',$biology->{clone})  if defined($biology->{clone});             
                        $svector = $SVECTORS->associate('svector',$svector,'name') if $svector;
                        $LIGATIONS->update('svector',$svector) if $svector;
# print "NEW LIGATION $ligation:"; foreach my $key (keys %$biology) { print " $key $biology->{$key}"; } print "$break";
                        $LIGATIONS->update('origin' , 'C');
                    }
# replace ligation in read, update counter table for old ligation (check clone id)
                    $READS->update('ligation',$ligation,'read_id',$read_id);
                    $LIGATIONS->counter('ligation',$hashrefs->[0]->{ligation},-1);
                }
                else {
#                    $LIGATIONS->rollback();
                    print "Failed to add a new line to LIGATIONS$break";
                }
            }
            elsif ($ligations{$hashrefs->[0]->{ligation}}) {
                $report .= "Undefined ligation in read $read_id to be replaced by $identifier $break";
            }
            $report .= "! Could not repair 'ligations' for read $read_id: $error" if $error;
        }
    }
    return $report;
}

###############################################################################
# The next 4 subs define the mapping of the current read
#############################################################################

sub setTestMode {
# (re)define class variables;
    my $self = shift;
    my $item = shift || 0;
    my $mode = shift || 0;

    if ($item =~ /\b(TESTMODE|REPAIR|READSCAN|WRITEDNA)\b/i) {
#        $self->{$item} = $mode;
    }
    elsif ($item =~ /\bTIMER\b/i) {
        $TIMER = $mode;
    }
}

###############################################################################

sub edit {
# load edits for this read: store an edit instruction in the 'edits' hash
    my $self = shift;
    my $base = shift;
    my $edit = shift;
  
    my $edits  = $self->{edits};
    my $counts = $self->{counts};

    $edit = ' '.$edit  if (length($edit) == 1); # prepend single char with blank
    if (defined($edits->{base}) && length($edits->{$base}) > 2) {
        print "too many edits on base $base in $self->{names}->[0]: old '$edits->{$base}' new '$edit'$break";
    }
    else {
        $counts->[0]++ if !$edits->{$base};
        $edits->{$base} .= $edit;
    }

#print "edit $self->{names}->[0]: base $base  edit $edit count $counts->[0] '$edits->{$base}'$break"  if ($self->{names}->[0] eq 'mal4U12g9.p1t');
}

###############################################################################

sub addAlignToCaf {
# input caf alignment(s) for this read (allows several records per read)
    my $self  = shift;
    my $block = shift; # input array of length 4 with mapped positions

# @$block: [0] padded start; [1] pfinal ; [2] read start; [3] rfinal 

    my $read2pad = $self->{read2pad};
    my $counts   = $self->{counts};
    my $status   = $self->{status};
    my $quality  = $self->{quality}; # default quality range

    my $report = "alignToCaf input: @$block$break";

# test the input information: sections must be equal length and direction

    undef my $error;
    if (@$block == 4) {
    # test length and orientation of alignments
        my $rlgt = $block->[1] - $block->[0];
        my $clgt = $block->[3] - $block->[2];
        if ($rlgt == 0 && $block->[0] == 0) {
            $error = "zero length block specification";
        } 
        elsif ($rlgt != $clgt) {
            $error = "block length/orientation mismatch ($rlgt<>$clgt)";
        } 
        else {
# get the hash value (string!) for this alignment ('999999' will be used as terminator)
            $counts->[1]++; # it's the next alignment
            my $hash = sprintf ("%06d",$counts->[1]);
            @{$read2pad->{$hash}} = @$block;
            my $next = @$quality || 0;
            my $default = $quality->[$next];
            $default->[0] = $block->[2] if (!$default->[0] || $block->[2] < $default->[0]);
            $default->[1] = $block->[3] if (!$default->[1] || $block->[3] > $default->[1]);
            $default->[2] = 1; # overall window
        }
    } 
    else {
        $error = "incomplete alignToCaf data";
    }

# test error reporting

    if ($error) {
        $status->{inerrors}++;
        $status->{inputlog} .= "! Invalid mapping info: @{$block} : $error$break";
        $report .= "alignToCaf error: $error$break";
    }

    $self->{report} .= $report;
}

################################################################################


# SURPLUSS TO REQUIREMENT. TO BE DEPRECATED
sub oldalignToContig {
# input contig alignment (should be only one!) for this read (after padding)
    my $self     = shift;
    my $block    = shift; # input array of length 4 with mapped positions

# block[0] = begin on contig, [1] end; block[2] = begin on SCF (tracefile), [3] end

    my $padtocon = $self->{padtocon};
    my $counts   = $self->{counts};
    my $status   = $self->{status};

#    undef $self->{counterAlign};

# test the input: sections must be equal length but may have opposite direction

    my $report = "alignToContig input: @$block$break";

    my $error;
    if (@$block == 4) {
# test length and orientation of alignment
        my $clength = $block->[1] - $block->[0];
        my $rlength = $block->[3] - $block->[2];

        if (abs($rlength) != abs($clength)) {
#        if ($rlength != -$clength && $rlength != $clength) {
            $error = "block length mismatch ($rlength<>$clength)";
        } 
        else {
            @$padtocon = @$block;
            $counts->[2] = 1; # signal padded alignment as defined
# to be replaced by final test on consistence
# determine alignment direction 
            $self->{counterAlign} = ($rlength == $clength) ? 0 : 1;
#            $self->{counterAlign} = 0; # default co-aligned
#            $self->{counterAlign} = 1 if ($rlength == -$clength);
        }
    } 
    else {
        $error = "missing data (block @{$block})$break";
    }

# test error status

    if ($error) {
        $status->{inerrors}++;
        $status->{inputlog} .= "! Invalid align to contig: @{$block} : $error$break";
        $report .= "alignToContig error: $error$break";
        undef @$padtocon;
    }

    $self->{report} .= $report;
}

################################################################################

sub addAssembledFrom {
# input of Assembled_from reads to contig alignments
    my $self = shift;
    my $from = shift; # ref to array of mappings: cstart, cfinal, rstart, rfinal

# loading section for Assembled_from alignments

    my $assemble = $self->{assemble}; # reference to array of arrays

    my $error = '';
    my $success = 0;

my $DEBUG = 0;
print "addAssembledFrom : @$from $break" if $DEBUG;

    if ($from && @$from == 4) {
# test length of Assembled_from alignment
        my $clength = $from->[1] - $from->[0];
        my $rlength = $from->[3] - $from->[2];

        if (abs($clength) != abs($rlength)) {
            $error = "section length error ($rlength <> $clength)";
        } 
        else {
# make a local copy and add to the array of arrays
            my @amap = @$from;
            push @$assemble, \@amap;
            $success = @$assemble+0;
# determine the alignment and its consistence
            my $align = $amap[1] - $amap[0];
            if (!defined($self->{counterAlign}) || $self->{counterAlign} < 0) {
# define at first use of method, but leave unchanged if $align == 0 (single base section)
                $self->{counterAlign} = 0 if ($align > 0); # co-aligned
                $self->{counterAlign} = 1 if ($align < 0); # counter-aligned
            }
            elsif ($self->{counterAlign} == 0 && $align < 0 
               or  $self->{counterAlign} >  0 && $align > 0) {
# there is an inconsistence of alignment in multiple assembled_from mappings
               $error = "inconsistent alignment in unpadded mapping";
            }
        }
    }
    elsif ($from) {
        $error = "Invalid Assembled_from mapping @{$from}";
    }
    else {
        $error = "Missing Assembled_from mapping";
    }

# error status

    if ($error =~ /\S/) {
        my $status = $self->{status};        
        $status->{inputlog} .= "! Invalid Assembled_from mapping : ";
        $status->{inputlog} .= "(@{$from})" if $from;
        $status->{inputlog} .= "$break";
        $status->{inerrors}++;
    }

# returns number of alignments

print "success $success align $self->{counterAlign} err: $error $break" if $DEBUG;

    return $success;    

# after loading into this buffer, use 'getAssembledFrom' to sort out padded and
# unpadded representations, and prepare the read2con alignments, either via
# alignToSCF/alignToContig and align method, or directly into read2con 

}

################################################################################

sub alignToContig {
    my $self = shift;

# loading section for assemble from alignments

    my $read2pad = $self->{read2pad}; #  hash of arrays
    my $assemble = $self->{assemble}; # array of arrays
    my $padtocon = $self->{padtocon}; # array for padded alignment
    my $counts   = $self->{counts};
    my $status   = $self->{status};

my $DEBUG = 0;
print "enter new alignToContig for $self->{names}->[0]$break" if $DEBUG;

    my $alignToCaf = scalar(keys %$read2pad); # number of align_to_caf maps
    my $assembled  = scalar(@$assemble);    # number of assembled_from maps

# there are two buffers: the "read2pad" hash of arrays, filled by align_to_SCF
# data, and the "assemble" array of arrays, filled with Assembled_from data; 
# one of these MUST contain only one alignment. This enables a decision whether
# we deal with padded or unpadded data; we derive the unpadded data accordingly.

    if ($assembled == 1 && $alignToCaf >= 1) {

# it's PADDED data; the read-to-scf map(s) are already in place in the read2pad hash
# the padded read-to-contig alignment is the first (and only) assembled from map,
# which will be put in the pad2con hash /// entry via the oldalignToContig method 

# $self->oldalignToContig($paddedReadToContigMap);
 
        $self->{padtocon} = $assemble->[0];
        $counts->[2] = 1; # signal padded alignment as defined
        $self->align(); # calculate the unpadded alignments and put into the reads2con hash
my $read2con = $self->{read2con};
print "PADDED or single alignment detected @{$self->{padtocon}} (@{$read2con->{'000001'}})$break$break" if $DEBUG;
    }

    elsif ($assembled > 1 &&  $alignToCaf <= 1 && defined($self->{counterAlign})) {

print "UNPADDED alignment detected @{$self->{padtocon}} $break" if $DEBUG;
# it's UNPADDED data; read2pad can have only one (or none) alignments. Store alignments
# directly into the "read2con" hash of arrays; afterwards use alignToContig to update
# counters and do some testing
  
        my $read2con = $self->{read2con}; # for hash of arrays
        undef %$read2con;

        my $k = $self->{counterAlign} ? 1 : 0;
        my $l = 1 - $k;
print "align $self->{counterAlign} k=$k l=$l $break" if $DEBUG;

        undef my @rtoc;
        $counts->[1] = 0;
        foreach my $from (@$assemble) {
            $counts->[1]++; # number of alignment
            my $hash = sprintf("%06d",$counts->[1]);
         my @r2c = ($from->[2],$from->[3],$from->[0],$from->[1]); # positions interchanged (see align/dump)
            $read2con->{$hash} = \@r2c; # array reference
# keep track of padded read to contig mapping
            if ($counts->[1] == 1) {
# print "range  1: @$from $break" if $DEBUG;
                @rtoc = @$from;
            }
            else{
# print "ranges  : @$from ---- @rtoc $break" if $DEBUG;
# get the range on the contig and the starting position on the read
                $rtoc[$k] = $from->[$k] if ($from->[$k] < $rtoc[$k]);
                $rtoc[$l] = $from->[$l] if ($from->[$l] > $rtoc[$l]);
                $rtoc[2]  = $from->[2]  if ($from->[2]  < $rtoc[2]);
                $rtoc[3]  = $from->[3]  if ($from->[3]  > $rtoc[3]);
            }           
        }
# do here some test on the caf alignment if defined
        if ($alignToCaf == 1) {
            my $toCaf = $read2pad->{'000001'};
# print "align to caf: @rtoc <---> @$toCaf  $break" if $DEBUG;
            if ($toCaf->[0] > $rtoc[2] || $toCaf->[1] < $rtoc[3]) {
                $status->{diagnosis} .= "! Mismatch of alignToCaf and Assemble_from mappings : ";
                $status->{diagnosis} .= "$toCaf->[0] $toCaf->[1] <-> $rtoc[2]  $rtoc[3]$break";
                $status->{warnings}++;
            }
        }
# get the range of the padded read 
        $rtoc[3] = $rtoc[2] + abs($rtoc[1] - $rtoc[0]);
        $self->{padtocon} = \@rtoc;
print "PADDED alignment calculated @{$self->{padtocon}} $break$break" if $DEBUG;
undef @{ $self->{padtocon}} if $DEBUG; # test option


# counts->[1]++, counts->[2]=1 should updated; however we have to get the overal mapping
# range and return it as an array

    }
    elsif (!defined($self->{counterAlign})) {
        $status->{diagnosis} .= "! Missing alignment information$break";
        $status->{errors}++;
    }
    else {
# incompatible mappings
        $status->{diagnosis} .= "! Incompatible mappings: cannot decide ";
        $status->{diagnosis} .= "between padded and unpadded status$break";
        $status->{diagnosis} .= "? Has the assembly caf file been completely parsed$break";
        $status->{diagnosis} .= "assembled: $assembled aligned: $alignToCaf$break";
        $status->{errors}++;
    }

# returns the padded read to contig alignment

    return $self->{padtocon};
}

################################################################################

sub quality {
# define quality range (for independent check)
    my $self = shift;
    my $ql   = shift;
    my $qr   = shift;
    my $type = shift; # 0 for quality, 1 enabling window, 2 blocking window

    my $counts  = $self->{counts};
    my $status  = $self->{status};
    my $quality = $self->{quality};

# load range in internal storage.

    if ($type == 0 && $ql > 0 && $ql <= $qr) {
        $counts->[3] = $ql;
        $counts->[4] = $qr;
    }
    elsif ($type == 0) {
        $status->{inerrors}++;
        $status->{inputlog} .= "! Invalid quality range data: $ql $qr$break";
    }
    elsif ($type > 0) {
        my $next = @$quality || 0;
        $quality->[$next]->[0] = $ql;
        $quality->[$next]->[1] = $qr;
        $quality->[$next]->[2] = $type;
    }

# analyse the stored info ($type < 0 effective only if no quality range defined

# my $list = 0; $list = 1 if ($self->{names}->[0] eq 'J773Ca4.q2t');

    if (($counts->[3] <= 0 || $counts->[4] <= 0) && $type < 0) {
# use enabling window only if quality window absent
#print "quality test: counts @$counts $break" if $list;
        foreach my $window (@$quality) {
#print "quality test: window @$window $break" if $list;
	    if ($window->[2] == 1) { 
                $counts->[3] = $window->[0] if (!$counts->[3] || $counts->[3] < $window->[0]);
                $counts->[4] = $window->[1] if (!$counts->[4] || $counts->[4] > $window->[1]);
            }
        }
#print "after test: counts @$counts $break" if $list;
    }

# filter through masking ranges once initial estimate is made

    if ($counts->[3] > 0 && $counts->[4] > 0) {
        foreach my $window (@$quality) {
	    if ($window->[2] >= 2) { # blocking window
                if ($window->[0] <= $counts->[3] && $window->[1] >= $counts->[3]) {
                    $counts->[3] = $window->[1] + 1;
                }
                if ($window->[0] <= $counts->[4] && $window->[1] >= $counts->[4]) {
                    $counts->[4] = $window->[0] - 1;
                }
            }
        }
    }
}

################################################################################

sub addTag {
# store all tags encountered in this read in an array of hashes
    my $self  = shift;
    my $name  = shift; 
    my $sbase = shift;
    my $fbase = shift;
    my $info  = shift;

    my $status = $self->{status};
    my $rdtags = $self->{tags};

    undef my %newtag;
    $newtag{tagname}  = $name;
    $newtag{trpstart} = $sbase;
    $newtag{trpfinal} = $fbase;
    $newtag{taglabel} = $info;
    push @$rdtags, \%newtag;

    return @$rdtags+0;
}

################################################################################

sub etest {
# test/compare current edits with any existing previous edits (after isInDataBase)
    my $self = shift;

    undef my %oedits; # old edits

    my $nedits = $self->{edits}; # newedits
    my $counts = $self->{counts};
    my $status = $self->{status};
    my $result = $status->{errors};

# if counts[5] >= 0 this test has already been done 

    my $report = "++++ ReadMapper $self->{names}->[0] etest: @$counts $break";

    my $read_id = $self->isInDataBase(0,0);

    if ($read_id && $counts->[5] < 0) {

# find any existing edit instructions for this read in the database
# if there is, compare stored one with current one; deprecate if different

        &timer('etest',0) if $TIMER; 

        $counts->[5] = 0;
        my $edits = $EDITS->cacheRecall($read_id,{indexName=>'read_id'}); # look in cached data first
        $edits = $EDITS->associate ('hashrefs',$read_id,'read_id') if ($DBS && !$edits);
# edits is now a reference to an array of hashes with edit information
        if (ref($edits) eq 'ARRAY' && @$edits) {
            foreach my $edithash (@$edits) {
                $report .= "ReadMapper edit:$edithash->{base} $edithash->{'edit'} $edithash->{deprecated}$break";
                if ($edithash->{deprecated} ne 'Y') {
                    my $base = $edithash->{base};
                    $oedits{$base} = $edithash->{'edit'};
                    $counts->[5]++;
		}
            }

# compare stored edits with new specification

            my $isDifferent = 0;
            foreach my $base (keys (%oedits)) {
                my $edit = $nedits->{$base};
                $edit = "Not Defined" if (!defined($nedits->{$base}));
                if (defined($oedits{$base}) && 
                (!defined($nedits->{$base}) || $oedits{$base} ne $nedits->{$base})) {
                    $isDifferent++;
                    $status->{warnings}++;
                    $status->{diagnosis} .= "! Inconsistent edit base $base: ";
                    $status->{diagnosis} .= " old=$oedits{$base} new=$edit$break";
	        }
	    }
            foreach my $base (keys (%$nedits)) {
                if (!defined($oedits{$base})) {
                    $isDifferent++;
                    $status->{warnings}++;
                    $status->{diagnosis} .= "! Inconsistent edit base $base: ";
                    $status->{diagnosis} .= "newly defined edit=$nedits->{$base}$break";                    
		}
            }


            if ($counts->[0] != $counts->[5]) {
                $isDifferent = 99;
                $status->{warnings}++;
                $status->{diagnosis} .= "! Inconsistent number of edits: ";
                $status->{diagnosis} .= "old=$counts->[5] new=$counts->[0]$break";
            }
        # now deprecate the old edits if different from current lot
            if ($isDifferent) {
                $status->{diagnosis} .= "! Previous edits for read $read_id are to be deprecated$break";
                $counts->[5] = 0;
            }
            else {
                $status->{diagnosis} .= "  Edits for $read_id already in database$break";
            }
            print "$status->{diagnosis} $break" if $DEBUG;
	}
        &timer('etest',1) if $TIMER; 
    }

    elsif (!$read_id) {
        $status->{diagnosis} .= "! Read $read_id not found in READS database$break";
        $status->{errors}++;
    }

    return $counts->[5];
}

# output $counts->[5] is either 0 if no edits are found in database or previous
# edits have been deprecated, or > 0 if edits are already stored in database,
# or < 0 if the read has not been found in the READS database

################################################################################
# mtest: test mappings and compare with any existing mappings in earlier
#        generations;
################################################################################

sub mtest {
# test/compare currrent mappings with any existing previous mappings 
    my $self = shift;
    my $list = shift; # for test purposes

    undef my %oldmaps;

    my $read2con = $self->{read2con}; # hash reference to current read-to-contig alignment
    my $con2con  = $self->{contocon}; # hash reference to contig-to-contig alignments
    my $dbrefs   = $self->{dbrefs};
    my $counts   = $self->{counts};
    my $status   = $self->{status};
    my $gen      = $self->{series};

# if counts[6] >= 0 this test has already been done 

    my $read_id = $self->isInDataBase(0,0);

    my $REPORT = "${break}++++ MTEST for ReadMapper $self->{names}->[0] ($read_id) @$counts ++++$break";

    if ($read_id && $counts->[6] < 0) {
        &timer('mtest',0) if $TIMER;

        my @read2conKeys = sort keys %$read2con;

        my %generations;
        my %deprecation;
        my %cgeneration;
        my $notDeprecated; # protect against case of only deprecated alignments
        $counts->[6] = 0;
        $dbrefs->[3] = 0; # for contig in previous generation
        @$con2con = (0,0,0,0,0,0); # have all elements defined
        my $previous = ''; # for string list of earlier contigs
        my $isDifferent = 0;

# find any existing mappings for this read in the database (first try cached data)

        my $dbmaps = $RR2CC->cacheRecall($read_id,{indexName=>'mappings'});
        $dbmaps = $RR2CC->associate ('hashrefs',$read_id,'read_id',-1,'deprecated,label') if ($DBS && !$dbmaps); 
# dbmaps is a reference to an array of hashes with existing mapping info in the database
        if (ref($dbmaps) eq 'ARRAY' && @$dbmaps > 0) {
# there are mappings of this read in the cache/database; make an inventory for each generation
            $notDeprecated = 0;
            foreach my $map (@$dbmaps) {
                my $generation = $map->{generation};
                my $deprecated = $map->{deprecated};
                if ($deprecated ne 'Y') {
                    $generations{$generation}++;
                    $cgeneration{$generation} = $map->{contig_id};
                    $deprecation{$generation} = $deprecated;
                    $notDeprecated++; # there is at least one map
                }
                $REPORT .= "mapping: generation $generation deprecation $deprecated $break";
            }
            $REPORT .= "STEP 1 (generation profile): notDeprecated = $notDeprecated$break";
        }
        else {
            $REPORT .= "NO readmap found for read $read_id$break";
        }

# test the new map against the stored map, if any (in the lowest generation, 0 or 1);
# analyse the deprecation profile; if different deprecate.  

        if ($notDeprecated && @$dbmaps > 0) {
    # get lastly loaded previous generation (could be 0)
            @$gen = sort keys %generations;
            $dbrefs->[3] = $cgeneration{$gen->[0]}; # the most recent generation number
            $REPORT .= "Generations counted: @$gen; last linking contig=$dbrefs->[3]$break";
    # get deprecation profile over generations
            my $deprecation;
            foreach my $generation (@$gen) {
                $deprecation .= $deprecation{$generation};
            }
            $REPORT .= "Deprecation profile: $deprecation $break";

    # test this generation inventory: there are only three combinations allowed
    # - there is only 1 generation = 0 or 1: only 'N' allowed (because it must be the first 
    #    occurance of this read in any contig); if G=0, the read has been processed earlier
    # - there are two generations: either 0 and 1 or 1 and n; in both cases 'MN' is required
    # - there are three generations, 0, 1 and n where 'MMN' is required
    # any other combination indicates a corrupted structure of the mapping table

            undef my $error;
            if (@$gen == 1 && ($gen->[0] > 1 || $deprecation ne 'N')) {
                $error .= "assignment status $deprecation (must be N) " if ($deprecation ne 'N');
                $error .= "first generation = @$gen (should be 0 or 1)" if ($gen->[0] > 1);
    # repair generation not necessary (filling in generation 1 not meaningful)
    # repair deprecation: set flag to 'N' on mappings not equal 'Y'
                my $where = "read_id = $read_id AND generation = $gen->[0] AND deprecated != 'Y'";
                $RR2CC->update('deprecated','N','where',$where);
            }
            elsif (@$gen == 2 && (($gen->[1] != 1 && $gen->[0] != 1) || $deprecation ne 'MN')) {
                $error .= "deprecation sequence $deprecation (should be MN)" if ($deprecation ne 'MN');
                $error .= "generation sequence @$gen (0 1 or 1 n)" if ($gen->[1] != 1 && $gen->[0] != 1);
    # possible repair on generations: delete the generation between 1 and n (will be done by reaper)
    # possible repair on deprecation: NN to NY (to be implemented) 
            }
            elsif (@$gen == 3 && ($gen->[1] != 1 || $deprecation ne 'MMN')) {
                $error .= "deprecation sequence $deprecation (must be MMN)" if ($deprecation ne 'MMN');
                $error .= "generation sequence @$gen (0 1 n)" if ($gen->[1] != 1);
    # possible repair on generations: delete the generation between 1 and n (will be done by reaper)
    # possible repair on deprecation: MNN to MNY, NNN & NMN to NYY(to be implemented)
             }
            elsif (@$gen > 3) {
                $error .= "Too many mapping generations @$gen$break";
    # possible repair to generations: delete the generation between 1 and n (will be done by reaper)
    # possible repair to deprecation: MMMN will be done by reaper, M..N..N to M..NYYY
            }
    # none of the above errors is fatal (reaper will sort out repair)
            $REPORT .= "Errors in mappings of this read $read_id: $error$break$break" if $error;
            $REPORT .= "No errors detected$break" if !$error;                

# now collect the mapping profile for each generation and all contigs referred to by this read
# store the maps of the last previous occurrence of this read in @crange (i.e. generation 1)

            undef my %profile;
            foreach my $map (@$dbmaps) {
                my @lastmap;
                my $label = $map->{label};
                my $deprecated = $map->{deprecated};
                my $generation = $map->{generation};
# memorize the last previous mapping: should be generation 1 or possibly 0 or 0 & 1 for a new one
                my $consider = 0;
                $consider = 1 if ($generation == $gen->[0]);
# test the alignments against the previous one apart from the overall alignment (label = 20,21)
                if ($consider && $deprecated ne 'Y' && $label <= 11) {
                    $lastmap[0] = $map->{prstart};
                    $lastmap[1] = $map->{prfinal};
                    $lastmap[2] = $map->{pcstart};
                    $lastmap[3] = $map->{pcfinal};
                    @{$oldmaps{$map}} = @lastmap;
# get range on contig; $m ensures ascending order comparison
                    my $segment = $lastmap[3] - $lastmap[2];
                    my $m = 2; $m = 3 if ($segment < 0); # $m measures alignment inversion
                    $con2con->[0] = $lastmap[$m]   if (!$counts->[6] || $lastmap[$m]   < $con2con->[0]);
                    $con2con->[1] = $lastmap[5-$m] if (!$counts->[6] || $lastmap[5-$m] > $con2con->[1]);
                    if ($con2con->[2] && ($con2con->[2] != $m) && $segment) {
                        $status->{diagnosis} .= "! Inconsistent alignment orientation$break";
                        $status->{errors}++;
                        $isDifferent++; 
                    }
                    elsif ($segment) {
                        $con2con->[2] = $m; # temporary storage; left 0 if only single base segments
                    }
                    $counts->[6]++;
                }
                my $contig = $map->{contig_id};
                if ($label >= 10) {
                    my $status = 'S'; # 'Single' record (as stored in lastmap hash)
                    $status = 'F' if ($label > 11); # 'Final' record (not stored in lastmap hash)
                    $status = lc($status) if ($deprecated eq 'Y'); # lowercase 's' or 'f'
                    $deprecated = $status;
                }
                $profile{$contig} .= $deprecated if $consider; # register only generation 0 or 1
            }
            $REPORT .= "ReadMapper after profile loop: isDifferent=$isDifferent $break";

# test the alignment profiles for the read segments in each generation
# note: currently only the last previously loaded map is tested 

            foreach my $contig (keys %profile) {
                $previous .= ' ' if $previous;
                $previous .= $contig; 
                my $progress= "Testing mappings against contig $contig: $profile{$contig} $break";
# test contig for consistence: should be either 'Y..Yf', 's', 'N..NF','M..MF','[M..MF]+N..NF' or 'S'
# cleanup deprecated mappings in same generation alongside active mappings
                my $mapping = $profile{$contig};
                if ($mapping =~ /[MNS]/ && $mapping =~ s/[Yfs]//g) {
                    $status->{diagnosis} .= "! Redundant deprecated mappings from contig ";
                    $status->{diagnosis} .= "$contig to read $read_id (to be) removed$break";
                    my $maps = "read_id=$read_id and contig_id=$contig and generation=0 and deprecated='Y'";
                    $RR2CC->delete('where',$maps);
                }

                if ($mapping =~ /^(Y{2,}f|s)$/) {
                    $progress .= "Deprecated mapping of read $read_id ";
                    if ($gen->[0] == 0) {
                        $progress =~ s/Dep/Unexpected dep/;
                        $progress .= " found for generation 0";
                    }
                } 
                elsif ($mapping =~ /^([NM]{2,}F|S)$/) {
                    $progress .= "Standard mapping of read $read_id ";
                }
# extra here? e.g.  /^(M{2,}FN{2,}F)|SS)$/   /^(N{2,}FY{2,}f)|Ss)$/ if both generation 0 and 1 tested
                else {
                    $progress .= "Incomplete or inconsistent mapping of read $read_id ";
                    $isDifferent = 1; # force deprecation of all current mappings
# this condition is fatal for generation 0: it occurs when a previous assembly load has not been finallized
                    if ($gen->[0] == 0) {
                        $status->{diagnosis} .= $progress;
                        $status->{errors}++; 
                    }
                }
                $REPORT .= "$progress ($mapping) to contig $contig$break";
	    }
            $REPORT .= "ReadMapper after contig loop : isDifferent=$isDifferent previous=$previous$break";
	}
        elsif (@read2conKeys > 0) {
             $isDifferent = 1; # It's the first mapping of this read: force 'N' label
        }

        $REPORT .= "STEP 2 (deprecation profile) : isDifferent = $isDifferent previous = $previous$break";

# compare previously stored map with new specification (if any; should be identical apart from shift)
# compare ranges on contigs and test co-alignments for consistency

        if ($counts->[6]) {  #?        if ($counts->[6] && !$isDifferent) {

	    $REPORT .= "Testing existing ($counts->[6]) alignments against $counts->[1] new ones $break";

            if ($counts->[1] > 0) {
# test the previous alignments against the current data 
                my $m = $con2con->[2];
# get range for current (new) readmap to the new contig
                my $first = 1;
                $con2con->[4] = 0;
                my $alignments = 0;
                foreach my $alignment (@read2conKeys) {
                    my @thismap = @{$read2con->{$alignment}};
                    my $segment = $thismap[3] - $thismap[2];
                    my $l = 2; $l = 3 if ($segment < 0);
                    $con2con->[2] = $thismap[$l]   if ($first || $thismap[$l]   < $con2con->[2]);
                    $con2con->[3] = $thismap[5-$l] if ($first || $thismap[5-$l] > $con2con->[3]);
                    $con2con->[4] = 1 if ($segment && $l != $m); # signal alignment inversion to ContigBuilder
                    $alignments++; # total of padded alignments
                    $first = 0;
                }
                $REPORT .= "! $con2con->[4] alignment inversion(s) detected$break" if $con2con->[4];

                my $oldrange = $con2con->[1] - $con2con->[0];
                my $newrange = $con2con->[3] - $con2con->[2];

                $REPORT .= "ReadMapper read nr $dbrefs->[0] aligned to previous contig(s): $previous$break";
                if ($alignments == $counts->[6] && $oldrange == $newrange) {
# numbers and overall range are identical; now test each individual mapping segment
                    undef my $offset;
                    foreach my $alignment (@read2conKeys) {
# get range for current (new) readmap to the new contig
                        my @thismap = @{$read2con->{$alignment}};
                        $REPORT .= "Testing alignment @thismap$break";
                        my $found = 0; 
                        my $error = 0;
                        my $progress = '';
# find the matching alignment on the read in previous map, then compare contig alignments 
                        foreach my $map (keys (%oldmaps)) {
                            my @lastmap = @{$oldmaps{$map}};
                            if ($lastmap[0] == $thismap[0] && $lastmap[1] == $thismap[1]) {
                                $found++; # there should be only one alignment
# get the "shift" between the contig maps; if inverted, use mirror image
                                if ($con2con->[4]) {
                                    $lastmap[2] = -$lastmap[2];
                                    $lastmap[3] = -$lastmap[3];
                                }
# the offset between the maps should be identical for all mapped read segments
                                my $shift = $thismap[2] - $lastmap[2];
                                $offset = $shift if !defined($offset);
                                $error = $map if ($shift != $offset);
                                $shift = $thismap[3] - $lastmap[3];
                                $error = $map if ($shift != $offset);
# register progress (possibly used below)
                                $progress .= "old alignment: @{lastmap} ";
                                $progress .= "new alignment: @{thismap} ";
                                $progress .= "reversal detected" if $con2con->[4];
                                $progress .= $break;
                            }
			}

                        if ($error) {                     
# the mapping range does not match
                            $isDifferent++;
                            $REPORT .= "! Inconsistent alignment(s), ";
                            $REPORT .= "(old: @{$oldmaps{$error}}, new: @{thismap})$break";
                            $REPORT .= $progress; # add details for this map
 	                } 
                        elsif ($found == 0) {
# no matching alignment found
                            $isDifferent++;
                            $REPORT .= "! NO matching alignment found for @{thismap}$break";
                        }
                        elsif ($found > 1) {
                            $isDifferent++;
                            $REPORT .= "! Multiple alignments ($found) for @{thismap}$break";
                        }
         	    }
                    $con2con->[5] = $offset; # register shift between contigs
                }
  	        elsif ($counts->[1] != $counts->[6]) {
# the maps are different in number of alignments and possibly in total range covered
                    $status->{warnings}++;
                    $REPORT .= "! Inconsistent number of alignments: in database ";
                    $REPORT .= "$counts->[6] new: $counts->[1]$break";
                    $isDifferent = 99;
                }
                else {
# the maps are different in total range covered
                    $REPORT .= "! Inconsistent alignment cover (new: $newrange, old:$oldrange)$break";
                    $isDifferent = 99;
                }
            } 
            else {
# there is no current (new) mapping info ($counts->[1]=0)
                $status->{errors}++;
                $REPORT .= "There is mapping info in database but no new info$break";
                $isDifferent = 99;
            }
        }

        $REPORT .= "STEP 3 (after alignment test): isDifferent = $isDifferent previous = $previous$break";

# now deprecate the old mappings if they are different from current ones

        my $progress;
        if ($isDifferent && $previous) {
# the alignments to a previous contig are different from those to the new contig; old 
# alignments have to be superseded. However, if the previous contig was in generation 0,
# the error flag is set, since this indicates that something went seriously wrong with 
# the generation incrementation of the previous assembly
            if ($gen->[0] == 0) {
                $status->{diagnosis} .= "Incompatible assembly generations: update NOT DONE$break";
                $status->{errors}++;
	    }
       	    else {
                &deprecate($self);
                $progress .= " New alignments of this read $dbrefs->[0] to the new contig:";
                $progress .= " $con2con->[0]-$con2con->[1] to $con2con->[2]-$con2con->[3] $break";
            }
            $con2con->[4] += 2; # signal deprecated readmap to ContigBuilder
        }
        elsif ($isDifferent && !$previous) {
# this alignment has not been seen before
            $progress = " First time assembly of read $dbrefs->[0] $break";
            $self->{marked} = 'N';
            $counts->[6] = 0;
        }
        elsif (@read2conKeys) {
# the alignments to the previous contig are identical to those to the new contig, apart from a (possible) shift;
            $progress = "Alignments are identical to those to a contig in generation $gen->[0]$break";   
            $self->{marked} = 'M' if ($gen->[0]  > 0); # mark for delete by reaper
            $self->{marked} = 'X' if ($gen->[0] == 0); # mark as already stored for new generation
        }
        else {
# the read is completely empty (after alignment)
            &deprecate($self) if $counts->[6]; # deprecate existing data
            $con2con->[4] = -1; # signal empty mapping to ContigBuilder
        }
        $status->{diagnosis} .= $progress if $progress;

        $REPORT .= $progress.$break;
        &timer('mtest',1) if $TIMER;
    }
    elsif (!$read_id) {
        $status->{diagnosis} .= "! Read $read_id not found in READS database$break";
        $status->{errors}++;
    }

#    print $REPORT;

    return $counts->[6];
}

# output $counts->[6] is either 0 if no alignment data are found in database or
# if previous alignment data have been deprecated, or > 0 if alignments are 
# already stored in database (in which case $dbrefs->[3] has the contig_id in which
# it first occurred), or < 0 if the read has not been found in the READS database

################################################################################

sub deprecate {
    my $self = shift;
    my $text = shift;

    my $counts = $self->{counts};
    my $status = $self->{status};
    my $update = 0;

    if (my $read_id = $self->isInDataBase(0,0)) {

# deprecate alignments to contigs of previous generations; only first ('N')
# suffices because mappings marked 'M' will be removed with &reaper afterwards

        return if ($self->{marked} eq 'N'); # already done previously

        $RR2CC->update('deprecated','Y','where',"read_id = $read_id AND deprecated = 'N'");

        $status->{diagnosis} .= "! Previously archived alignments for read $read_id are deprecated";
        $status->{diagnosis} .= " ($text)" if $text;
        $status->{diagnosis} .= "$break"; 
        $status->{warnings}++;

# signal no (valid) data in database 

        $self->{marked} = 'N'; # treat as new read appearing for the first time
        $counts->[6] = 0;      # will suppress repeat of test and force dump
        $update++;
    }
    elsif (!$read_id) {
        $status->{diagnosis} .= "! Read $read_id not found in READS database$break";
        $status->{errors}++;
    }

    return $update;
}

################################################################################

sub reporter {
    my $self = shift;
    my $home = shift;

    my $report = $self->{report};
    if ($report || $home) {
        print STDOUT "${break}REPORTER";
        print STDOUT " (Origin $home)" if defined($home);
        print STDOUT "$break$report$break" if $report;
    }
}

################################################################################
# This sub dumps the current mappings to database tables (after testing)
################################################################################

sub dump {
# dump edits and mapping in database tables READEDITS and READS2CONTIG
    my $self     = shift;
    my $contig   = shift; # contig ID obtained in ContigBuilder
    my $assembly = shift; # assembly number of the contig

# edit and mapping data can only be dumped if read is in READS and contig exists

    my $dbrefs   = $self->{dbrefs};
    my $status   = $self->{status};
    my $counts   = $self->{counts};
    my $read2con = $self->{read2con};
    my $edits    = $self->{edits};
    my $names    = $self->{names};
    my $marker   = $self->{marked};

$DEBUG = 0; # $DEBUG=1 if ($self->{names}->[0] =~ /mal4N18g10\.p2co17frA/);
print "++++ DUMP for ReadMapper $self->{names}->[0] ($self) counts: @$counts ++++$break" if $DEBUG;

    &timer('RM dump',0) if $TIMER; 

# reinitialize error status

    $status->{errors}    = $status->{inerrors};
    $status->{diagnosis} = $status->{inputlog};
    $status->{warnings}  = 0;

# test validity of alignments; go on if no inconsistencies found
 
    if ($self->align() == 0 && $contig) {

# alignment tested okay: all alignments consistent and contig ID defined
# only proceed if the read is actually present in READS, i.e. reads_id exists

        if (my $read_id = $self->isInDataBase(0,0)) {

$DEBUG = 0; # $DEBUG = 1 if ($read_id == 73701);

    # test edits against possible exiting data in READEDITS
print "ETEST for  ReadMapper $self->{names}->[0]$break" if $DEBUG;
	    $self->etest();

    # counts->[5] = 0 (set in etest) if new edits have to be put into database 

            if ($counts->[0] && !$counts->[5]) {
        # deprecate any existing previous edits for this read
                $EDITS->update('deprecated','Y','read_id',$read_id);
        # now write the edits to database
                foreach my $edithash (keys (%$edits)) {
                   (my $base = $edithash) =~ s/^[0]+//;
        # (NOTE: the next blocks should be replaced by one call to the database)
                    my $edit = $edits->{$edithash};
                    if (!$EDITS->newrow('read_id',$read_id,'deprecated','X')) {
                        $status->{diagnosis} .= "! Failed to add edit entry";
                        $status->{diagnosis} .= " $read_id $base $edit to EDITS";
                        $status->{errors}++;
                    }
                    else {
                        $EDITS->update('base',$base);
                        $EDITS->update('edit',$edit);
                        $EDITS->update('deprecated','N');
                        $counts->[5]++;
                    }
                }
            }

    # test alignment data against possible existing data in READS2CONTIG

            $self->mtest();

    # we store all readmaps of the current generation; afterwards we have to
    # remove copies marked 'M' in previous generation, which leaves us with
    # two copies: the one mapped to the contig in which it first occurred, and
    # the one in the current generation 
    # marker set to X indicates that mappings have been loaded for generation 0
    # previously during an earlier run of a loading script using this module

$DEBUG = 0; # $DEBUG=1 if ($self->{names}->[0] =~ /mal4N18g10\.p2co17frA/);
print "++++ after MTEST for ReadMapper $self->{names}->[0]  counts: @$counts ++++$break" if $DEBUG;

            if ($counts->[1] && $marker ne 'X') {

        # build and add the overall mapping to a table of several alignments

                my $aligntype = 1; # default single alignment in this read
                my @read2conKeys = sort keys %$read2con;
                if (@read2conKeys > 1) {
                   $aligntype = 0; # multiple alignments
                    undef my @range;
                    my $l = 3 - $self->{counterAlign}; my $k = 5 - $l; # 2,3 or 3,2
                    foreach my $alignment (@read2conKeys) {
                        my $block = $read2con->{$alignment};
                        @range = @$block  if !@range;
                        $range[0]  = $block->[0]  if ($block->[0]  < $range[0]);
                        $range[1]  = $block->[1]  if ($block->[1]  > $range[1]);
                        $range[$k] = $block->[$k] if ($block->[$k] < $range[$k]);
                        $range[$l] = $block->[$l] if ($block->[$l] > $range[$l]);
                    }
                    $read2con->{'999999'} = \@range;
		    push @read2conKeys, '999999';
                }

#                my $clone_id = $self->{clone} || 0;

#$self->list(1) if $DEBUG;
                &timer('RM newline(s)',0) if $TIMER;
                foreach my $alignment (@read2conKeys) {
# print "alignment key $alignment$break";
                    my @block = @{$read2con->{$alignment}};
                    if (@block != 4) {
                        $status->{diagnosis} .=  "invalid alignment $alignment: @{block}$break";
                        $status->{errors}++;           
                    }

                    else {
                # define label: 0 for one in a series; 1 for a single record; 2 for end series
                        my $label = $aligntype;
                        $label = 2 if ($alignment eq '999999');     # last of a series 
                        $label = $label*10 + $self->{counterAlign}; # 1 if aligned against contig
                # assemble arrays
                        undef my @columns;
                        undef my @cvalues;
                        push @columns, 'contig_id' ; push @cvalues, $contig;
                        push @columns, 'pcstart'   ; push @cvalues, $block[2];
                        push @columns, 'pcfinal'   ; push @cvalues, $block[3];
                        push @columns, 'read_id'   ; push @cvalues, $read_id;
                        push @columns, 'prstart'   ; push @cvalues, $block[0];
                        push @columns, 'prfinal'   ; push @cvalues, $block[1];
                        push @columns, 'label'     ; push @cvalues, $label;
                        push @columns, 'assembly'  ; push @cvalues, $assembly; # ?
#                        push @columns, 'clone'     ; push @cvalues, $clone_id; # ?
                        push @columns, 'generation'; push @cvalues, 0;
                        push @columns, 'deprecated'; push @cvalues, $marker;

                &timer('RM newrow',0) if $TIMER;
                        if ($RR2CC->newrow(\@columns,\@cvalues)) {
                            if ($status->{diagnosis} !~ /\badded/) {
                                $status->{diagnosis} .= "Alignments to contig $contig added: ";
print "Alignments @cvalues to contig $contig (@block) added$break" if $DEBUG;
                            }
                            $status->{diagnosis} .= "x";
                        }
                        else {
                            $status->{diagnosis} .= "! Failed to add alignment $alignment to contig";
                            $status->{diagnosis} .= " $contig (@block) to READS2CONTIG$break";
print "$status->{diagnosis} $break $RR2CC->{lastquery} $break $RR2CC->{qerror} $break";
                            $status->{errors}++;
                        } 
                &timer('RM newrow',1) if $TIMER;
                        $counts->[6]++;
# and finally update assembly in READS2ASSEMBLY ??? insert afterwards?
                &timer('RM assembly',0) if $TIMER;
#                        $RR2AA->update('assembly',$assembly,'read_id',$read_id);
#                        $RR2AA->newrow('read_id',$read_id,'assembly',$assembly,1);
                &timer('RM assembly',1) if $TIMER;
                    }
                } 
                &timer('RM newline(s)',1) if $TIMER;
                $status->{diagnosis} .= "$break";
    # here you could do the cleanup of marked mappings of previous generations
                if ($piecemealwise) {
                    my $where = "read_id=$read_id && generation>0 && deprecated='M'";
                    $RR2CC->delete('where',$where);
                }
            }
            elsif ($counts->[1] && $marker eq 'X') {
                $status->{diagnosis} .= "Generation 0 alignments of read $read_id to contig ";
                $status->{diagnosis} .= "$dbrefs->[3] ($contig) are currently stored: dump ";
                $status->{diagnosis} .= "SKIPPED$break";
                $status->{warnings}++; 
# print "$status->{diagnosis}";          
            }
            elsif (!$counts->[1]) {
                $status->{diagnosis} .= "! No CAF alignment defined$break";
                $status->{errors}++;           
            }
            else {
                $status->{diagnosis} .= "Unspecified error in read $read_id: $counts->[1], ";
                $status->{diagnosis} .= "$counts->[2], $dbrefs->[3] $contig$break";
                $status->{errors}++;           
            }
        }
        $dbrefs->[2] = $contig; # memorise current contig for list purposes  
    }
    elsif (!$contig) {
        $status->{diagnosis} .= "! dump failed because of undefined contig reference$break";
        $status->{errors}++;           
    }
    else {
        $status->{diagnosis} .= "! dump failed because of align errors$break";
        $status->{errors}++;           
    }

    &timer('RM dump',1) if $TIMER; 

print "$self->{report}" if $DEBUG;

    if (&status($self,0)) {
        return 0; # failed to dump the alignments or the edits
    }
    elsif (!$dbrefs->[3]) {
        return 1; # alignments (and edits) have been written to database fro this new read
    }
    else {
        return 2; # this read was found to be aligned to contig $dbrefs->[3]
    }
}

###############################################################################
# private function to test alignments
###############################################################################

sub align {
# test if all information is present, then test the mapping itself
    my $self = shift;

    my $counts   = $self->{counts};
    my $padtocon = $self->{padtocon};
    my $read2pad = $self->{read2pad};
    my $read2con = $self->{read2con};
    my $status   = $self->{status};
    my $dbrefs   = $self->{dbrefs};

    &timer('align',0) if $TIMER;

# if the read2con hash is defined, this method has already been executed 

    return 0 if ($read2con && keys %$read2con); # prevent repeat run

    undef %$read2con;

    my $error = $status->{errors};
 
# count [1]=number of maps, [2]=alignment defined, [4]=quality right
$DEBUG = 0; # $DEBUG=1 if ($self->{names}->[0] =~ /mal4N18g10\.p2co17frA/);
print "++++ ALIGN for ReadMapper $self->{names}->[0] ($self) (counts = @$counts)++++$break" if $DEBUG;

    if ($counts->[1] > 0 && $counts->[2] == 1 && ($counts->[4] > 0 || $counts->[3] > 0)) {
    &timer('align',0) if $TIMER;
# get shift between padded read and contig and its direction
        my ($cntgs, $cntgf, $padds, $paddf) = @{$padtocon};
# ensure ordering on (padded) read is increasing
       ($cntgf, $cntgs, $paddf, $padds) =  @{$padtocon} if ($padds > $paddf);
# determine orientation of mapping on contig
        my $sign = 1.0;
        $sign = -1.0 if ($cntgs > $cntgf);
# get transformation between padded read and contig y = shifts + sign*x
        my $shifts = $cntgs - $sign*$padds;
        my $shiftf = $cntgf - $sign*$paddf;

# test overal quality range for this contig
       
        my $ql = $counts->[3];
        my $qr = $counts->[4];
        my $qlength = $qr - $ql; # quality range
        my $rlength = $paddf - $padds; # read (and contig) section length

        if ($rlength < $qlength) {
# warning, info only,  to be printed only in case of other warnings or errors
            $status->{diagnosis} .= "  Quality range $ql - $qr not fully covered $padds - $paddf$break";
        } 
        elsif ($rlength > $qlength) {
# warning always printed: may indicate more serious problem with mapping
            $status->{warnings}++;
            $status->{diagnosis} .= "! Mapped range @{$padtocon}";
            $status->{diagnosis} .= " overflows quality range $ql - $qr$break";
        }

        if (int($shifts-$shiftf) != 0) {
            $status->{errors}++; # shifts must be the same
            $status->{diagnosis} .= "! Corrupted (padded) read-to-contig mapping:";
            $status->{diagnosis} .= " @{$padtocon}, shifts $shifts & $shiftf$break";
        }
        else {
            my $outside = 0;
            foreach my $number (sort keys (%$read2pad)) {
                my ($pstart, $pfinal, $rstart, $rfinal, @dummmy) = @{$read2pad->{$number}};
        # shift between padded read segment and read segment on trace file
                my $shift = $pstart - $rstart;
        # get clipping window for un-padded read section by backtransforming from padded read
                my $wndws = $padds - $shift;
                my $wndwf = $paddf - $shift;
                $rstart = $wndws  if ($rstart < $wndws);
                $rfinal = $wndwf  if ($rfinal > $wndwf);

                if ($rstart <= $rfinal) {
        # positioning is okay, now get mapped range by applying forward translation
                    $read2con->{$number}->[0] = $rstart;                 # unpadded
                    $read2con->{$number}->[1] = $rfinal;
                    $pstart = $rstart + $shift;                          # padded
                    $pfinal = $rfinal + $shift;
                    $read2con->{$number}->[2] = $shifts + $sign*$pstart; # contig
                    $read2con->{$number}->[3] = $shifts + $sign*$pfinal;   
        # now the range $pstart-$pfinal must preferably be inside the quality range
                    if ($pstart < $ql || $pfinal > $qr) {
                        $status->{warnings}++;
                        $status->{diagnosis} .= "! Alignment block $number: $rstart-$rfinal";
                        $status->{diagnosis} .= " (padded: $pstart-$pfinal) outside";
                        $status->{diagnosis} .= " quality window $ql-$qr$break" if ($qr >= $ql);
                        $status->{diagnosis} .= " quality window (vector covers window)$break" if ($qr< $ql);
                    }
print "Alignment block $number to be added: $rstart-$rfinal $break" if $DEBUG;
                }
                else {
                   ($pstart, $pfinal, $rstart, $rfinal, @dummmy) = @{$read2pad->{$number}}; # recall
                    $status->{warnings}++;
                    $status->{diagnosis} .= "! Alignment block $number: $rstart-$rfinal";
                    $status->{diagnosis} .= " (padded: $pstart-$pfinal) outside";
                    $status->{diagnosis} .= " contig window $padds-$paddf$break";
		    $outside++;
                }
            }
# test if there are any intervals left
            if (keys %$read2con == 0) {
                $status->{errors}++;
                $status->{diagnosis} .= "NO read segments found inside contig range$break";
            }
            elsif ($outside) {
                $status->{warnings}++;           
                $status->{diagnosis} .= "$outside read segments outside contig range$break";
            }
        }
    &timer('align',1) if $TIMER; 
    }
    else {
# error in alignment data
        $status->{errors}++;
        $status->{diagnosis} .= "! Missing mapping information, counts:@{$counts}$break";
        $status->{diagnosis} .= "  Missing CAF alignment(s)$break" if ($counts->[1] == 0);
        $status->{diagnosis} .= "  Missing or invalid alignment to contig$break" if ($counts->[2] != 1);
        $status->{diagnosis} .= "  Invalid or missing Quality Window$break" if ($counts->[4] == 0);
    }

    return $status->{errors} - $error; # will be 0 if no errors
}

################################################################################
# 
################################################################################

sub list {
# short or long list of current status
    my $self = shift;
    my $list = shift;

    my $count    = $self->{counts};
    my $names    = $self->{names};
    my $edits    = $self->{edits};
    my $dbrefs   = $self->{dbrefs};
    my $read2pad = $self->{read2pad};
    my $padtocon = $self->{padtocon};

    print STDOUT "ReadMapper for $names->[0] list:";
    print STDOUT "$count->[0] Edit(s) and $count->[1] Mapping(s)$break";

    if (defined($list) && $list > 0) {
        foreach my $base (sort keys (%$edits)) {
            print STDOUT "edit on $base: $edits->{$base}$break";
        }

        foreach my $number (keys (%$read2pad)) {
            print STDOUT "Map: @{$read2pad->{$number}}$break";
        }
    }
    print STDOUT "Read_id = $dbrefs->[0]; "    if ($dbrefs->[0]);
    print STDOUT "Pending id = $dbrefs->[1]; " if ($dbrefs->[1]);
    print STDOUT "mapped to contig $dbrefs->[2]: @{$padtocon}$break" if ($dbrefs->[2]);
    print STDOUT "linked to earlier contig $dbrefs->[3]$break"       if ($dbrefs->[3]);

    return status ($self,2);
}

###############################################################################

sub status {
# return the hash reference to a named read in the class hash table "reads"
    my $self = shift;
    my $list = shift;

    my $names  = $self->{names};
    my $status = $self->{status};

    my $errors    = $status->{errors};
    my $warnings  = $status->{warnings};
    my $diagnosis = $status->{diagnosis};

    if (defined($list) && $list > 0) {
        my $fonts = &fonts;
        if ($errors || $warnings) {
            my $font = $fonts->{b}; 
            $font = $fonts->{o} if $errors;
            print STDOUT "Status of ReadMapper $names->[0]: ";
            print STDOUT "$font $errors errors $fonts->{e}, $warnings warnings $break";
            print STDOUT "$diagnosis $break" if ($list > 1);
        }
        elsif ($list > 1) {
            print STDOUT "Status of ReadMapper $names->[0]:$fonts->{g} passed $fonts->{e} $break";
        }
        print STDOUT "$self->{report} $break"  if ($list > 2 && $self->{report});
    }

    return $errors;
}

###############################################################################

sub reset {
# resets the errors and warning counters
    my $self = shift;

    my $status = $self->{'status'};
    $status->{errors}    = $status->{inerrors};
    $status->{diagnosis} = $status->{inputlog};
    $status->{warnings}  = 0;
}

###############################################################################

sub delete {
# delete the hashes of this read (irreversible) and remove from reads table
    my $self = shift;

    my $name = $self->{names};
    my $read = $name->[0];

    foreach my $key (keys (%$self)) {
        my $hash = $self->{$key};
        undef %$hash if (ref($hash) eq "HASH");
        undef @$hash if (ref($hash) eq "ARRAY");
    }

    undef %$self;

    delete $ReadMapper{$read};
}

###############################################################################
# Class sub-routines
###############################################################################

sub lookup {
# return the reference to a ReadMapper instance in the class table
    my $self = shift;
    my $read = shift;

# if $read is a name,   return ref to named read 
# if $read is a number, return ref of that number in the table  

    return \%ReadMapper if !$read;

    &timer('lookup',0) if $TIMER; 

    my $result = $ReadMapper{$read};

    if (!$result && !($read =~ /[a-z]/i) && $read =~ /\d+/) {

        foreach my $name (sort keys (%ReadMapper)) {
            if (--$read == 0) {
                $result = $ReadMapper{$name};
                last;
            }
        }
    }

    &timer('lookup',1) if $TIMER; 

    return $result;
}

##################################################################################
# retire and reap obsolete or older readmaps
##################################################################################

sub retire {
# to be invoked after generation 0 is completed: retire reads in G1 but not in G0
    my $self     = shift;
    my $assembly = shift || 0;

    my $retired = 0;

    my $query  = "select G1.read_id from <self> as G1 left join <self> as G0 ";
    $query .= "on G1.read_id = G0.read_id where G0.label >= 10 and G1.label >= 10 and ";
    $query .= "G0.assembly = $assembly and G1.assembly = $assembly and ";
    $query .= "G0.generation = 0 and G1.generation = 1 and ";
    $query .= "G0.read_id = NULL";

    my $hashes = $RR2CC->query($query,{traceQuery=>0});
print "retire query $RR2CC->{lastQuery}$break";
print "retire hashes $hashes \n";
    if ($hashes && ref($hashes) eq 'ARRAY') {
my $length=@$hashes; print "retire hashes= $hashes $length $break"; print "retire hashes: @$hashes \n";
	$retired = @$hashes;
        foreach my $hash (@$hashes) {
            $hash = $hash->{read_id};
        }
print "retire: readid: @$hashes \n";
# retire: set deprecated to 'X' where read_id in (join ',',@$hashes) and generation=1
#        $RR2CC->update('deprecated','X','read_id',$hashes) if $assembly;     
    }

    $retired;

# NEW setup tests
#      select distinct(read_id) from READS2CONTIG, CONTIGS2CONTIG where
#      READS2CONTIG.contig_id = CONTIGS2CONTIG.oldcontig and
#      CONTIGS2CONTIG.generation=0;

#      select distinct read_id,deprecated from READS2CONTIG, CONTIGS2CONTIG where
#      READS2CONTIG.assembly=1 and READS2CONTIG.deprecated in ('M','N') and label>=10 and
#      READS2CONTIG.contig_id=CONTIGS2CONTIG.oldcontig and CONTIGS2CONTIG.generation=0;

#ysql> select distinct read_id,deprecated from READS2CONTIG, CONTIGS2CONTIG where
#   -> READS2CONTIG.assembly=1 and label>=10 and
#   -> READS2CONTIG.contig_id=CONTIGS2CONTIG.newcontig and CONTIGS2CONTIG.generation=0;
}

##################################################################################

sub reaper {
# cleanup all marked readmaps in older generations
    my $self     = shift;
    my $assembly = shift || 0;

# leave generation  1 untouched! (i.e. do reaper after ageByOne)

    my $where = "generation > 1 AND deprecated = 'M' AND assembly=$assembly";
print "reaper: delete from READS2CONTIG where $where $break";
    $RR2CC->delete('where',$where) if ($assembly > 0);
}

##################################################################################

sub mapAnalysis {
# analyse maps and chemistry (ad hoc application for the moment) 
    my $self = shift;
    my $opts = shift;

    my %options = (minimum => 100, list => 0, normalise => 1);
    $READS->importOptions(\%options,$opts);

    my $CHEMISTRY = $READS->spawn('CHEMISTRY');

# first find the chemistry counts on READS

    my $query = "select chemistry, count(chemistry) as total from <self> group by chemistry";
    my $hashes = $READS->query($query,{traceQuery=>0}) || return 0;
    my %counts;
    foreach my $hash (@$hashes) {
        $counts{$hash->{chemistry}} = $hash->{total};
    }

# go through each chemistry and get the reads and map counts

    my %histogram = ( '01'=>0, '02'=>0, '03'=>0, '04'=>0, '05-06'=>0, '07-09'=>0,
                      '10-15'=>0, '16-20'=>0, '21-30'=>0, '31-50'=>0, '>50'=>0);
    my $reporth = "    ";
    foreach my $key (sort keys %histogram) {
        $reporth .= sprintf "%7s" , $key;
    }
    $reporth .= "$break$break";
    my $reporta = '';
    my $database = $READS->{database};
    foreach my $chemistry (sort { $a <=> $b } keys %counts) {
# apply minimum number quillotine
        my $chname = $CHEMISTRY->associate('identifier',$chemistry,'chemistry');
        $reporta .= "Chemistry $chname ($chemistry: $counts{$chemistry})$break";
        next if ($options{minimum} && $counts{$chemistry} < $options{minimum});
# get a list of all reads and a count of the maps for this chemistry
        $query  = "select count(R2C.read_id) as total, R2C.read_id from ";
        $query .= "$database.READS2CONTIG as R2C, $database.READS as RDS ";
        $query .= "where R2C.label<20 and R2C.read_id=RDS.read_id and ";
        $query .= "RDS.chemistry=$chemistry group by read_id";
print "$query\n" if ($options{list} > 1);
        my $readids = $RR2AA->query($query,{traceQuery=>0}) || next;
        next unless (ref($readids) eq 'ARRAY');
# collate the data
        my $sum = 0;
        foreach my $key (sort keys %histogram) {
            $histogram{$key} = 0;
        }
        foreach my $read (@$readids) {
            my $count  = $read->{total};
            my $readid = $read->{read_id};
            if ($count <= 4) {
                $histogram{"0$count"}++;
            }
            elsif ($count <= 6) {
                $histogram{"05-06"}++;
            }
            elsif ($count <= 9) {
                $histogram{"07-09"}++;
            }
            elsif ($count <= 15) {
                $histogram{"10-15"}++;
            }
            elsif ($count <= 20) {
                $histogram{"16-20"}++;
            }
            elsif ($count <= 30) {
                $histogram{"21-30"}++;
            }
            elsif ($count <= 50) {
                $histogram{"31-50"}++;
            }
            else {
                $histogram{">50"}++;
            }
            $sum += $count;
        }
# printout
        my $total = scalar(@$readids); 
        my $average = $sum / $total;
        $reporta .= "Chemistry $chemistry : average number of maps per read = ";
        $reporta .= "$average ($sum / $total)$break$break";
        $reporth .= sprintf "%3d:", $chemistry;
        foreach my $key (sort keys %histogram) {
            $histogram{$key} = int($histogram{$key}*100/$total+0.5) if $options{normalise};
            $reporth .= sprintf "%7d" , $histogram{$key};
        }
        $reporth .= "$break$break";
    }

    return $reporta.$reporth;
}

################################################################################
# The next 3 subs test if the read is already in READS or perhaps in PENDING
################################################################################

sub isInDataBase {
# test where the read is listed in the ARCTURUS database
    my $self     = shift;
    my $dbprobe  = shift; # probe database if read not in cached table sections
    my $append   = shift; # add the read to PENDING database if not found
    my $assembly = shift; # assembly to be assigned read in PENDING (if added)

    my $names  = $self->{names};
    my $dbrefs = $self->{dbrefs};
    my $status = $self->{'status'};

# if the read is not in the READS database test for it in PENDING table

    &timer('isInDataBase',0) if $TIMER;

    if (!$dbrefs->[0] || !$dbrefs->[1]) {

       ($dbrefs->[0], $dbrefs->[1]) = $self->inDataBase($names->[0],$dbprobe,$append,$assembly);

        if ($dbrefs->[0] && !$dbrefs->[1]) {
            $dbrefs->[1] = -1; # suppress subsequent search as read is in READS
        } 
        elsif (!$dbrefs->[0] && $dbrefs->[1]) {
            $dbrefs->[0] = -1; # suppress subsequent search as read is in PENDING
        }
        elsif ($dbprobe) {
# the read could not be added to the pending list
            $dbrefs->[0] = -1;
            $dbrefs->[1] = -1;
        }
    }

    &timer('isInDataBase',1) if $TIMER;

# return value > 0 only if read present in database READS table

    if ($dbrefs->[0] > 0) {
        return $dbrefs->[0];
    } 
    else {
        return 0;
    }
}

#############################################################################

sub inDataBase {
# test where the named read is in the ARCTURUS database
    my $self     = shift;
    my $readname = shift; # read name
    my $dbsearch = shift || 0; # set true to search database if not found in cache
    my $append   = shift || 1; # set true if a missing read is to be added to PENDING
    my $assembly = shift || 0; # the assembly number 
    my $list     = shift || 0;

# print "inDataBase called from ContigBuilder for read $readname, pen $append $break" if $list;

# first test the (possibly) cached data
# if the read is not in the READS database test for it in PENDING table
# if not found && find, do a query

    my $dbrref = 0;
    my $dbpref = 0;
    my $hashes = 0;

    &timer('inDataBase',0) if $TIMER; 

    if (!$readname) {
        return 0, 0;
    }
# first look in the READS cache
    elsif ($hashes = $READS->cacheRecall($readname,{indexName=>'readname'})) {
        $dbrref = $hashes->[0]->{read_id} || 0;
#        $self->{clone} = $hashes->[0]->{clone};
#print "Read $readname found in READS $dbrref $break";
    }
# then look in the PENDING cache
    elsif ($hashes = $PENDS->cacheRecall($readname,{indexName=>'readname'})) {
        $dbpref = $hashes->[0]->{record}  || 0;
#print "Read $readname found in PENDING $dbpref $break";
    }
# if not found in either two tables: try find the read in the READS tablehandle
    elsif ($dbsearch) {
        &timer('inDataBase db-lookup',0) if $TIMER; 
        $dbrref = $READS->associate('read_id',$readname,'readname',{useCache => 0});
        $dbpref = $PENDS->associate('record' ,$readname,'readname',{useCache => 0}) if !$dbrref;
        &timer('inDataBase db-lookup',1) if $TIMER; 
    }

    &timer('inDataBase',1) if $TIMER; 

# if read not found in either READS or PENDING : add to PENDING

    if (!$dbrref && !$dbpref && $append) {
        &timer('inDataBase newrow',0) if $TIMER;
        if ($assembly) {
            $dbpref = $PENDS->newrow('readname',$readname,'assembly',$assembly);
        }
        else {
            $dbpref = $PENDS->newrow('readname',$readname);
        }
        &timer('inDataBase newrow',1) if $TIMER;
# error status checking
        print "Adding to PENDING: $readname (as $dbpref)$break" if ($list && !($dbpref%($list)));
        if (!$dbpref) {
            my $status = $self->{'status'};
            $status->{diagnosis} .= "! Failed to add entry $readname ";
            $status->{diagnosis} .= "to PENDING list$break";
            $status->{warning}++;
        }
    }

    return ($dbrref, $dbpref);
}

#############################################################################

sub preload {
# get database id (level=1) or mapping data (level=2) into hash %readstatus
    my $self  = shift;
    my $reads = shift || 0; # ref to ARRAY with readnames
    my $mask  = shift || '1100';

    my @mask = split //,$mask;

    my $where = '';
    my $query = '';

print "enter ReadMapper preload $reads $mask $break";

print "Building caches ('$mask') $break";

    if ($reads && ref($reads) eq 'ARRAY') {
# array mode
        my $extend = 0;
        my $nblock = 1000;
        my $nr = @$reads;
        my $ns = 1;
        while ($ns <= $nr) {
            my $nf = $ns + $nblock -1;
            $nf = $nr if ($nf > $nr);  
print "block ns=$ns  nf=$nf  nr=$nr $break";
            undef my @block;
	    for my $i ($ns .. $nf) {
                push @block, $reads->[$i-1];
#                push @block,(shift @$reads); # if removing buffer
            }
            $ns = $nf + 1;
# get the readname and read_id in the database (READS and PENDING)
            my $where = "where readname in (\"".(join '","',@block)."\")";

            if ($mask[0]) {
print "READS $break";
                $query = "select read_id,readname from <self> $where";    
#                $query = "select read_id,readname,clone from <self> $where";    
                $READS->cacheBuild($query,{indexKey=>'readname',extend=>$extend});
# get the read_id's from the readnames, using the cached data
            }
            if ($mask[1]) {
print "PENDS $break";
                $query = "select record,readname from <self> $where";
# print "$query $break";
                $PENDS->cacheBuild($query,{indexKey=>'readname',extend=>$extend});
            }

            if ($mask[2] || $mask[3]) {
# get the read_id's from the readnames, using the cached data
                my @readids;
                foreach my $read (@block) {
                    my $hash = $READS->cacheRecall($read,{indexName=>'readname'});
                    push @readids,$hash->[0]->{read_id} if $hash;
                }

                if (@readids) {
# cache the read to contig maps
                    $where = "where read_id in (".(join ',',@readids).")";
                    $query = "select *  from <self> $where";
print "RR2CC $break";
# print "$query $break";
                    my %options = (indexKey=>'read_id',extend=>$extend);
                    $options{sortBy} = 'edit,base';
                    $EDITS->cacheBuild($query,\%options) if $mask[3];
                    $options{sortBy} = 'deprecated,label';
                    $options{indexName} = 'mappings';
                    $RR2CC->cacheBuild($query,\%options) if $mask[2];
                }
            }
            $extend = 1;
        }
    }
# or load whole table
    else {
print "enter ReadMapper preload whole table $reads $break";

        my $query = "select read_id,readname from <self>";
#        my $query = "select read_id,readname,clone from <self>";
print "$query $break" if $mask[0];
        $READS->cacheBuild($query,{indexKey=>'readname'}) if $mask[0];
        $query = "select record,readname from <self>";
print "$query $break" if $mask[1];
        $PENDS->cacheBuild($query,{indexKey=>'readname'}) if $mask[1];

        $query = "select *  from <self>";
print "$query $break" if $mask[2];
        $RR2CC->cacheBuild($query,{indexKey=>'read_id', indexName=>'mappings', sortBy=>'deprecated, label'}) if $mask[2];
print "$query $break" if $mask[3];
        $EDITS->cacheBuild($query,{indexKey=>'read_id', sortBy=>'edit,base'}) if $mask[3];
    }
print "exit preload $break$break";
}

#############################################################################

sub tagList {
# e.g. list = tagList('FTAGS')
    my $self = shift;
    my $name = shift;

    my @TAGS  = ('FINL','FINR','ANNO','COMP','FICM','RCMP','POLY',
                 'REPT','OLIG','COMM');

    my $list  = eval "join '|',\@$name";
}

#############################################################################

sub fonts {

# return a hash with font specifications

    my %font = ( b=>'blue', o=>'orange', g=>'lightgreen', 'y'=>'yellow', e=>'</FONT>');

    foreach my $colour (keys %font) {
        if ($ENV{REQUEST_METHOD}) {
            $font{$colour} = "<FONT COLOR=$font{$colour}>" if ($colour ne 'e');
        }
        else {
            $font{$colour} = " ";
        }
    }

    return \%font;
}

#############################################################################
#############################################################################

# class method: testing before destroying all remaining ReadMapper object

sub flush {
    my $self = shift;
    my $keep = shift;

# flush mapping and PENDING tables

    $RR2CC->flush;
    $RR2AA->flush;
    $EDITS->flush;

# test the remaining ReadMapper instances using the currently cached data

print "Flushing ReadMappers$break";
    my @readnames;
    foreach my $readname (keys %ReadMapper) {
        my $instance = $ReadMapper{$readname};
        if ($instance->isInDataBase(0,0)) {
            $instance->delete if !$keep; # found in READS
        }
        elsif ($instance->{dbrefs}->[1] > 0) {
            $instance->delete if !$keep; # found in PENDING
        }
        else {
print "NOT FOUND IN CACHE: $readname $break";
            push @readnames,$readname;
        }
    }

    $PENDS->flush;

# @readnames contains all readnames not found in the database
# rebuild caches for these remaining files only; then test again
    
my $nr = @readnames; print "$nr reads to be re-investigated $break";
    return if !@readnames;

    &preload(0,\@readnames,'0100'); # build only PENDING

    foreach my $readname (@readnames) {
        my $instance = $ReadMapper{$readname};
        $instance->isInDataBase(0,1);
        $instance->delete if !$keep;
    }

# and flush the PENDING table again

    $PENDS->flush;
}

#############################################################################

sub timer {
# ad hoc local timer function
    my $name = shift;
    my $mark = shift;

    use MyTimer;

    $MyTimer = new MyTimer if !$MyTimer;

    $MyTimer->timer($name,$mark) if $MyTimer;
}


#############################################################################

sub setEnvironment {

# return the line break appropriate for the environment

    $CGI = $ENV{REQUEST_METHOD} ? 1 : 0;

    $break = $CGI ? "<br>" : "\n";
}

#############################################################################
#############################################################################

sub colophon {
    return colophon => {
        author  => "E J Zuiderwijk",
        id      =>            "ejz",
        group   =>       "group 81",
        version =>             0.9 ,
        date    =>    "16 Mar 2002",
        update  =>    "01 Oct 2003",
    };
}

1;

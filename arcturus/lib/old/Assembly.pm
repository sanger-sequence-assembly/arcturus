package Assembly;

#########################################################################
#
# Operations on an individual assembly
#
#########################################################################

use strict;

use ArcturusTableRow;

use Projects;

use vars qw(@ISA); # our qw(@ISA);

@ISA = qw(ArcturusTableRow);

#########################################################################
# Class variables
#########################################################################

my %Assembly;

my $break = $ENV{REQUEST_METHOD} ? "<br>" : "\n";

#########################################################################
# constructor new: create an Assembly instance
#########################################################################

sub new {
# create a new instance for the named or numbered assembly
    my $caller    = shift;
    my $assembly  = shift || 0; # (optional) number or name
    my $Organisms = shift;      # (optional) pass it an Organisms instance

    return $Assembly{$assembly} if $Assembly{$assembly};

    my $class = ref($caller) || $caller;

    my $ASSEMBLY; # for the handle to the ASSEMBLY database table

    if ($class eq ref($caller) && !$Organisms) {
# the new object is spawned from an existing instance of this class
        $Organisms = $caller->{Organisms};
        $ASSEMBLY  = $caller->tableHandle;
    }

# test the database table handle

    if (!$ASSEMBLY) {
# here we need to inherit from Organisms, which therefore must exist
        die "Missing Organisms reference" unless $Organisms;

        my $tableHandle = $Organisms->tableHandle; # of the ORGANISMS table
        my $database = $Organisms->get('dbasename');
# spawn the ASSEMBLY database table handle
        $ASSEMBLY = $tableHandle->spawn('ASSEMBLY',$database);
    }

# okay, we seem to have everything to build a new Assembly instance

    my $self = $class->SUPER::new($ASSEMBLY);

# add reference to the Organisms instance

    $self->{Organisms} = $Organisms;

# allocate key for projects of this assembly

    $self->{ProjectNames} = []; # array ref

# identify the assembly, either by number or by name and get the data

    my $loaded;
    my $column;

    if (!$assembly) {
# no assembly specified: get the default assembly
        $self = $self->getDefaultAssembly(0,$Organisms);
        $loaded = 1 unless $self->status(1);
    }
    else {
# decide if a name or a number is given
        $column = ($assembly =~ /\D/) ? 'assemblyname' : 'assembly';
        $loaded = $self->loadRecord($column,$assembly);
    }

# if assemblyname is not identified (!$loaded) it could be a project name

    if (!$loaded && $column && ($column =~ /name/)) {
# the name was not identified; try if it is a project name
        my $Projects = new Projects($assembly,$self);
        if (!$Projects->status()) {
# the name is identfied as a projectname; get its assembly number
            my $assembly = $Projects->get('assembly');
# load the data for the now known assembly number
            $loaded = $self->loadRecord('assembly',$assembly);
        }
    }


    if ($loaded) {
# define the default column for (possible) queries
        $self->setDefaultColumn('assemblyname');
# instantiate the default project for this assembly as current project
        my $Projects = new Projects(0,$self);
        $self->{currentProject} = $Projects;
# test if the default project lookup or creation has been successfull
        if (my $pstatus = $Projects->status()) {
# not really, add error status from Projects instance as warning to this assembly
            $self->putErrorStatus(0,$pstatus);
        }       
# add this assembly instance to the inventory
        my $contents = $self->{contents};
        $Assembly{$contents->{assembly}}     = $self;
        $Assembly{$contents->{assemblyname}} = $self;
    }

# finally, instantiate the default project for this assembly

    return $self;
}

#############################################################################

sub getDefaultAssembly {
# get/add the default BLOB assembly from/to the ASSEMBLY table
    my $self      = shift;
    my $Organisms = shift; # pass it an Organisms instance (for database info)
    my $new       = shift;

    $Organisms = $self->{Organisms} unless $Organisms;

    return 0 if (ref($Organisms) ne 'Organisms');

# identify the BLOB assembly

    my $tableHandle = $self->tableHandle;

    my $assembly = $tableHandle->associate('assembly','BLOB','assemblyname');

# if the default assembly already exists, spawn/return its Assembly instance

    return $self->new($assembly) if $assembly;

# the BLOB assembly does not yet exist, hence create it

    my $organism = $Organisms->get('number');
    my $creator  = $Organisms->get('creator') || 'arcturus';

    $self->put('organism',$organism);
    $self->put('assemblyname','BLOB');
    $self->put('comment','auto-generated by Assembly module');
    my $timestamp = $tableHandle->timestamp(0);
    $self->put('created',$timestamp);
    $self->put('creator',$creator);

    if ($self->newRow()) {
# assembly added okay; update the row in the ORGANISMS table
        my $count = $self->count || 'assemblies+1'; # print "count $count $break";
        $Organisms->put('assemblies',$count,1);        
# either spawn a new instance 
        return $self->new('BLOB') if $new;
# or (re)load the date into this instance
        $self->loadRecord('assemblyname','BLOB');
    }

    return $self; # always returns an instance
}

#############################################################################
# projects of this assembly
#############################################################################

sub getProjects {
# returns array of project names for all projects of this assembly
    my $self = shift;
    my $load = shift;

    $load = 1 unless @{$self->{ProjectNames}}; # force loading

    my $Projects = $self->{currentProject}; # a Projects instance

    $self->{ProjectNames} = $Projects->getProjects($self) if $load;

    return $self->{ProjectNames}; # retruns array reference
}

#############################################################################

sub putCurrentProject {
# (re)defines the default project and returns Project reference 
    my $self = shift;
    my $name = shift; # optional, a project name

    $self->clearErrorStatus;

    my $Projects = $self->{currentProject}; # instance of Projects class

    if (!$name) {
# restore the original default
        $self->{currentProject} = $Projects->getDefaultProject($self);
    }
    elsif (my $projects = $self->getProjects) {
# define a new default, but only if the project is among assembly projects
        my $found = 0;
        foreach my $project (@$projects) {

            if ($name eq $project) {
# create a new Projects instance
                my $Projects = new Projects($name);
                if (my $pstatus = $Projects->status) {
                    $self->putErrorStatus(0,$pstatus);
                }
                else {
# put the project as default project
                    $self->{currentProject} = $Projects;
                    $found = 1;
                }
                last;
            }
	}

# if the project cannot be found put a warning on this assembly

        $self->putErrorStatus(0,"Project $name does not exist") unless $found;
    }

    return $self->{currentProject};
}

#############################################################################

sub getCurrentProject {
# returns the default project (either database default or > putCurrentProject)
    my $self = shift;

    return $self->{currentProject}; # there always is one
}

#############################################################################
#
#############################################################################

#DEVELOPMENT


sub testAccessStatus {
# test the access status the current or the named assembly
# correct assembly status returns 0; an error status returns its description
    my $self     = shift;
    my $gtest    = shift; # optional, include test on generations of mappings 
    my $assembly = shift; # optional, assembly number or name

    if ($assembly) {
# spawn a new assembly object for this assembly
        my $Assembly = $self->new($assembly);
# and call this method again
        return $Assembly->testAssembly($gtest);
    }

# signal any error status on THIS Assembly

    my $status = $self->status(0); # errors only, no warnings tested
 
    return $status if $status; 

# we test the 'status' value of the assembly; this should be either
# 'virgin' or 'complete' with no data in generation 0 for this assembly
# or 'loading' with data in generation 0;

# including the generation test redefines $self->{G0} and $self->{G1} 

    $assembly   = $self->get('assembly');
    my $aname   = $self->get('assemblyname');

    my $astatus = $self->get('status')  || 'invalid';
    my $comment = $self->get('comment') || '';

my $TEST = 0;
print STDOUT "**** Testing assembly $assembly (astatus = $astatus) **** $break$break" if $TEST;
   
    my $report = 0;

    if ($astatus !~ /\b(virgen|complete|loading)\b/) {
# invalid assembly status flag
        $report = "Error status $astatus detected on assembly $aname: $comment";
    }

    elsif ($gtest) {

# test the presence of entries in generation 0 and 1 of this assembly

# astatus = 'virgen'  requires no entries at all for this assembly
#         = 'loading' is consistent with entries at generation 0
#         = 'complete is consistent with entries at generation 1 only

        my $tableHandle = $self->tableHandle;

        my $R2C = $tableHandle->spawn('READS2CONTIG');

        my $where = "assembly = $assembly";
        $where = "generation = 0 and ".$where if ($astatus ne 'virgin');

        $self->{G0} = $R2C->probe('contig_id',undef,$where);

        if ($self->{G0} && $astatus ne 'loading') {
            $report = "Inconsistent assembly status '$astatus' : generation 0 entries";
        }
        elsif (!$self->{G0} && $astatus eq 'loading') {
            $report = "Inconsistent assembly status '$astatus' : no generation 0 entries";
        }

# if the assembly is labeled as complete, test if there is indeed data in generation 1

        $where =~ s/0/1/; # replace '= 0' by '= 1'

        $self->{G1} = $R2C->probe('contig_id',undef,$where);

        if ($astatus eq 'complete' && !$self->{G1}) {
            $report = "Inconsistent assembly status '$astatus' : no generation 1 entries";
        }
print "G0 $self->{G0} ($where) $break" if $TEST;
print "last query on R2C: $R2C->{lastQuery}$break" if $TEST;
    }

    print "report $report $break" if $TEST;
    return $report;
}

#############################################################################
# actions on the whole of an assembly

# promote : to be executed after a new generation of mappings has been loaded
#            
#############################################################################

sub promote {
# upgrades 
# call this method after a CAF file has been processed completely
    my $self     = shift;
    my $assembly = shift;

    if ($assembly) {
# spawn a new assembly object for the assembly
        my $Assembly = $self->new($assembly);
# and call this method again
        return $Assembly->promote(0);        
    }

# test assembly?


# retire reads occuring in generation 1 but not in 0

print "retire readmaps in generation 1 but not in 0 $break";
    $self->retire;

# update the generation counter and cleanup the older generations

print "UPDATE and cleanup of generations $break";
    if (my $report = $self->ageByOne) {
        return "promote on assembly $assembly FAILED: $report $break";
    }

# ageByOne successful: remove readmaps marked with 'M' generation>1 and this assembly

    $self->reaper;

# HERE: update the data for the assembly status $self->assemblyUpdate($assembly,1);

# update counters and length for the current assembly at generation 1

    $self->updateAssembly(1);

    return;
}

##################################################################################
# retire and reap obsolete or older readmaps
##################################################################################

sub retire {
# to be invoked after generation 0 is completed: retire reads in G1 but not in G0
    my $self     = shift;
    my $assembly = shift || 0;

    my $retired = 0;

    my $ASSEMBLY = $self->{table};
    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');

    my $query  = "select G1.read_id from <self> as G1 left join <self> as G0 ";
    $query .= "on G1.read_id = G0.read_id where G0.label >= 10 and G1.label >= 10 and ";
    $query .= "G0.assembly = $assembly and G1.assembly = $assembly and ";
    $query .= "G0.generation = 0 and G1.generation = 1 and ";
    $query .= "G0.read_id = NULL";

    my $hashes = $R2C->query($query,{traceQuery=>0});
print "retire query $R2C->{lastQuery}$break";
print "retire hashes $hashes \n";
    if ($hashes && ref($hashes) eq 'ARRAY') {
my $length=@$hashes; print "retire hashes= $hashes $length $break"; print "retire hashes: @$hashes \n";
	$retired = @$hashes;
        foreach my $hash (@$hashes) {
            $hash = $hash->{read_id};
        }
print "retire: readid: @$hashes \n";
# retire: set deprecated to 'X' where read_id in (join ',',@$hashes) and generation=1
#        $R2C->update('deprecated','X','read_id',$hashes) if $assembly;     
    }

    $retired;

# NEW setup tests
#      select distinct(read_id) from READS2CONTIG, CONTIGS2CONTIG where
#      READS2CONTIG.contig_id = CONTIGS2CONTIG.oldcontig and
#      CONTIGS2CONTIG.generation=0;

#      select distinct read_id,deprecated from READS2CONTIG, CONTIGS2CONTIG where
#      READS2CONTIG.assembly=1 and READS2CONTIG.deprecated in ('M','N') and label>=10 and
#      READS2CONTIG.contig_id=CONTIGS2CONTIG.oldcontig and CONTIGS2CONTIG.generation=0;

#ysql> select distinct read_id,deprecated from READS2CONTIG, CONTIGS2CONTIG where
#   -> READS2CONTIG.assembly=1 and label>=10 and
#   -> READS2CONTIG.contig_id=CONTIGS2CONTIG.newcontig and CONTIGS2CONTIG.generation=0;
}

##################################################################################

sub reaper {
# cleanup all marked readmaps in older generations
    my $self     = shift;


    my $assembly = $self->{contents}->{assembly} || return 0;

# leave generation  1 untouched! (i.e. do reaper after ageByOne)

    my $ASSEMBLY = $self->{table};
    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');

    my $where = "generation > 1 AND deprecated = 'M' AND assembly=$assembly";
print "reaper: delete from READS2CONTIG where $where $break";
    $R2C->delete('where',$where) if ($assembly > 0);
}

##################################################################################


##################################################################################

sub ageByOne {
# increase all generation counters by one (after G0 is complete and G1 retired)
    my $self     = shift;
    my $assembly = shift || 0;

# only apply ageing if generation 0 exists

# this is a crucial step which MUST complete correctly; if not, any subsequent
# operation on the READS2CONTIG table will irretrievably corrupt the database.
# Therefore we first test the current status of the assembly and abort on error
# (block any action on READS2CONTIG).
# Subsequently we pre-set an error status on ASSEMBLY, and reset to 'completed'
# only if we are absolute sure that the process has terminated correctly.

# NOTE: the 'blocked' column on READS2CONTIG and operations upon it, could be
# replaced by a transaction protocol. However, speed is a consideration for
# actions on READS2CONTIG, and this way the overal process of dumping and ageing
# is faster

    my $ASSEMBLY = $self->{table};
    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');

    my $comment;

    my $where = "generation=0 AND assembly=$assembly";
    if ($assembly > 0 && $R2C->probe('contig_id',undef,$where)) {

# OKAY, there is a 0 generation to be processed, now test the current assembly status

        my $astatus = $ASSEMBLY->associate('status',$assembly,'assembly');
        if ($astatus eq 'error' || $astatus eq 'complete') {
            return "Invalid assembly status: $astatus";
        }
# test if any blocked entries exist as leftover of previous operations (there shouldn't)
        elsif ($R2C->probe('contig_id',undef,"assembly=$assembly and blocked='1'")) {
            return "Blocked entries detected in assembly $assembly";
        }

# OKAY, assembly status passed, preset the error flag 

        $ASSEMBLY->update('status','error','assembly',$assembly);
# we increase generation and set the blocked item
        my $query = "UPDATE <self> set generation=generation+1 WHERE assembly=$assembly"; # blocked taken out
#$query .= " limit 10000"; # test (partial) failure
        $R2C->query($query,{traceQuery=>0,timeStamp=>1}); # time stamp & no trace
#        $R2C->increment('generation','assembly',$assembly,1); # with allow query trace

# now test if any unblocked entries or generation 0 entries remain; if so, something has gone wrong

        $where = "assembly = $assembly and (generation = 0 or blocked = '0')";
        if ($R2C->probe('contig_id',undef,$where)) {
            $comment = "Last generation update attempt FAILED (partially)";
            $ASSEMBLY->update('comment',$comment,'assembly',$assembly);
        }
	else {
# the ageing was successful: remove the blocking flag and reset assembly status
            $R2C->update('blocked','0','assembly',$assembly); # remove the flag (replace by script afterwards)
#?           $C2C->update('generation','generation+1');
            $ASSEMBLY->update('status','complete','assembly',$assembly);
            my $completed = "Last generation update successfully completed";
            $ASSEMBLY->update('comment',$completed,'assembly',$assembly);
        }
    }
    else {
        $comment = "ContigBuilder::ageByOne FAILED: there is no generation 0";
    }

    return $comment; # undef for success, else error status
}


#############################################################################

sub unbuild {
# remove generation 0 for given assembly from the database
    my $self     = shift;
    my $assembly = shift;

# only apply if generation 0 exists and assembly status != error

    my $ASSEMBLY = $self->{table};
    my $R2C      = $ASSEMBLY->spawn('READS2CONTIG');
    my $CONTIGS  = $ASSEMBLY->spawn('CONTIGS');
    my $SEQUENCE = $ASSEMBLY->spawn('CONSENSUS');
    my $C2P      = $ASSEMBLY->spawn('CONTIGS2PROJECTS');
    my $C2C      = $ASSEMBLY->spawn('CONTIGS2CONTIG');
    my $T2C      = $ASSEMBLY->spawn('TAGS2CONTIG');

    my $comment;

    my $where = "generation=0 AND assembly=$assembly";
    if ($assembly > 0 && $R2C->probe('contig_id',undef,$where)) {

# OKAY, there is a 0 generation to be processed, now test the current assembly status

        my $astatus = $ASSEMBLY->associate('status',$assembly,'assembly');
        if ($astatus eq 'error' || $astatus eq 'completed') {
            return "Invalid assembly status: $astatus";
        }
# test if any blocked entries exist as leftover of previous operations (there shouldn't)
        elsif ($R2C->probe('contig_id',undef,"assembly=$assembly and blocked='1'")) {
            return "Blocked entries detected in assembly $assembly";
        }

# okay, now remove (this is not the fastest implementation!)

#        my $DBVERSION = $CONTIGS->dbVersion;

        my $where = "assembly = $assembly and generation = 0";
        my %qoptions = (returnScalar => 0, traceQuery => 0, orderBy => 'contig_id');
        my $contigs = $R2C->associate('distinct contig_id','where',$where,\%qoptions);

# should be blocked

 return "Test abort";

        $R2C->delete('where',$where);

        my $block = 500;
        while (@$contigs) {
            $block = @$contigs if ($block > @$contigs);
print "processing next block $block $break";
            undef my @block;
            for (my $i = 0 ; $i < $block ; $i++) {
                push @block, (shift @$contigs);
            }
            $where = "contig_id in (".join(',',@block).")";
#print "query $where $break";
            $C2P->delete('where',$where);   # to project
            $T2C->delete('where',$where);   # tags
# missing here GENE2CONTIG & CLONES2CONTIG
            $CONTIGS->delete('where',$where);  # contigs
	    $where =~ s/contig_id/newcontig/;
            $C2C->delete('where',$where);   # contig to contig
            $where =~ s/newcontig/contig_uid/;
            $SEQUENCE->delete('where',$where); # consensus
	}

# restore the status of the assembly for generation 1

        $self->updateAssembly($assembly,1);

    }
    else {
        $comment = "ContigBuilder::unbuild FAILED: there is no generation 0";
    }

    return $comment;
}

#############################################################################

sub updateMetaData {
# update counters and length for the current assembly
    my $self       = shift;
    my $generation = shift;
    my $assembly   = shift;

    $generation = 1 unless defined($generation);

    if ($assembly) {
# spawn a new assembly object for this assembly
        my $Assembly = $self->new($assembly);
# and call this method again
        return $Assembly->testAssembly($generation);
    }

    my $status = $self->testAccessStatus(1); # include generations test

    return $status if $status; # exit with error report

# test if the generation provided is populated

    my $G = "G$generation";

    return "Generation $generation contains no data" if !$self->{$G};

# 

    my $list = 1;
    my $ASSEMBLY = $self->tableHandle;
    my $CONTIGS  = $ASSEMBLY->spawn('CONTIGS');
    my $R2C      = $ASSEMBLY->spawn('READS2CONTIG');

    my $DBVERSION = $ASSEMBLY->dbVersion;

# the next will work for version 4.1, using sub query

    if ($DBVERSION =~ /^4\.1\./) {
print "$DBVERSION getting length and L2000 ... " if $list;
        my $query = "select sum(length) as sum from CONTIGS where contig_id in ";
        $query .= "(select distinct contig_id from READS2CONTIG where ";
        $query   .= "assembly = $assembly and generation = 1)";
        my $length = $CONTIGS->query($query,{traceQuery=>0});
#        $ASSEMBLY->update('length',$length->[0]->{sum},'assembly',$assembly);

        $self->put('length',$length->[0]->{sum});
print "total = $length & " if $list;

        $query =~ s/where/where length>=2000 and/; # only the irst one
        $length = $CONTIGS->query($query,{traceQuery=>0});
#        $ASSEMBLY->update('l2000',$length->[0]->{sum},'assembly',$assembly);
        
        $self->put('l2000',$length->[0]->{sum});
        
print "l2000 = $length & " if $list;
    }

# for MySQL versions below 4.1 fall back on indirect method 

    else {
print "VERSION $DBVERSION ${break}getting length and L2000 ... " if $list;
        my $where = "assembly = $assembly and generation = $generation";
        $where .= " and label>=10 and deprecated in ('N','M')";
        my %qoptions = (returnScalar => 0, traceQuery => 0, orderBy => 'contig_id');
        my $contigs = $R2C->associate('distinct contig_id','where',$where,\%qoptions);
        my $query = "select sum(length) as sum from <self> where contig_id in (".join(',',@$contigs).")";
        my $length = $CONTIGS->query($query,{traceQuery=>0});
#       $ASSEMBLY->update('length',$length->[0]->{sum},'assembly',$assembly);
        $self->put('length',$length->[0]->{sum});

print "total $length->[0]->{sum}   $break" if $list;
        $query =~ s/where/where length>=2000 and/; # only once
        $length = $CONTIGS->query($query,{traceQuery=>0});
print "l2000 query: $CONTIGS->{lastQuery} \n" if $list;
#       $ASSEMBLY->update('l2000',$length->[0]->{sum},'assembly',$assembly);
print "l2000 = $length->[0]->{sum}  $break" if $list;

        $self->put('l2000',$length->[0]->{sum});
    }

# get the total counts for this assembly

print "Update counters for assembly $assembly ... " if $list;
    my $where = "assembly = $assembly and label>=10 and deprecated in ('N','M')";
print "all contigs in assembly $assembly ... $break" if $list;
    my $ncontig = $R2C->count($where,'distinct contig_id');
#    $ASSEMBLY->update('allcontigs',$ncontig,'assembly',$assembly);
    $self->put('allcontigs',$ncontig);
print "all reads in assembly $assembly ... $break" if $list;
    my $nreads  = $R2C->count($where,'distinct read_id');
#    $ASSEMBLY->update('reads',$nreads,'assembly',$assembly);
    $self->put('reads',$nreads);

# contig count and read count for the assembly of generation

    $where .= " and generation = $generation";
print "contigs in assembly $assembly and generation $generation$break" if $list;
    $ncontig = $R2C->count($where,'distinct contig_id');
#    $ASSEMBLY->update('contigs',$ncontig,'assembly',$assembly);
    $self->put('contigs',$ncontig);
print "assembled reads in assembly $assembly and generation $generation$break" if $list;
    $nreads  = $R2C->count($where,'distinct read_id');
#    $ASSEMBLY->update('assembled',$nreads,'assembly',$assembly);
    $self->put('assembled',$nreads);

# finally set the loading status

    $self->put('status', 'loading') if ($generation == 0);
    $self->put('status','complete') if ($generation == 1);

    return 0;
}

#############################################################################

#sub setEnvironment {#

# return the line break appropriate for the environment

#    my $CGI = $ENV{REQUEST_METHOD} ? 1 : 0;

#    $break = $ENV{REQUEST_METHOD} ? "<br>" : "\n";
#}

#############################################################################

sub colophon {
    return colophon => {
        author  => "E J Zuiderwijk",
        id      =>            "ejz",
        group   =>       "group 81",
        version =>             0.9 ,
        updated =>    "18 Feb 2004",
        date    =>    "10 Feb 2004",
    };
}

#############################################################################

1;

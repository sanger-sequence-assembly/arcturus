package Assembly;

#########################################################################
#
# Operations on an individual assembly
#
#########################################################################

use strict;

use ArcturusTableRow;

use Projects;

use vars qw(@ISA); # our qw(@ISA);

@ISA = qw(ArcturusTableRow);

#########################################################################
# Class variables
#########################################################################

my %Assembly;

my $ASSEMBLY; # table handle for ASSEMBLY table

my $break;

#########################################################################
# constructor init
#########################################################################

sub init {
# initialise by defining the ASSEMBLY table handle
    my $prototype = shift;
    my $tblhandle = shift; # handle to any table
    my $database  = shift; # optional 

# the default database is taken from the table handle

    my $class = ref($prototype) || $prototype;

    my $self  = {};
    bless ($self, $class);

    $ASSEMBLY = $tblhandle->spawn('ASSEMBLY',$database);

#    Projects->init($ASSEMBLY);

    return $self;
}

#########################################################################
# constructor new: create an Assembly instance
#########################################################################

sub new {
# create a new instance for the named or numbered assembly
    my $caller    = shift;
    my $assembly  = shift || 0; # (optional) number or name
    my $Organisms = shift;      # (optional) pass it an Organisms instance

    die "Assembly must be initialised with the init method" unless $ASSEMBLY;

print "Assembly.pm new for assembly $assembly<br>\n";

    return $Assembly{$assembly} if $Assembly{$assembly};

    my $class = ref($caller) || $caller;

#    my $ASSEMBLY;

    if ($class eq ref($caller) && !$Organisms) {
# the new object is spawned from an existing instance of this class
        $Organisms = $caller->{Organisms};
        $ASSEMBLY = $caller->tableHandle;
    }

# test the database table handle

    if (!$ASSEMBLY) {
# here we need to inherit from Organisms, which therefore must exist
        die "Missing Organisms reference" unless $Organisms;

        my $tableHandle = $Organisms->tableHandle; # of the ORGANISMS table
        my $database = $Organisms->get('dbasename');
# spawn the ASSEMBLY database table handle
        $ASSEMBLY = $tableHandle->spawn('ASSEMBLY',$database);
    }

# okay, we seem to have everything to build a new instance

    my $self = $class->SUPER::new($ASSEMBLY);

# identify the assembly, either by number or by name and get the data

    my $loaded;
    my $column;

    if (!$assembly) {
# get the default assembly
        $self = $self->getDefaultAssembly(0);
        $loaded = 1 unless $self->status(1);
    }
    else {
# decide if it is a name or a number
        $column = ($assembly =~ /\D/) ? 'assemblyname' : 'assembly';
        $loaded = $self->loadRecord($column,$assembly);
    }

# if assemblyname not identified it could be a project name: try to do a project name 

    if (!$loaded && ($column =~ /name/)) {
# the name was not identified; try if it is a project name
        $self->put('table',$ASSEMBLY);
        my $Project = new Project($assembly,$self);
        if (!$Project->status()) {
# the name is identfied as a projectname; get its assembly number
            my $assembly = $Project->get('assembly');
# replace $self by a new object spawned for the now known assembly number
            $loaded = $self->loadRecord('assembly',$assembly);
        }
    }


    if ($loaded) {
# add this instance to the inventory
        my $contents = $self->{contents};
        $Assembly{$contents->{assembly}}     = $self;
        $Assembly{$contents->{assemblyname}} = $self;
    }

    $self->{Organisms} = $Organisms;

    return $self;
}

#############################################################################

sub getDefaultAssembly {
# get/add the default BLOB assembly from/to the ASSEMBLY table
    my $self = shift;
    my $new  = shift;

# identify the BLOB assembly

    my $tableHandle = $self->tableHandle;

    my $assembly = $tableHandle->associate('assembly','BLOB','assemblyname');
print "default BLOB has assembly nr $assembly <br>";

# if the default assembly already exists, spawn/return its Assembly instance

    return $self->new($assembly) if $assembly; # the default assembly already exists

# the BLOB assembly does not yet exist, hence create it

    $self->put('assemblyname','BLOB');
    $self->put('comment','auto-generated by Assembly module');
    my $timestamp = $tableHandle->timestamp(0);
    $self->put('created',$timestamp);
    $self->put('creator','arcturus');

    if ($self->newRow()) {
# either spawn a new instance 
        return $self->new('BLOB') if $new;
# or (re)load the date into this instance
        $self->loadRecord('assemblyname','BLOB');
    }

    return $self; # always returns an instance
}

#############################################################################

sub projects {
# return Projects instances for all projects of this assembly
    my $self = shift;

}

#############################################################################

sub testAssembly {
# test the access status the current or the named assembly
    my $self     = shift;
    my $ginclude = shift; # include test on generations of mappings 
    my $assembly = shift; # optional

    if ($assembly) {
# spawn a new assembly object for this assembly
        my $Assembly = $self->new($assembly);
# and call this method again
        return $Assembly->testAssembly($ginclude);        
    }

# signal any error status on this module

    return $self->{status}->{diagnosis} if ($self->{status}->{errors});
 
#    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');
    my $R2C = $self->{table}->spawn('READS2CONTIG');

# we test the 'status' value of the assembly; this should be either
# 'virgin' or 'complete' with no data in generation 0 for this assembly'
# or 'loading' with data in generation 0;
   
    my $report = 0;

    my $content = $self->{contents}; 

    my $astatus = $content->{status} || 'invalid';

print STDOUT "**** Testing assembly $assembly **** $break$break";

    if ($astatus !~ /\b(virgen|complete|loading)\b/) {
# invalid assembly status flag
        $report = "Error status $astatus detected on assembly ";
        $report = "$content->{assemblyname}: $content->{comment}$break";
    }

    elsif ($ginclude) {
# test the presence of entries (in generation 0) of this assembly
        my $where = "assembly = $content->{assembly}";
        $where = "generation = 0 and ".$where if ($astatus ne 'virgin');

        my $gzero = $R2C->probe('contig_id',undef,$where);

        if ($gzero && $astatus ne 'loading') {
            $report = "Inconsistent assembly status '$astatus' : generation 0 entries$break";
        }
        elsif (!$gzero && $astatus eq 'loading') {
            $report = "Inconsistent assembly status '$astatus' : no generation 0 entries$break";
        }
#        $report = '' unless $ginclude;
    }

# WHAT about projects? If no project available, auto create the bin project?

    return $report;
}


#############################################################################
# actions on the whole of an assembly

# promote : to be executed after a new generation of mappings has been loaded
#            
#############################################################################

sub promote {
# upgrades 
# call this method after a CAF file has been processed completely
    my $self     = shift;
    my $assembly = shift;

    if ($assembly) {
# spawn a new assembly object for the assembly
        my $Assembly = $self->new($assembly);
# and call this method again
        return $Assembly->promote(0);        
    }

# test assembly?


# retire reads occuring in generation 1 but not in 0

print "retire readmaps in generation 1 but not in 0 $break";
    $self->retire;

# update the generation counter and cleanup the older generations

print "UPDATE and cleanup of generations $break";
    if (my $report = $self->ageByOne) {
        return "promote on assembly $assembly FAILED: $report $break";
    }

# ageByOne successful: remove readmaps marked with 'M' generation>1 and this assembly

    $self->reaper;

# HERE: update the data for the assembly status $self->assemblyUpdate($assembly,1);

# update counters and length for the current assembly at generation 1

    $self->updateAssembly(1);

    return;
}

##################################################################################
# retire and reap obsolete or older readmaps
##################################################################################

sub retire {
# to be invoked after generation 0 is completed: retire reads in G1 but not in G0
    my $self     = shift;
    my $assembly = shift || 0;

    my $retired = 0;

    my $ASSEMBLY = $self->{table};
    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');

    my $query  = "select G1.read_id from <self> as G1 left join <self> as G0 ";
    $query .= "on G1.read_id = G0.read_id where G0.label >= 10 and G1.label >= 10 and ";
    $query .= "G0.assembly = $assembly and G1.assembly = $assembly and ";
    $query .= "G0.generation = 0 and G1.generation = 1 and ";
    $query .= "G0.read_id = NULL";

    my $hashes = $R2C->query($query,{traceQuery=>0});
print "retire query $R2C->{lastQuery}$break";
print "retire hashes $hashes \n";
    if ($hashes && ref($hashes) eq 'ARRAY') {
my $length=@$hashes; print "retire hashes= $hashes $length $break"; print "retire hashes: @$hashes \n";
	$retired = @$hashes;
        foreach my $hash (@$hashes) {
            $hash = $hash->{read_id};
        }
print "retire: readid: @$hashes \n";
# retire: set deprecated to 'X' where read_id in (join ',',@$hashes) and generation=1
#        $R2C->update('deprecated','X','read_id',$hashes) if $assembly;     
    }

    $retired;

# NEW setup tests
#      select distinct(read_id) from READS2CONTIG, CONTIGS2CONTIG where
#      READS2CONTIG.contig_id = CONTIGS2CONTIG.oldcontig and
#      CONTIGS2CONTIG.generation=0;

#      select distinct read_id,deprecated from READS2CONTIG, CONTIGS2CONTIG where
#      READS2CONTIG.assembly=1 and READS2CONTIG.deprecated in ('M','N') and label>=10 and
#      READS2CONTIG.contig_id=CONTIGS2CONTIG.oldcontig and CONTIGS2CONTIG.generation=0;

#ysql> select distinct read_id,deprecated from READS2CONTIG, CONTIGS2CONTIG where
#   -> READS2CONTIG.assembly=1 and label>=10 and
#   -> READS2CONTIG.contig_id=CONTIGS2CONTIG.newcontig and CONTIGS2CONTIG.generation=0;
}

##################################################################################

sub reaper {
# cleanup all marked readmaps in older generations
    my $self     = shift;


    my $assembly = $self->{contents}->{assembly} || return 0;

# leave generation  1 untouched! (i.e. do reaper after ageByOne)

    my $ASSEMBLY = $self->{table};
    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');

    my $where = "generation > 1 AND deprecated = 'M' AND assembly=$assembly";
print "reaper: delete from READS2CONTIG where $where $break";
    $R2C->delete('where',$where) if ($assembly > 0);
}

##################################################################################


##################################################################################

sub ageByOne {
# increase all generation counters by one (after G0 is complete and G1 retired)
    my $self     = shift;
    my $assembly = shift || 0;

# only apply ageing if generation 0 exists

# this is a crucial step which MUST complete correctly; if not, any subsequent
# operation on the READS2CONTIG table will irretrievably corrupt the database.
# Therefore we first test the current status of the assembly and abort on error
# (block any action on READS2CONTIG).
# Subsequently we pre-set an error status on ASSEMBLY, and reset to 'completed'
# only if we are absolute sure that the process has terminated correctly.

# NOTE: the 'blocked' column on READS2CONTIG and operations upon it, could be
# replaced by a transaction protocol. However, speed is a consideration for
# actions on READS2CONTIG, and this way the overal process of dumping and ageing
# is faster

    my $ASSEMBLY = $self->{table};
    my $R2C = $ASSEMBLY->spawn('READS2CONTIG');

    my $comment;

    my $where = "generation=0 AND assembly=$assembly";
    if ($assembly > 0 && $R2C->probe('contig_id',undef,$where)) {

# OKAY, there is a 0 generation to be processed, now test the current assembly status

        my $astatus = $ASSEMBLY->associate('status',$assembly,'assembly');
        if ($astatus eq 'error' || $astatus eq 'complete') {
            return "Invalid assembly status: $astatus";
        }
# test if any blocked entries exist as leftover of previous operations (there shouldn't)
        elsif ($R2C->probe('contig_id',undef,"assembly=$assembly and blocked='1'")) {
            return "Blocked entries detected in assembly $assembly";
        }

# OKAY, assembly status passed, preset the error flag 

        $ASSEMBLY->update('status','error','assembly',$assembly);
# we increase generation and set the blocked item
        my $query = "UPDATE <self> set generation=generation+1 WHERE assembly=$assembly"; # blocked taken out
#$query .= " limit 10000"; # test (partial) failure
        $R2C->query($query,{traceQuery=>0,timeStamp=>1}); # time stamp & no trace
#        $R2C->increment('generation','assembly',$assembly,1); # with allow query trace

# now test if any unblocked entries or generation 0 entries remain; if so, something has gone wrong

        $where = "assembly = $assembly and (generation = 0 or blocked = '0')";
        if ($R2C->probe('contig_id',undef,$where)) {
            $comment = "Last generation update attempt FAILED (partially)";
            $ASSEMBLY->update('comment',$comment,'assembly',$assembly);
        }
	else {
# the ageing was successful: remove the blocking flag and reset assembly status
            $R2C->update('blocked','0','assembly',$assembly); # remove the flag (replace by script afterwards)
#?           $C2C->update('generation','generation+1');
            $ASSEMBLY->update('status','complete','assembly',$assembly);
            my $completed = "Last generation update successfully completed";
            $ASSEMBLY->update('comment',$completed,'assembly',$assembly);
        }
    }
    else {
        $comment = "ContigBuilder::ageByOne FAILED: there is no generation 0";
    }

    return $comment; # undef for success, else error status
}


#############################################################################

sub unbuild {
# remove generation 0 for given assembly from the database
    my $self     = shift;
    my $assembly = shift;

# only apply if generation 0 exists and assembly status != error

    my $ASSEMBLY = $self->{table};
    my $R2C      = $ASSEMBLY->spawn('READS2CONTIG');
    my $CONTIGS  = $ASSEMBLY->spawn('CONTIGS');
    my $SEQUENCE = $ASSEMBLY->spawn('CONSENSUS');
    my $C2P      = $ASSEMBLY->spawn('CONTIGS2PROJECTS');
    my $C2C      = $ASSEMBLY->spawn('CONTIGS2CONTIG');
    my $T2C      = $ASSEMBLY->spawn('TAGS2CONTIG');

    my $comment;

    my $where = "generation=0 AND assembly=$assembly";
    if ($assembly > 0 && $R2C->probe('contig_id',undef,$where)) {

# OKAY, there is a 0 generation to be processed, now test the current assembly status

        my $astatus = $ASSEMBLY->associate('status',$assembly,'assembly');
        if ($astatus eq 'error' || $astatus eq 'completed') {
            return "Invalid assembly status: $astatus";
        }
# test if any blocked entries exist as leftover of previous operations (there shouldn't)
        elsif ($R2C->probe('contig_id',undef,"assembly=$assembly and blocked='1'")) {
            return "Blocked entries detected in assembly $assembly";
        }

# okay, now remove (this is not the fastest implementation!)

#        my $DBVERSION = $CONTIGS->dbVersion;

        my $where = "assembly = $assembly and generation = 0";
        my %qoptions = (returnScalar => 0, traceQuery => 0, orderBy => 'contig_id');
        my $contigs = $R2C->associate('distinct contig_id','where',$where,\%qoptions);

# should be blocked

 return "Test abort";

        $R2C->delete('where',$where);

        my $block = 500;
        while (@$contigs) {
            $block = @$contigs if ($block > @$contigs);
print "processing next block $block $break";
            undef my @block;
            for (my $i = 0 ; $i < $block ; $i++) {
                push @block, (shift @$contigs);
            }
            $where = "contig_id in (".join(',',@block).")";
#print "query $where $break";
            $C2P->delete('where',$where);   # to project
            $T2C->delete('where',$where);   # tags
# missing here GENE2CONTIG & CLONES2CONTIG
            $CONTIGS->delete('where',$where);  # contigs
	    $where =~ s/contig_id/newcontig/;
            $C2C->delete('where',$where);   # contig to contig
            $where =~ s/newcontig/contig_uid/;
            $SEQUENCE->delete('where',$where); # consensus
	}

# restore the status of the assembly for generation 1

        $self->updateAssembly($assembly,1);

    }
    else {
        $comment = "ContigBuilder::unbuild FAILED: there is no generation 0";
    }

    return $comment;
}

#############################################################################

sub updateAssembly {
# update counters and length for the current assembly
    my $self       = shift;
    my $assembly   = shift || 1;
    my $generation = shift || 0;
    my $list       = shift;

# test if the generation provided is legal

    my $ASSEMBLY = $self->{table};
    my $CONTIGS  = $ASSEMBLY->spawn('CONTIGS');
    my $R2C      = $ASSEMBLY->spawn('READS2CONTIG');

    my $accept = -1;

    if ($ASSEMBLY->associate('status',$assembly,'assembly') eq 'error') {
        print "Error status on assembly $assembly $break" if $list;
        return 0;
    }
    elsif ($R2C->probe('contig_id',undef,"assembly=$assembly and blocked='1'")) {
        print "Blocked status on assembly $assembly $break" if $list;
        return 0;
    }
    elsif ($R2C->probe('contig_id',undef,"generation=0 AND assembly=$assembly")) {
        $accept = 0;
    }
    elsif ($R2C->probe('contig_id',undef,"generation=1 AND assembly=$assembly")) {
        $accept = 1;
    }

    print "update assembly $assembly cleared for generation $accept\n" if $list;

    return 0 if ($accept < 0 || $accept != $generation);

    my $DBVERSION = $ASSEMBLY->dbVersion;

# the next will work for version 4.1, using sub query

    if ($DBVERSION =~ /^4\.1\./) {
print "$DBVERSION getting length and L2000 ... " if $list;
        my $query = "select sum(length) as sum from CONTIGS where contig_id in ";
        $query .= "(select distinct contig_id from READS2CONTIG where ";
        $query   .= "assembly = $assembly and generation = 1)";
        my $length = $CONTIGS->query($query,{traceQuery=>0});
        $ASSEMBLY->update('length',$length->[0]->{sum},'assembly',$assembly);
print "total = $length & " if $list;

        $query =~ s/where/where length>=2000 and/; # only the irst one
        $length = $CONTIGS->query($query,{traceQuery=>0});
        $ASSEMBLY->update('l2000',$length->[0]->{sum},'assembly',$assembly);
print "l2000 = $length & " if $list;
    }

# for MySQL versions below 4.1 fall back on indirect method 

    else {
        print "VERSION $DBVERSION ${break}getting length and L2000 ... " if $list;
        my $where = "assembly = $assembly and generation = $generation";
        $where .= " and label>=10 and deprecated in ('N','M')";
        my %qoptions = (returnScalar => 0, traceQuery => 0, orderBy => 'contig_id');
        my $contigs = $R2C->associate('distinct contig_id','where',$where,\%qoptions);
        my $query = "select sum(length) as sum from <self> where contig_id in (".join(',',@$contigs).")";
        my $length = $CONTIGS->query($query,{traceQuery=>0});
        $ASSEMBLY->update('length',$length->[0]->{sum},'assembly',$assembly);
print "total $length->[0]->{sum}   $break" if $list;
        $query =~ s/where/where length>=2000 and/; # only once
        $length = $CONTIGS->query($query,{traceQuery=>0});
print "l2000 query: $CONTIGS->{lastQuery} \n" if $list;
        $ASSEMBLY->update('l2000',$length->[0]->{sum},'assembly',$assembly);
print "l2000 = $length->[0]->{sum}  $break" if $list;
    }

# get the total counts for this assembly

    print "Update counters for assembly $assembly ... " if $list;
    my $where = "assembly = $assembly and label>=10 and deprecated in ('N','M')";
    print "all contigs in assembly $assembly ... $break" if $list;
    my $ncontig = $R2C->count($where,'distinct contig_id');
    $ASSEMBLY->update('allcontigs',$ncontig,'assembly',$assembly);
    print "all reads in assembly $assembly ... $break" if $list;
    my $nreads  = $R2C->count($where,'distinct read_id');
    $ASSEMBLY->update('reads',$nreads,'assembly',$assembly);

# contig count and read count for the assembly of generation

    $where .= " and generation = $generation";
    print "contigs in assembly $assembly and generation $generation$break" if $list;
    $ncontig = $R2C->count($where,'distinct contig_id');
    $ASSEMBLY->update('contigs',$ncontig,'assembly',$assembly);
    print "assembled reads in assembly $assembly and generation $generation$break" if $list;
    $nreads  = $R2C->count($where,'distinct read_id');
    $ASSEMBLY->update('assembled',$nreads,'assembly',$assembly);

# finally set the loading status

    $ASSEMBLY->update('status', 'loading','assembly',$assembly) if ($generation == 0);
    $ASSEMBLY->update('status','complete','assembly',$assembly) if ($generation == 1);

    return 1;
}

#############################################################################

sub setEnvironment {

# return the line break appropriate for the environment

#    my $CGI = $ENV{REQUEST_METHOD} ? 1 : 0;

    $break = $ENV{REQUEST_METHOD} ? "<br>" : "\n";
}

#############################################################################

sub colophon {
    return colophon => {
        author  => "E J Zuiderwijk",
        id      =>            "ejz",
        group   =>       "group 81",
        version =>             1.1 ,
        updated =>    "10 Feb 2004",
        date    =>    "10 Feb 2004",
    };
}

#############################################################################

1;
